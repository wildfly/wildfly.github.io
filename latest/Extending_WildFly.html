<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="author" content="WildFly code development team">
<title>Extending WildFly</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/*! Stylesheet for CodeRay to loosely match GitHub themes | MIT License */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid;opacity:.35;padding:0 .5em 0 0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff!important;background:navy!important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:navy}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:teal}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:teal}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:teal}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:teal}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body id="Extending_WildFly" class="book toc2 toc-left">
<div id="header">
<h1>Extending WildFly</h1>
<div class="details">
<span id="author" class="author">WildFly code development team</span><br>
<span id="revnumber">version 29.0.0.Final,</span>
<span id="revdate">2023-07-20T17:19:12Z</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Extending WildFly</div>
<ul class="sectlevel1">
<li><a href="#target-audience">1. Target Audience</a>
<ul class="sectlevel2">
<li><a href="#prerequisites">1.1. Prerequisites</a></li>
<li><a href="#examples-in-this">1.2. Examples in this guide</a></li>
</ul>
</li>
<li><a href="#Example_subsystem">2. Example subsystem</a>
<ul class="sectlevel2">
<li><a href="#create-the-skeleton-project">2.1. Create the skeleton project</a></li>
<li><a href="#create-the-schema">2.2. Create the schema</a></li>
<li><a href="#design-and-define-the-model-structure">2.3. Design and define the model structure</a></li>
<li><a href="#parsing-and-marshalling-of-the-subsystem-xml">2.4. Parsing and marshalling of the subsystem xml</a></li>
<li><a href="#add-the-deployers">2.5. Add the deployers</a></li>
<li><a href="#integrate-with-wildfly">2.6. Integrate with WildFly</a></li>
<li><a href="#expressions">2.7. Expressions</a></li>
</ul>
</li>
<li><a href="#Working_with_WildFly_Capabilities">3. Working with WildFly Capabilities</a>
<ul class="sectlevel2">
<li><a href="#capabilities">3.1. Capabilities</a></li>
<li><a href="#capability-contract">3.2. Capability Contract</a></li>
<li><a href="#capability-registry">3.3. Capability Registry</a></li>
<li><a href="#using-capabilities">3.4. Using Capabilities</a></li>
</ul>
</li>
<li><a href="#Domain_Mode_Subsystem_Transformers">4. Domain Mode Subsystem Transformers</a>
<ul class="sectlevel2">
<li><a href="#background">4.1. Background</a></li>
<li><a href="#versions-and-backward-compatibility">4.2. Versions and backward compatibility</a></li>
<li><a href="#the-role-of-transformers">4.3. The role of transformers</a></li>
<li><a href="#how-do-i-know-what-needs-to-be-transformed">4.4. How do I know what needs to be transformed?</a></li>
<li><a href="#how-do-i-write-a-transformer">4.5. How do I write a transformer?</a></li>
<li><a href="#evolving-transformers-with-subsystem-modelversions">4.6. Evolving transformers with subsystem ModelVersions</a></li>
<li><a href="#testing-transformers">4.7. Testing transformers</a></li>
<li><a href="#common-transformation-use-cases">4.8. Common transformation use-cases</a></li>
</ul>
</li>
<li><a href="#Key_Interfaces_and_Classes_Relevant_to_Extension_Developers">5. Key Interfaces and Classes Relevant to Extension Developers</a>
<ul class="sectlevel2">
<li><a href="#extension-interface">5.1. Extension Interface</a></li>
<li><a href="#wildfly-managed-resources">5.2. WildFly Managed Resources</a></li>
<li><a href="#managementresourceregistration-interface">5.3. ManagementResourceRegistration Interface</a></li>
<li><a href="#resourcedefinition-interface">5.4. ResourceDefinition Interface</a></li>
<li><a href="#attributedefinition-class">5.5. AttributeDefinition Class</a></li>
<li><a href="#operationdefinition-and-operationstephandler-interfaces">5.6. OperationDefinition and OperationStepHandler Interfaces</a></li>
<li><a href="#operation-execution-and-the-operationcontext">5.7. Operation Execution and the OperationContext</a></li>
<li><a href="#resource-interface">5.8. Resource Interface</a></li>
<li><a href="#deploymentunitprocessor-interface">5.9. DeploymentUnitProcessor Interface</a></li>
<li><a href="#useful-classes-for-implementing-operationstephandler">5.10. Useful classes for implementing OperationStepHandler</a></li>
</ul>
</li>
<li><a href="#WildFly_JNDI_Implementation">6. WildFly JNDI Implementation</a>
<ul class="sectlevel2">
<li><a href="#introduction">6.1. Introduction</a></li>
<li><a href="#architecture">6.2. Architecture</a></li>
<li><a href="#binding-apis">6.3. Binding APIs</a></li>
<li><a href="#resource-ref-processing">6.4. Resource Ref Processing</a></li>
</ul>
</li>
<li><a href="#CLI_extensibility_for_layered_products">7. CLI extensibility for layered products</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this document we provide an example of how to extend the kernel
functionality of WildFly via an extension and the subsystem it installs.
The WildFly kernel is very simple and lightweight; most of the
capabilities people associate with an application server are provided
via extensions and their subsystems. The WildFly distribution includes
many extensions and subsystems; the webserver integration is via a
subsystem; the transaction manager integration is via a subsystem, the
Jakarta Enterprise Beans container integration is via a subsystem, etc.</p>
</div>
<div class="paragraph">
<p>This document is divided into two main sections. The
<a href="Extending_WildFly.html#Example_subsystem">first</a> is focused on learning by doing. This
section will walk you through the steps needed to create your own
subsystem, and will touch on most of the concepts discussed elsewhere in
this guide. The
<a href="Extending_WildFly.html#Key_Interfaces_and_Classes_Relevant_to_Extension_Developers">second</a>
focuses on a conceptual overview of the key interfaces and classes
described in the example. Readers should feel free to start with the
second section if that better fits their learning style. Jumping back
and forth between the sections is also a good strategy.</p>
</div>
<!-- toc disabled -->
</div>
</div>
<div class="sect1">
<h2 id="target-audience"><a class="anchor" href="#target-audience"></a>1. Target Audience</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="prerequisites"><a class="anchor" href="#prerequisites"></a>1.1. Prerequisites</h3>
<div class="paragraph">
<p>You should know how to download, install and run WildFly. If not please
consult the <a href="Getting_Started_Guide.html">Getting Started Guide</a>. You
should also be familiar with the management concepts from the
<a href="Admin_Guide.html">Admin Guide</a>, particularly the
<a href="Admin_Guide.html#Core_management_concepts">Core management concepts</a> section and
you need Java development experience to follow the example in this
guide.</p>
</div>
</div>
<div class="sect2">
<h3 id="examples-in-this"><a class="anchor" href="#examples-in-this"></a>1.2. Examples in this guide</h3>
<div class="paragraph">
<p>Most of the examples in this guide are being expressed as excerpts of
the XML configuration files or by using a representation of the de-typed
management model.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Example_subsystem"><a class="anchor" href="#Example_subsystem"></a>2. Example subsystem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Our example subsystem will keep track of all deployments of certain
types containing a special marker file, and expose operations to see how
long these deployments have been deployed.</p>
</div>
<div class="sect2">
<h3 id="create-the-skeleton-project"><a class="anchor" href="#create-the-skeleton-project"></a>2.1. Create the skeleton project</h3>
<div class="paragraph">
<p>To make your life easier we have provided a maven archetype which will
create a skeleton project for implementing subsystems.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>mvn archetype:generate \
    -DarchetypeArtifactId=wildfly-subsystem \
    -DarchetypeGroupId=org.wildfly.archetype \
    -DarchetypeVersion=26.1.0.Final \
    -DarchetypeRepository=https://repository.jboss.org/nexus/content/groups/public</code></pre>
</div>
</div>
<div class="paragraph">
<p>Maven will download the archetype and it&#8217;s dependencies, and ask you
some questions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>$ mvn archetype:generate \
    -DarchetypeArtifactId=wildfly-subsystem \
    -DarchetypeGroupId=org.wildfly.archetype \
    -DarchetypeVersion=26.1.0.Final \
    -DarchetypeRepository=https://repository.jboss.org/nexus/content/groups/public
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Stub Project (No POM) 1
[INFO] ------------------------------------------------------------------------
[INFO]
 
.........
 
Define value for property 'module': com.acme.corp.tracker
Define value for property 'groupId': com.acme.corp
Define value for property 'artifactId': acme-subsystem
Define value for property 'version':  1.0-SNAPSHOT: :
Define value for property 'package':  com.acme.corp: : com.acme.corp.tracker
[INFO] Using property: name = WildFly subsystem project
Confirm properties configuration:
groupId: com.acme.corp
artifactId: acme-subsystem
version: 1.0-SNAPSHOT
package: com.acme.corp.tracker
module: com.acme.corp.tracker
name: WildFly subsystem project
 Y: : Y
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1:42.563s
[INFO] Finished at: Fri Jul 08 14:30:09 BST 2011
[INFO] Final Memory: 7M/81M
[INFO] ------------------------------------------------------------------------
$</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enter the module name you wish to use for your extension.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enter the groupId you wish to use</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enter the artifactId you wish to use</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enter the version you wish to use, or just hit Enter if you wish to
accept the default 1.0-SNAPSHOT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enter the java package you wish to use, or just hit Enter if you
wish to accept the default (which is copied from groupId ).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Finally, if you are happy with your choices, hit Enter and Maven
will generate the project for you.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>We now have a skeleton project that you can use to
implement a subsystem. Import the ﻿ <code>acme-subsystem</code> project into your
favourite IDE. A nice side-effect of running this in the IDE is that you
can see the javadoc of WildFly classes and interfaces imported by the
skeleton code. If you do a <code>mvn install</code> in the project it will work if
we plug it into WildFly, but before doing that we will change it to do
something more useful.</p>
</div>
<div class="paragraph">
<p>The rest of this section modifies the skeleton project created by the
archetype to do something more useful, and the full code can be found in
<a href="downloads/acme-subsystem.zip">acme-subsystem.zip</a>.</p>
</div>
<div class="paragraph">
<p>If you do a <code>mvn install</code> in the created project, you will see some
tests being run</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>$mvn install
[INFO] Scanning for projects...
[...]
[INFO] Surefire report directory: /Users/kabir/sourcecontrol/temp/archetype-test/acme-subsystem/target/surefire-reports
 
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running com.acme.corp.tracker.extension.SubsystemBaseParsingTestCase
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.424 sec
Running com.acme.corp.tracker.extension.SubsystemParsingTestCase
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.074 sec
 
Results :
 
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will talk about these later in the
<a href="#testing-the-parsers">#Testing the
parsers</a> section.</p>
</div>
</div>
<div class="sect2">
<h3 id="create-the-schema"><a class="anchor" href="#create-the-schema"></a>2.2. Create the schema</h3>
<div class="paragraph">
<p>First, let us define the schema for our subsystem. Rename
<code>src/main/resources/schema/mysubsystem.xsd</code> to
<code>src/main/resources/schema/acme.xsd</code>. Then open <code>acme.xsd</code> and modify it
to the following</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml"><span class="tag">&lt;xs:schema</span> <span class="attribute-name">xmlns:xs</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema</span><span class="delimiter">&quot;</span></span>
            <span class="attribute-name">targetNamespace</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:com.acme.corp.tracker:1.0</span><span class="delimiter">&quot;</span></span>
            <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:com.acme.corp.tracker:1.0</span><span class="delimiter">&quot;</span></span>
            <span class="attribute-name">elementFormDefault</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">qualified</span><span class="delimiter">&quot;</span></span>
            <span class="attribute-name">attributeFormDefault</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">unqualified</span><span class="delimiter">&quot;</span></span>
            <span class="attribute-name">version</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
 
   <span class="comment">&lt;!-- The subsystem root element --&gt;</span>
   <span class="tag">&lt;xs:element</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystem</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemType</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
   <span class="tag">&lt;xs:complexType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemType</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      <span class="tag">&lt;xs:all&gt;</span>
         <span class="tag">&lt;xs:element</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-types</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-typesType</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
      <span class="tag">&lt;/xs:all&gt;</span>
   <span class="tag">&lt;/xs:complexType&gt;</span>
   <span class="tag">&lt;xs:complexType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-typesType</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      <span class="tag">&lt;xs:choice</span> <span class="attribute-name">minOccurs</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">maxOccurs</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">unbounded</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
         <span class="tag">&lt;xs:element</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-type</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-typeType</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
      <span class="tag">&lt;/xs:choice&gt;</span>
   <span class="tag">&lt;/xs:complexType&gt;</span>
   <span class="tag">&lt;xs:complexType</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-typeType</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      <span class="tag">&lt;xs:attribute</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">suffix</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">use</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">required</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
      <span class="tag">&lt;xs:attribute</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">xs:long</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">use</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">optional</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">default</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">10000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
   <span class="tag">&lt;/xs:complexType&gt;</span>
<span class="tag">&lt;/xs:schema&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we modified the <code>xmlns</code> and <code>targetNamespace</code> values to ﻿
<code>urn.com.acme.corp.tracker:1.0</code>. Our new <code>subsystem</code> element has a child
called <code>deployment-types</code>, which in turn can have zero or more children
called <code>deployment-type</code>. Each <code>deployment-type</code> has a required <code>suffix</code>
attribute, and a <code>tick</code> attribute which defaults to <code>true.</code></p>
</div>
<div class="paragraph">
<p>Now modify the ﻿ <code>com.acme.corp.tracker.extension.SubsystemExtension</code>
class to contain the new namespace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SubsystemExtension</span> <span class="directive">implements</span> Extension {
<span class="error"> </span>
    <span class="comment">/** The name space used for the {@code substystem} element */</span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> NAMESPACE = <span class="string"><span class="delimiter">&quot;</span><span class="content">urn:com.acme.corp.tracker:1.0</span><span class="delimiter">&quot;</span></span>;
    ...</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="design-and-define-the-model-structure"><a class="anchor" href="#design-and-define-the-model-structure"></a>2.3. Design and define the model structure</h3>
<div class="paragraph">
<p>The following example xml contains a valid subsystem configuration, we
will see how to plug this in to WildFly later in this tutorial.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml"><span class="tag">&lt;subsystem</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:com.acme.corp.tracker:1.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
   <span class="tag">&lt;deployment-types&gt;</span>
      <span class="tag">&lt;deployment-type</span> <span class="attribute-name">suffix</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">sar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">tick</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">10000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
      <span class="tag">&lt;deployment-type</span> <span class="attribute-name">suffix</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">war</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">tick</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">10000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
   <span class="tag">&lt;/deployment-types&gt;</span>
<span class="tag">&lt;/subsystem&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now when designing our model, we can either do a one to one mapping
between the schema and the model or come up with something slightly or
very different. To keep things simple, let us stay pretty true to the
schema so that when executing a <code>:read-resource(recursive=true)</code> against
our subsystem we&#8217;ll see something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>{
    &quot;outcome&quot; =&gt; &quot;success&quot;,
    &quot;result&quot; =&gt; {&quot;type&quot; =&gt; {
        &quot;sar&quot; =&gt; {&quot;tick&quot; =&gt; &quot;10000&quot;},
        &quot;war&quot; =&gt; {&quot;tick&quot; =&gt; &quot;10000&quot;}
    }}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each <code>deployment-type</code> in the xml becomes in the model a child resource
of the subsystem&#8217;s root resource. The child resource&#8217;s child-type is
<code>type</code>, and it is indexed by its <code>suffix</code>. Each <code>type</code> resource then
contains the <code>tick</code> attribute.</p>
</div>
<div class="paragraph">
<p>We also need a name for our subsystem, to do that change
<code>com.acme.corp.tracker.extension.SubsystemExtension</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SubsystemExtension</span> <span class="directive">implements</span> Extension {
    ...
    <span class="comment">/** The name of our subsystem within the model. */</span>
    public <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SUBSYSTEM_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">tracker</span><span class="delimiter">&quot;</span></span>;
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Modify the <code>src/main/resources/com/acme/corp/tracker/LocalDescriptions.properties</code>
with the new extension name, too</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="properties">tracker=My Tracker subsystem
tracker.add=Operation Adds subsystem
tracker.remove=Operation Removes subsystem
tracker.type=The type of file
tracker.type.add=Operation Adds type child
tracker.type.remove=Operation Removes type child
tracker.type.tick=The tick time in millis</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once we are finished our subsystem will be available under
<code>/subsystem=tracker</code>.</p>
</div>
<div class="paragraph">
<p>The <code>SubsystemExtension.initialize()</code> method defines the model,
currently it sets up the basics to add our subsystem to the model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">void</span> initialize(ExtensionContext context) {
    <span class="comment">//register subsystem with its model version</span>
<span class="error"> </span>       <span class="directive">final</span> SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>));
    <span class="comment">//register subsystem model with subsystem definition that defines all attributes and operations</span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="directive">final</span> ManagementResourceRegistration registration = subsystem.registerSubsystemModel(SubsystemDefinition.INSTANCE);
    <span class="comment">//register describe operation, note that this can be also registered in SubsystemDefinition</span>
    registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);
<span class="error"> </span>       <span class="comment">//we can register additional submodels here</span>
    <span class="comment">//</span>
    subsystem.registerXMLElementWriter(parser);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>registerSubsystem()</code> call registers our subsystem with the
extension context. At the end of the method we register our parser with
the returned <code>SubsystemRegistration</code> to be able to marshal our
subsystem&#8217;s model back to the main configuration file when it is
modified. We will add more functionality to this method later.</p>
</div>
<div class="sect3">
<h4 id="registering-the-core-subsystem-model"><a class="anchor" href="#registering-the-core-subsystem-model"></a>2.3.1. Registering the core subsystem model</h4>
<div class="paragraph">
<p>Next we obtain a <code>ManagementResourceRegistration</code> by registering the
subsystem model. This is a <strong>compulsory</strong> step for every new subsystem.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">final</span> ManagementResourceRegistration registration = subsystem.registerSubsystemModel(SubsystemDefinition.INSTANCE);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Its parameter is an implementation of the <code>ResourceDefinition</code>
interface, which means that when you call
<code>/subsystem=tracker:read-resource-description</code> the information you see
comes from model that is defined by <code>SubsystemDefinition.INSTANCE</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SubsystemDefinition</span> <span class="directive">extends</span> PersistentResourceDefinition {

    <span class="directive">static</span> <span class="directive">final</span> AttributeDefinition<span class="type">[]</span> ATTRIBUTES = { <span class="comment">/* you can include attributes here */</span> };

    <span class="directive">static</span> <span class="directive">final</span> SubsystemDefinition INSTANCE = <span class="keyword">new</span> SubsystemDefinition();

    <span class="directive">private</span> SubsystemDefinition() {
        <span class="local-variable">super</span>(SubsystemExtension.SUBSYSTEM_PATH,
                SubsystemExtension.getResourceDescriptionResolver(<span class="predefined-constant">null</span>),
                <span class="comment">//We always need to add an 'add' operation</span>
                SubsystemAdd.INSTANCE,
                <span class="comment">//Every resource that is added, normally needs a remove operation</span>
                SubsystemRemove.INSTANCE);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> registerOperations(ManagementResourceRegistration resourceRegistration) {
        <span class="local-variable">super</span>.registerOperations(resourceRegistration);
        <span class="comment">//you can register additional operations here</span>
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Collection</span>&lt;AttributeDefinition&gt; getAttributes() {
        <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.asList(ATTRIBUTES);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since we need child resource <code>type</code> we need to add new
ResourceDefinition,</p>
</div>
<div class="paragraph">
<p>The <code>ManagementResourceRegistration</code> obtained in
<code>SubsystemExtension.initialize()</code> is then used to add additional
operations or to register submodels to the <code>/subsystem=tracker</code> address.
Every subsystem and resource <strong>must</strong> have an <code>ADD</code> method which can be
achieved by providing it in constructor of your <code>ResourceDefinition</code>
just as we did in example above.</p>
</div>
<div class="paragraph">
<p>Let us first look at the description provider which is quite simple,
it provides information (description, list of attributes, list of children)
describing the structure of an addressable model node or operation.</p>
</div>
<div class="paragraph">
<p>There are three way to define <code>DescriptionProvider</code>, one is by defining it
by hand using ModelNode, but as this has show to be very error prone
there are lots of helper methods to help you automatically describe the
model. Following example is done by manually defining Description
provider for ADD operation handler</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">/**
     * Used to create the description of the subsystem add method
     */</span>
    <span class="directive">public</span> <span class="directive">static</span> DescriptionProvider SUBSYSTEM_ADD = <span class="keyword">new</span> DescriptionProvider() {
        <span class="directive">public</span> ModelNode getModelDescription(<span class="predefined-type">Locale</span> locale) {
            <span class="comment">//The locale is passed in so you can internationalize the strings used in the descriptions</span>
<span class="error"> </span>
            <span class="directive">final</span> ModelNode subsystem = <span class="keyword">new</span> ModelNode();
            subsystem.get(OPERATION_NAME).set(ADD);
            subsystem.get(DESCRIPTION).set(<span class="string"><span class="delimiter">&quot;</span><span class="content">Adds the tracker subsystem</span><span class="delimiter">&quot;</span></span>);
<span class="error"> </span>
            <span class="keyword">return</span> subsystem;
        }
    };</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use API that helps you do that for you. <code>SimpleOperationDefinitionBuilder</code>
is the class for the case. With a set of fields to build operation&#8217;s definitions.
In case you use <code>PersistentResourceDefinition</code> even that part is hidden from you.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">// Registration of an add operation</span>
resourceRegistration.registerOperationHandler(<span class="keyword">new</span> SimpleOperationDefinitionBuilder(ModelDescriptionConstants.ADD, SubsystemExtension.getResourceDescriptionResolver(<span class="predefined-constant">null</span>)).build(), SubsystemAdd.INSTANCE);
<span class="comment">// Registration of a remove operation</span>
resourceRegistration.registerOperationHandler(<span class="keyword">new</span> SimpleOperationDefinitionBuilder(ModelDescriptionConstants.REMOVE, SubsystemExtension.getResourceDescriptionResolver(<span class="predefined-constant">null</span>)).build(), SubsystemAdd.INSTANCE);
<span class="comment">// Registration of a custom operation</span>
resourceRegistration.registerOperationHandler(<span class="keyword">new</span> SimpleOperationDefinitionBuilder(<span class="string"><span class="delimiter">&quot;</span><span class="content">mime-type</span><span class="delimiter">&quot;</span></span>, SubsystemExtension.getResourceDescriptionResolver(<span class="string"><span class="delimiter">&quot;</span><span class="content">container.mime-mapping</span><span class="delimiter">&quot;</span></span>)).build(), <span class="keyword">new</span> MimeTypeStepOperationHandler());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last one is implicit used when you pass the operation handler through the
<code>SimpleResourceDefinition</code> class constructor. A <code>DefaultResourceAddDescriptionProvider</code>
will be create under the hood. For this reason, you don&#8217;t need to add a description
provider explicit in this example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">// The framework will take care to handle a default `DescriptionProvider`</span>
<span class="directive">private</span> SubsystemDefinition() {
    <span class="local-variable">super</span>(SubsystemExtension.SUBSYSTEM_PATH,
            SubsystemExtension.getResourceDescriptionResolver(<span class="predefined-constant">null</span>),
            <span class="comment">//We always need to add an 'add' operation</span>
            SubsystemAdd.INSTANCE,
            <span class="comment">//Every resource that is added, normally needs a remove operation</span>
            SubsystemRemove.INSTANCE);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we have the actual operation handler instance, note that we have
changed its <code>populateModel()</code> method to initialize the <code>type</code> child of
the model.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">SubsystemAdd</span> <span class="directive">extends</span> AbstractBoottimeAddStepHandler {
<span class="error"> </span>
    <span class="directive">static</span> <span class="directive">final</span> SubsystemAdd INSTANCE = <span class="keyword">new</span> SubsystemAdd();

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Logger</span> log = <span class="predefined-type">Logger</span>.getLogger(SubsystemAdd.class);<span class="error"> </span>

    <span class="directive">private</span> SubsystemAdd() {
        <span class="local-variable">super</span>(SubsystemDefinition.ATTRIBUTES);
    }
<span class="error"> </span>
    <span class="comment">/** {@inheritDoc} */</span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> populateModel(ModelNode operation, ModelNode model) <span class="directive">throws</span> OperationFailedException {
        log.info(<span class="string"><span class="delimiter">&quot;</span><span class="content">Populating the model</span><span class="delimiter">&quot;</span></span>);
        <span class="comment">//Initialize the 'type' child node</span>
        model.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>).setEmptyObject();
    }
    ....</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SubsystemAdd</code> also has a <code>performBoottime()</code> method which is used for
initializing the deployer chain associated with this subsystem. We will
talk about the deployers later on. However, the basic idea for all
operation handlers is that we do any model updates before changing the
actual runtime state.</p>
</div>
<div class="paragraph">
<p><code>SubsystemRemove</code> extends <code>AbstractRemoveStepHandler</code> which takes care
of removing the resource from the model so we don&#8217;t need to override its
<code>performRemove()</code> operation, also the add handler did not install any
services (services will be discussed later) so we can delete the methods
<code>performRuntime()</code> and <code>recoverServices()</code> generated by the archetype.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">SubsystemRemove</span> <span class="directive">extends</span> AbstractRemoveStepHandler {
<span class="error"> </span>
    <span class="directive">static</span> <span class="directive">final</span> SubsystemRemove INSTANCE = <span class="keyword">new</span> SubsystemRemove();
<span class="error"> </span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Logger</span> log = <span class="predefined-type">Logger</span>.getLogger(SubsystemRemove.class);
<span class="error"> </span>
    <span class="directive">private</span> SubsystemRemove() {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The description provider for the remove operation is simple and quite
similar to that of the add handler where just name of the method
changes.</p>
</div>
</div>
<div class="sect3">
<h4 id="registering-the-subsystem-child"><a class="anchor" href="#registering-the-subsystem-child"></a>2.3.2. Registering the subsystem child</h4>
<div class="paragraph">
<p>The <code>type</code> child does not exist in our skeleton project so we need to
implement the operations to add and remove them from the model.</p>
</div>
<div class="paragraph">
<p>Create two constant in SubsystemExtension with the the name and property of
the new child, and mount child path</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">SubsystemExtension</span> <span class="directive">extends</span> Extension {
    ...
    protected <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> TICK = <span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">protected</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> TYPE = <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">protected</span> <span class="directive">static</span> <span class="directive">final</span> PathElement TYPE_PATH = PathElement.pathElement(TYPE);
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we need an add operation to add the <code>type</code> child. Create a class
called <code>com.acme.corp.tracker.extension.TypeAddHandler</code>. In this case we
extend the <code>org.jboss.as.controller.AbstractAddStepHandler</code>.
<code>org.jboss.as.controller.OperationStepHandler</code> is the main
interface for the operation handlers, and <code>AbstractAddStepHandler</code> is an
implementation of that which does the plumbing work for adding a
resource to the model.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">TypeAddHandler</span> <span class="directive">extends</span> AbstractAddStepHandler {
<span class="error"> </span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> TypeAddHandler INSTANCE = <span class="keyword">new</span> TypeAddHandler();
<span class="error"> </span>
    <span class="directive">private</span> TypeAddHandler() {
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we define subsystem model. Lets call it <code>TypeDefinition</code> and for
ease of use let declare just the tick attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TypeDefinition</span> {
<span class="error"> </span>
<span class="error"> </span>   <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> TypeDefinition INSTANCE = <span class="keyword">new</span> TypeDefinition();
<span class="error"> </span>
<span class="error"> </span><span class="comment">//we define attribute named tick</span>
    <span class="directive">protected</span> <span class="directive">static</span> <span class="directive">final</span> SimpleAttributeDefinition TICK =
        <span class="keyword">new</span> SimpleAttributeDefinitionBuilder(SubsystemExtension.TICK, ModelType.LONG)
          .setAllowExpression(<span class="predefined-constant">true</span>)
          .setXmlName(SubsystemExtension.TICK)
          .setFlags(AttributeAccess.Flag.RESTART_ALL_SERVICES)
          .setDefaultValue(<span class="keyword">new</span> ModelNode(<span class="integer">1000</span>))
          .setRequired(<span class="predefined-constant">true</span>)
          .build();
<span class="error"> </span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which will take care of describing the model for us. As you can see in
example above we define <code>SimpleAttributeDefinition</code> named <code>TICK</code>, this
is a mechanism to define Attributes in more type safe way and to add
more common API to manipulate attributes. As you can see here we define
default value of 1000 as also other constraints and capabilities. There
could be other properties set such as validators, alternate names, xml
name, flags for marking it attribute allows expressions and more.</p>
</div>
<div class="paragraph">
<p>Then we do the work of updating the model by implementing the
<code>populateModel()</code> method from the <code>AbstractAddStepHandler</code>, which
populates the model&#8217;s attribute from the operation parameters. First we
get hold of the model relative to the address of this operation (we will
see later that we will register it against <code>/subsystem=tracker/type=*</code>),
so we just specify an empty relative address, and we then populate our
model with the parameters from the operation. There is operation
<code>validateAndSet</code> on <code>AttributeDefinition</code> that helps us validate and set
the model based on definition of the attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TypeAddHandler</span> <span class="directive">extends</span> AbstractAddStepHandler {
    ...
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> populateModel(ModelNode operation, ModelNode model) <span class="directive">throws</span> OperationFailedException {
        TypeDefinition.TICK.validateAndSet(operation,model);
    }
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then override the <code>performRuntime()</code> method to perform our runtime
changes, which in this case involves installing a service into the
controller at the heart of WildFly. (
<code>AbstractAddStepHandler.performRuntime()</code> is similar to
<code>AbstractBoottimeAddStepHandler.performBoottime()</code> in that the model is
updated before runtime changes are made.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TypeAddHandler</span> <span class="directive">extends</span> AbstractAddStepHandler {
    ...
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> performRuntime(OperationContext context, ModelNode operation, ModelNode model) <span class="directive">throws</span> OperationFailedException {
        <span class="predefined-type">String</span> suffix = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.ADDRESS)).getLastElement().getValue();
        <span class="type">long</span> tick = TypeDefinition.TICK.resolveModelAttribute(context,model).asLong();
        TrackerService service = <span class="keyword">new</span> TrackerService(suffix, tick);
        ServiceName serviceName = TrackerService.createServiceName(suffix);

        context.getServiceTarget()
                .addService(serviceName)
                .setInstance(service)
                .setInitialMode(Mode.ACTIVE)
                .install();
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the add methods will be of the format
<code>/subsystem=tracker/suffix=war:add(tick=1234)</code>, we look for the last
element of the operation address, which is <code>war</code> in the example just
given and use that as our suffix. We then create an instance of
TrackerService and install that into the <code>service target</code> of the context
and add the created <code>service controller</code> to the <code>newControllers</code> list.</p>
</div>
<div class="paragraph">
<p>The tracker service is quite simple. All services installed into WildFly
must implement the <code>org.jboss.msc.Service</code> interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TrackerService</span> <span class="directive">implements</span> Service {</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then have some fields to keep the tick count and a thread which when
run outputs all the deployments registered with our service.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">private</span> <span class="predefined-type">AtomicLong</span> tick = <span class="keyword">new</span> <span class="predefined-type">AtomicLong</span>(<span class="integer">10000</span>);
<span class="error"> </span>
<span class="directive">private</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; deployments = <span class="predefined-type">Collections</span>.synchronizedSet(<span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">String</span>&gt;());
<span class="directive">private</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; coolDeployments = <span class="predefined-type">Collections</span>.synchronizedSet(<span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">String</span>&gt;());
<span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> suffix;
<span class="error"> </span>
<span class="directive">private</span> <span class="predefined-type">Thread</span> OUTPUT = <span class="keyword">new</span> <span class="predefined-type">Thread</span>() {
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> run() {
        <span class="keyword">while</span> (<span class="predefined-constant">true</span>) {
            <span class="keyword">try</span> {
                <span class="predefined-type">Thread</span>.sleep(tick.get());
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Current deployments deployed while </span><span class="delimiter">&quot;</span></span> + suffix + <span class="string"><span class="delimiter">&quot;</span><span class="content"> tracking active:</span><span class="char">\n</span><span class="delimiter">&quot;</span></span> + deployments
                   + <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="content">Cool: </span><span class="delimiter">&quot;</span></span> + coolDeployments.size());
            } <span class="keyword">catch</span> (<span class="exception">InterruptedException</span> e) {
                interrupted();
                <span class="keyword">break</span>;
            }
        }
    }
};
<span class="error"> </span>
<span class="directive">public</span> TrackerService(<span class="predefined-type">String</span> suffix, <span class="type">long</span> tick) {
    <span class="local-variable">this</span>.suffix = suffix;
    <span class="local-variable">this</span>.tick.set(tick);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we have three methods which come from the <code>Service</code> interface.
<code>getValue()</code> returns this service, <code>start()</code> is called when the service
is started by the controller, <code>stop</code> is called when the service is
stopped by the controller, and they start and stop the thread outputting
the deployments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> TrackerService getValue() <span class="directive">throws</span> <span class="exception">IllegalStateException</span>, <span class="exception">IllegalArgumentException</span> {
    <span class="keyword">return</span> <span class="local-variable">this</span>;
}
<span class="error"> </span>
<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">void</span> start(StartContext context) <span class="directive">throws</span> StartException {
    OUTPUT.start();
}
<span class="error"> </span>
<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">void</span> stop(StopContext context) {
    OUTPUT.interrupt();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next we have a utility method to create the <code>ServiceName</code> which is used
to register the service in the controller.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> ServiceName createServiceName(<span class="predefined-type">String</span> suffix) {
        <span class="keyword">return</span> ServiceName.JBOSS.append(<span class="string"><span class="delimiter">&quot;</span><span class="content">tracker</span><span class="delimiter">&quot;</span></span>, suffix);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally we have some methods to add and remove deployments, and to set
and read the <code>tick</code>. The 'cool' deployments will be explained later.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> addDeployment(<span class="predefined-type">String</span> name) {
    deployments.add(name);
}
<span class="error"> </span>
<span class="directive">public</span> <span class="type">void</span> addCoolDeployment(<span class="predefined-type">String</span> name) {
    coolDeployments.add(name);
}
<span class="error"> </span>
<span class="directive">public</span> <span class="type">void</span> removeDeployment(<span class="predefined-type">String</span> name) {
    deployments.remove(name);
    coolDeployments.remove(name);
}
<span class="error"> </span>
<span class="type">void</span> setTick(<span class="type">long</span> tick) {
    <span class="local-variable">this</span>.tick.set(tick);
}
<span class="error"> </span>
<span class="directive">public</span> <span class="type">long</span> getTick() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.tick.get();
}
}<span class="comment">//TrackerService - end</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since we are able to add <code>type</code> children, we need a way to be able to
remove them, so we create a
<code>com.acme.corp.tracker.extension.TypeRemoveHandler</code>. In this case we
extend <code>AbstractRemoveStepHandler</code> which takes care of removing the
resource from the model so we don&#8217;t need to override its
<code>performRemove()</code> operation. Once the add handler installs the TrackerService,
we need to remove that in the <code>performRuntime()</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TypeRemoveHandler</span> <span class="directive">extends</span> AbstractRemoveStepHandler {
<span class="error"> </span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> TypeRemoveHandler INSTANCE = <span class="keyword">new</span> TypeRemoveHandler();
<span class="error"> </span>
    <span class="directive">private</span> TypeRemoveHandler() {
    }
<span class="error"> </span>
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> performRuntime(OperationContext context, ModelNode operation, ModelNode model) <span class="directive">throws</span> OperationFailedException {
        <span class="predefined-type">String</span> suffix = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.ADDRESS)).getLastElement().getValue();
        ServiceName name = TrackerService.createServiceName(suffix);
        context.removeService(name);
    }
<span class="error"> </span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So far <code>TypeDefinition</code> is just a simple Java class, however, it must be an
addressable management resource. Modify this class to extend <code>SimpleResourceDefinition</code>,
register the Add and Remove handlers created before and register the <code>TICK</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TypeDefinition</span> <span class="directive">extends</span> SimpleResourceDefinition {

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> TypeDefinition INSTANCE = <span class="keyword">new</span> TypeDefinition();

    <span class="directive">protected</span> <span class="directive">static</span> <span class="directive">final</span> SimpleAttributeDefinition TICK =
            <span class="keyword">new</span> SimpleAttributeDefinitionBuilder(SubsystemExtension.TICK, ModelType.LONG)
              .setAllowExpression(<span class="predefined-constant">true</span>)
              .setXmlName(SubsystemExtension.TICK)
              .setFlags(AttributeAccess.Flag.RESTART_ALL_SERVICES)
              .setDefaultValue(<span class="keyword">new</span> ModelNode(<span class="integer">1000</span>))
              .setRequired(<span class="predefined-constant">true</span>)
              .build();

    <span class="directive">public</span> TypeDefinition() {
        <span class="local-variable">super</span>(
                SubsystemExtension.TYPE_PATH,
                SubsystemExtension.getResourceDescriptionResolver(SubsystemExtension.TYPE),
                TypeAddHandler.INSTANCE,
                TypeRemoveHandler.INSTANCE
        );
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> registerAttributes(ManagementResourceRegistration resourceRegistration) {
        resourceRegistration.registerReadWriteAttribute(TICK, <span class="predefined-constant">null</span>, TrackerTickHandler.INSTANCE);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then finally we need to specify that our new <code>type</code> child and associated
handlers go under <code>/subsystem=tracker/type=*</code> in the model by adding
registering it with the model in <code>SubsystemExtension.initialize()</code>. So
we add the following just before the end of the method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">void</span> initialize(ExtensionContext context){
    <span class="directive">final</span> SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>));
    <span class="directive">final</span> ManagementResourceRegistration registration = subsystem.registerSubsystemModel(SubsystemExtension.INSTANCE);
    registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);
    <span class="comment">//Add the type child</span>
    ManagementResourceRegistration typeChild = registration.registerSubModel(TypeDefinition.INSTANCE);
    subsystem.registerXMLElementWriter(parser);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above first creates a child of our main subsystem registration for
the relative address <code>type=*</code>, and gets the <code>typeChild</code> registration.<br>
To this we add the <code>TypeAddHandler</code> and <code>TypeRemoveHandler</code>.<br>
The add variety is added under the name <code>add</code> and the remove handler
under the name <code>remove</code>, and for each registered operation handler we
use the handler singleton instance as both the handler parameter and as
the <code>DescriptionProvider</code>.</p>
</div>
<div class="paragraph">
<p>Finally, we register <code>tick</code> as a read/write attribute, the null
parameter means we don&#8217;t do anything special with regards to reading it,
for the write handler we supply it with an operation handler called
<code>TrackerTickHandler</code>.<br>
Registering it as a read/write attribute means we can use the
<code>:write-attribute</code> operation to modify the value of the parameter, and
it will be handled by <code>TrackerTickHandler</code>.</p>
</div>
<div class="paragraph">
<p>Not registering a write attribute handler makes the attribute read only.</p>
</div>
<div class="paragraph">
<p><code>TrackerTickHandler</code> extends <code>AbstractWriteAttributeHandler</code><br>
directly, and so must implement its <code>applyUpdateToRuntime</code> and
<code>revertUpdateToRuntime</code> method.<br>
This takes care of model manipulation (validation, setting) but leaves
us to do just to deal with what we need to do.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">TrackerTickHandler</span> <span class="directive">extends</span> AbstractWriteAttributeHandler&lt;<span class="predefined-type">Void</span>&gt; {
<span class="error"> </span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> TrackerTickHandler INSTANCE = <span class="keyword">new</span> TrackerTickHandler();
<span class="error"> </span>
    <span class="directive">private</span> TrackerTickHandler() {
        <span class="local-variable">super</span>(TypeDefinition.TICK);
    }
<span class="error"> </span>
    <span class="directive">protected</span> <span class="type">boolean</span> applyUpdateToRuntime(OperationContext context, ModelNode operation, <span class="predefined-type">String</span> attributeName,
              ModelNode resolvedValue, ModelNode currentValue, HandbackHolder&lt;<span class="predefined-type">Void</span>&gt; handbackHolder) <span class="directive">throws</span> OperationFailedException {
<span class="error"> </span>
        modifyTick(context, operation, resolvedValue.asLong());
<span class="error"> </span>
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
<span class="error"> </span>
    <span class="directive">protected</span> <span class="type">void</span> revertUpdateToRuntime(OperationContext context, ModelNode operation, <span class="predefined-type">String</span> attributeName, ModelNode valueToRestore, ModelNode valueToRevert, <span class="predefined-type">Void</span> handback){
        modifyTick(context, operation, valueToRestore.asLong());
    }
<span class="error"> </span>
    <span class="directive">private</span> <span class="type">void</span> modifyTick(OperationContext context, ModelNode operation, <span class="type">long</span> value) <span class="directive">throws</span> OperationFailedException {
<span class="error"> </span>
        <span class="directive">final</span> <span class="predefined-type">String</span> suffix = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.ADDRESS)).getLastElement().getValue();
        TrackerService service = (TrackerService) context.getServiceRegistry(<span class="predefined-constant">true</span>).getRequiredService(TrackerService.createServiceName(suffix)).getValue();
        service.setTick(value);
    }
<span class="error"> </span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The operation used to execute this will be of the form
<code>/subsystem=tracker/type=war:write-attribute(name=tick,value=12345</code>) so
we first get the <code>suffix</code> from the operation address, and the <code>tick</code>
value from the operation parameter&#8217;s <code>resolvedValue</code> parameter, and use
that to update the model.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="parsing-and-marshalling-of-the-subsystem-xml"><a class="anchor" href="#parsing-and-marshalling-of-the-subsystem-xml"></a>2.4. Parsing and marshalling of the subsystem xml</h3>
<div class="paragraph">
<p>WildFly uses the Stax API to parse the xml files. This is initialized in
<code>SubsystemExtension</code> by mapping our parser onto our namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SubsystemExtension</span> <span class="directive">implements</span> Extension {
<span class="error"> </span>
    <span class="comment">/** The name space used for the {@code subsystem} element */</span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> NAMESPACE = <span class="string"><span class="delimiter">&quot;</span><span class="content">urn:com.acme.corp.tracker:1.0</span><span class="delimiter">&quot;</span></span>;
    ...
    protected <span class="directive">static</span> <span class="directive">final</span> PathElement SUBSYSTEM_PATH = PathElement.pathElement(SUBSYSTEM, SUBSYSTEM_NAME);
<span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="directive">protected</span> <span class="directive">static</span> <span class="directive">final</span> PathElement TYPE_PATH = PathElement.pathElement(TYPE);
<span class="error"> </span>
  <span class="error"> </span><span class="comment">/** The parser used for parsing our subsystem */</span>
    <span class="directive">private</span> <span class="directive">final</span> SubsystemParser parser = <span class="keyword">new</span> SubsystemParser();
<span class="error"> </span>
  <span class="error"> </span><span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> initializeParsers(ExtensionParsingContext context) {
        context.setSubsystemXmlMapping(NAMESPACE, parser);
    }
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We then need to write the parser. The contract is that we read our
subsystem&#8217;s xml and create the operations that will populate the model
with the state contained in the xml. These operations will then be
executed on our behalf as part of the parsing process. The entry point
is the <code>readElement()</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SubsystemExtension</span> <span class="directive">implements</span> Extension {
<span class="error"> </span>
    <span class="comment">/**
     * The subsystem parser, which uses stax to read and write to and from xml
     */</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">SubsystemParser</span> <span class="directive">implements</span> XMLStreamConstants, XMLElementReader&lt;<span class="predefined-type">List</span>&lt;ModelNode&gt;&gt;, XMLElementWriter&lt;SubsystemMarshallingContext&gt; {
<span class="error"> </span>
        <span class="comment">/** {@inheritDoc} */</span>
        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> readElement(XMLExtendedStreamReader reader, <span class="predefined-type">List</span>&lt;ModelNode&gt; list) <span class="directive">throws</span> XMLStreamException {
            <span class="comment">// Require no attributes</span>
            ParseUtils.requireNoAttributes(reader);
<span class="error"> </span>
            <span class="comment">//Add the main subsystem 'add' operation</span>
            <span class="directive">final</span> ModelNode subsystem = <span class="keyword">new</span> ModelNode();
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> subsystem.get(OP).set(ADD);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> subsystem.get(OP_ADDR).set(PathAddress.pathAddress(SUBSYSTEM_PATH).toModelNode());
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> list.add(subsystem);
<span class="error"> </span>
            <span class="comment">//Read the children</span>
            <span class="keyword">while</span> (reader.hasNext() &amp;&amp; reader.nextTag() != END_ELEMENT) {
                <span class="keyword">if</span> (!reader.getLocalName().equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-types</span><span class="delimiter">&quot;</span></span>)) {
                    <span class="keyword">throw</span> ParseUtils.unexpectedElement(reader);
                }
                <span class="keyword">while</span> (reader.hasNext() &amp;&amp; reader.nextTag() != END_ELEMENT) {
                    <span class="keyword">if</span> (reader.isStartElement()) {
                        readDeploymentType(reader, list);
                    }
                }
            }
        }
<span class="error"> </span>
        <span class="directive">private</span> <span class="type">void</span> readDeploymentType(XMLExtendedStreamReader reader, <span class="predefined-type">List</span>&lt;ModelNode&gt; list) <span class="directive">throws</span> XMLStreamException {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">if</span> (!reader.getLocalName().equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-type</span><span class="delimiter">&quot;</span></span>)) {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">throw</span> ParseUtils.unexpectedElement(reader);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> }
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> ModelNode addTypeOperation = <span class="keyword">new</span> ModelNode();
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> addTypeOperation.get(OP).set(ModelDescriptionConstants.ADD);
<span class="error"> </span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="predefined-type">String</span> suffix = <span class="predefined-constant">null</span>;
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; reader.getAttributeCount(); i++) {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="predefined-type">String</span> attr = reader.getAttributeLocalName(i);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="predefined-type">String</span> value = reader.getAttributeValue(i);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">if</span> (attr.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>)) {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> TypeDefinition.TICK.parseAndSetParameter(value, addTypeOperation, reader);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> } <span class="keyword">else</span> <span class="keyword">if</span> (attr.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">suffix</span><span class="delimiter">&quot;</span></span>)) {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> suffix = value;
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> } <span class="keyword">else</span> {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">throw</span> ParseUtils.unexpectedAttribute(reader, i);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> }
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> }
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> ParseUtils.requireNoContent(reader);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">if</span> (suffix == <span class="predefined-constant">null</span>) {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">throw</span> ParseUtils.missingRequiredElement(reader, <span class="predefined-type">Collections</span>.singleton(<span class="string"><span class="delimiter">&quot;</span><span class="content">suffix</span><span class="delimiter">&quot;</span></span>));
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> }
<span class="error"> </span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="comment">//Add the 'add' operation for each 'type' child</span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> PathAddress addr = PathAddress.pathAddress(SUBSYSTEM_PATH, PathElement.pathElement(TYPE, suffix));
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> addTypeOperation.get(OP_ADDR).set(addr.toModelNode());
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> list.add(addTypeOperation);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> }
        ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>So in the above we always create the add operation for our subsystem.
Due to its address <code>/subsystem=tracker</code> defined by <code>SUBSYSTEM_PATH</code> this
will trigger the <code>SubsystemAdd</code> we created earlier when we invoke
<code>/subsystem=tracker:add</code>. We then parse the child elements and create an
add operation for the child address for each <code>type</code> child. Since the
address will for example be <code>/subsystem=tracker/type=sar</code> (defined by
<code>TYPE_PATH</code> ) and <code>TypeAddHandler</code> is registered for all <code>type</code>
subaddresses the <code>TypeAddHandler</code> will get invoked for those operations.
Note that when we are parsing attribute <code>tick</code> we are using definition
of attribute that we defined in TypeDefintion to parse attribute value
and apply all rules that we specified for this attribute, this also
enables us to property support expressions on attributes.</p>
</div>
<div class="paragraph">
<p>The parser is also used to marshal the model to xml whenever something
modifies the model, for which the entry point is the <code>writeContent()</code>
method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">private</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">SubsystemParser</span> <span class="directive">implements</span> XMLStreamConstants, XMLElementReader&lt;<span class="predefined-type">List</span>&lt;ModelNode&gt;&gt;, XMLElementWriter&lt;SubsystemMarshallingContext&gt; {
        ...
        <span class="comment">/** {@inheritDoc} */</span>
        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> writeContent(<span class="directive">final</span> XMLExtendedStreamWriter writer, <span class="directive">final</span> SubsystemMarshallingContext context) <span class="directive">throws</span> XMLStreamException {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="comment">//Write out the main subsystem element</span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> context.startSubsystemElement(SubsystemExtension.NAMESPACE, <span class="predefined-constant">false</span>);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> writer.writeStartElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-types</span><span class="delimiter">&quot;</span></span>);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> ModelNode node = context.getModelNode();
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> ModelNode type = node.get(TYPE);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">for</span> (Property property : type.asPropertyList()) {
<span class="error"> </span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="comment">//write each child element to xml</span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> writer.writeStartElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">deployment-type</span><span class="delimiter">&quot;</span></span>);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> writer.writeAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">suffix</span><span class="delimiter">&quot;</span></span>, property.getName());
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> ModelNode entry = property.getValue();
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> TypeDefinition.TICK.marshallAsAttribute(entry, <span class="predefined-constant">true</span>, writer);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> writer.writeEndElement();
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> }
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="comment">//End deployment-types</span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> writer.writeEndElement();
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="comment">//End subsystem</span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> writer.writeEndElement();
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we have to implement the <code>SubsystemDescribeHandler</code> which
translates the current state of the model into operations similar to the
ones created by the parser. The <code>SubsystemDescribeHandler</code> is only used
when running in a managed domain, and is used when the host controller
queries the domain controller for the configuration of the profile used
to start up each server. In our case the <code>SubsystemDescribeHandler</code> adds
the operation to add the subsystem and then adds the operation to add
each <code>type</code> child. Since we are using ResourceDefinitinon for defining
subsystem all that is generated for us, but if you want to customize
that you can do it by implementing it like this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">private</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">SubsystemDescribeHandler</span> <span class="directive">implements</span> OperationStepHandler, DescriptionProvider {
        <span class="directive">static</span> <span class="directive">final</span> SubsystemDescribeHandler INSTANCE = <span class="keyword">new</span> SubsystemDescribeHandler();
<span class="error"> </span>
        <span class="directive">public</span> <span class="type">void</span> execute(OperationContext context, ModelNode operation) <span class="directive">throws</span> OperationFailedException {
            <span class="comment">//Add the main operation</span>
            context.getResult().add(createAddSubsystemOperation());
<span class="error"> </span>
            <span class="comment">//Add the operations to create each child</span>
<span class="error"> </span>
            ModelNode node = context.readModel(PathAddress.EMPTY_ADDRESS);
            <span class="keyword">for</span> (Property property : node.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>).asPropertyList()) {
<span class="error"> </span>
                ModelNode addType = <span class="keyword">new</span> ModelNode();
                addType.get(OP).set(ModelDescriptionConstants.ADD);
                PathAddress addr = PathAddress.pathAddress(SUBSYSTEM_PATH, PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, property.getName()));
                addType.get(OP_ADDR).set(addr.toModelNode());
                <span class="keyword">if</span> (property.getValue().hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>)) {
                  <span class="error"> </span>TypeDefinition.TICK.validateAndSet(property,addType);
                }
                context.getResult().add(addType);
            }
            context.completeStep();
        }
<span class="error"> </span>
<span class="error"> </span>
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="testing-the-parsers"><a class="anchor" href="#testing-the-parsers"></a>2.4.1. Testing the parsers</h4>
<div class="paragraph">
<p>From 7.0.1 the testing framework is now brought in via the
<code>org.jboss.as:jboss-as-subsystem-test</code> maven artifact, and the test&#8217;s
superclass is <code>org.jboss.as.subsystem.test.AbstractSubsystemTest</code>. The
concepts are the same but more and more functionality will be available
as JBoss AS 7 is developed.</p>
</div>
<div class="paragraph">
<p>Now that we have modified our parsers we need to update our tests to
reflect the new model. There are currently three tests testing the basic
functionality, something which is a lot easier to debug from your IDE
before you plug it into the application server. We will talk about these
tests in turn and they all live in
<code>com.acme.corp.tracker.extension.SubsystemParsingTestCase</code>.
<code>SubsystemParsingTestCase</code> extends <code>AbstractSubsystemTest</code> which does a
lot of the setup for you and contains utility methods for verifying
things from your test. See the javadoc of that class for more
information about the functionality available to you. And by all means
feel free to add more tests for your subsystem, here we are only testing
for the best case scenario while you will probably want to throw in a
few tests for edge cases.</p>
</div>
<div class="paragraph">
<p>The first test we need to modify is <code>testParseSubsystem()</code>. It tests
that the parsed xml becomes the expected operations that will be parsed
into the server, so let us tweak this test to match our subsystem. First
we tell the test to parse the xml into operations</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml">@Test
public void testParseSubsystem() throws Exception {
    //Parse the subsystem xml into operations
    String subsystemXml =
            &quot;<span class="tag">&lt;subsystem</span> <span class="attribute-name">xmlns</span>=<span class="error">\</span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> <span class="error">+</span> <span class="attribute-name">SubsystemExtension.NAMESPACE</span> <span class="error">+</span> <span class="error">&quot;</span><span class="error">\</span><span class="error">&quot;</span><span class="tag">&gt;</span>&quot; +
            &quot;   <span class="tag">&lt;deployment-types&gt;</span>&quot; +
            &quot;       <span class="tag">&lt;deployment-type</span> <span class="attribute-name">suffix</span>=<span class="error">\</span><span class="string"><span class="delimiter">&quot;</span><span class="content">tst\</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">tick</span>=<span class="error">\</span><span class="string"><span class="delimiter">&quot;</span><span class="content">12345\</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>&quot; +
            &quot;   <span class="tag">&lt;/deployment-types&gt;</span>&quot; +
            &quot;<span class="tag">&lt;/subsystem&gt;</span>&quot;;
    List<span class="tag">&lt;ModelNode&gt;</span> operations = super.parse(subsystemXml);</code></pre>
</div>
</div>
<div class="paragraph">
<p>There should be one operation for adding the subsystem itself and an
operation for adding the <code>deployment-type</code>, so check we got two
operations</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">///Check that we have the expected number of operations</span>
Assert.assertEquals(<span class="integer">2</span>, operations.size());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now check that the first operation is <code>add</code> for the address
<code>/subsystem=tracker</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Check that each operation has the correct content</span>
<span class="comment">//The add subsystem operation will happen first</span>
ModelNode addSubsystem = operations.get(<span class="integer">0</span>);
Assert.assertEquals(ADD, addSubsystem.get(OP).asString());
PathAddress addr = PathAddress.pathAddress(addSubsystem.get(OP_ADDR));
Assert.assertEquals(<span class="integer">1</span>, addr.size());
PathElement element = addr.getElement(<span class="integer">0</span>);
Assert.assertEquals(SUBSYSTEM, element.getKey());
Assert.assertEquals(SubsystemExtension.SUBSYSTEM_NAME, element.getValue());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then check that the second operation is <code>add</code> for the address
<code>/subsystem=tracker</code>, and that <code>12345</code> was picked up for the value of
the <code>tick</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Then we will get the add type operation</span>
    ModelNode addType = operations.get(<span class="integer">1</span>);
    Assert.assertEquals(ADD, addType.get(OP).asString());
    Assert.assertEquals(<span class="integer">12345</span>, addType.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>).asLong());
    addr = PathAddress.pathAddress(addType.get(OP_ADDR));
    Assert.assertEquals(<span class="integer">2</span>, addr.size());
    element = addr.getElement(<span class="integer">0</span>);
    Assert.assertEquals(SUBSYSTEM, element.getKey());
    Assert.assertEquals(SubsystemExtension.SUBSYSTEM_NAME, element.getValue());
    element = addr.getElement(<span class="integer">1</span>);
    Assert.assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, element.getKey());
    Assert.assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>, element.getValue());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second test we need to modify is <code>testInstallIntoController()</code> which
tests that the xml installs properly into the controller. In other words
we are making sure that the <code>add</code> operations we created earlier work
properly. First we create the xml and install it into the controller.
Behind the scenes this will parse the xml into operations as we saw in
the last test, but it will also create a new controller and boot that up
using the created operations</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="annotation">@Test</span>
<span class="directive">public</span> <span class="type">void</span> testInstallIntoController() <span class="directive">throws</span> <span class="exception">Exception</span> {
    <span class="comment">//Parse the subsystem xml and install into the controller</span>
    <span class="predefined-type">String</span> subsystemXml =
            <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;subsystem xmlns=</span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> + SubsystemExtension.NAMESPACE + <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">   &lt;deployment-types&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">       &lt;deployment-type suffix=</span><span class="char">\&quot;</span><span class="content">tst</span><span class="char">\&quot;</span><span class="content"> tick=</span><span class="char">\&quot;</span><span class="content">12345</span><span class="char">\&quot;</span><span class="content">/&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">   &lt;/deployment-types&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/subsystem&gt;</span><span class="delimiter">&quot;</span></span>;
    KernelServices services = <span class="local-variable">super</span>.createKernelServicesBuilder(<span class="predefined-constant">null</span>).setSubsystemXml(subsystemXml).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned <code>KernelServices</code> allow us to execute operations on the
controller, and to read the whole model.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Read the whole model and make sure it looks as expected</span>
ModelNode model = services.readWholeModel();
<span class="comment">//Useful for debugging :-)</span>
<span class="comment">//System.out.println(model);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we make sure that the structure of the model within the controller
has the expected format and values</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    Assert.assertTrue(model.get(SUBSYSTEM).hasDefined(SubsystemExtension.SUBSYSTEM_NAME));
    Assert.assertTrue(model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME).hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>));
    Assert.assertTrue(model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>).hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>));
    Assert.assertTrue(model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>).hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>));
    Assert.assertEquals(<span class="integer">12345</span>, model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>).asLong());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last test provided is called <code>testParseAndMarshalModel()</code>. It&#8217;s main
purpose is to make sure that our <code>SubsystemParser.writeContent()</code> works
as expected. This is achieved by starting a controller in the same way
as before</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="annotation">@Test</span>
<span class="directive">public</span> <span class="type">void</span> testParseAndMarshalModel() <span class="directive">throws</span> <span class="exception">Exception</span> {
    <span class="comment">//Parse the subsystem xml and install into the first controller</span>
    <span class="predefined-type">String</span> subsystemXml =
            <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;subsystem xmlns=</span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> + SubsystemExtension.NAMESPACE + <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">   &lt;deployment-types&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">       &lt;deployment-type suffix=</span><span class="char">\&quot;</span><span class="content">tst</span><span class="char">\&quot;</span><span class="content"> tick=</span><span class="char">\&quot;</span><span class="content">12345</span><span class="char">\&quot;</span><span class="content">/&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">   &lt;/deployment-types&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/subsystem&gt;</span><span class="delimiter">&quot;</span></span>;
    KernelServices servicesA = <span class="local-variable">super</span>.createKernelServicesBuilder(<span class="predefined-constant">null</span>).setSubsystemXml(subsystemXml).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we read the model and the xml that was persisted from the first
controller, and use that xml to start a second controller</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Get the model and the persisted xml from the first controller</span>
ModelNode modelA = servicesA.readWholeModel();
<span class="predefined-type">String</span> marshalled = servicesA.getPersistedSubsystemXml();
<span class="error"> </span>
<span class="comment">//Install the persisted xml from the first controller into a second controller</span>
KernelServices servicesB = <span class="local-variable">super</span>.createKernelServicesBuilder(<span class="predefined-constant">null</span>).setSubsystemXml(marshalled).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally we read the model from the second controller, and make sure that
the models are identical by calling <code>compare()</code> on the test superclass.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    ModelNode modelB = servicesB.readWholeModel();
<span class="error"> </span>
    <span class="comment">//Make sure the models from the two controllers are identical</span>
    <span class="local-variable">super</span>.compare(modelA, modelB);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To test the removal of the the subsystem and child resources we modify
the <code>testSubsystemRemoval()</code> test provided by the archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">/**
     * Tests that the subsystem can be removed
     */</span>
    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> testSubsystemRemoval() <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="comment">//Parse the subsystem xml and install into the first controller</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We provide xml for the subsystem installing a child, which in turn
installs a TrackerService</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="predefined-type">String</span> subsystemXml =
                <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;subsystem xmlns=</span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> + SubsystemExtension.NAMESPACE + <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">   &lt;deployment-types&gt;</span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">       &lt;deployment-type suffix=</span><span class="char">\&quot;</span><span class="content">tst</span><span class="char">\&quot;</span><span class="content"> tick=</span><span class="char">\&quot;</span><span class="content">12345</span><span class="char">\&quot;</span><span class="content">/&gt;</span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">   &lt;/deployment-types&gt;</span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/subsystem&gt;</span><span class="delimiter">&quot;</span></span>;
KernelServices services = <span class="local-variable">super</span>.createKernelServicesBuilder(<span class="predefined-constant">null</span>).setSubsystemXml(subsystemXml).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Having installed the xml into the controller we make sure the
TrackerService is there</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Sanity check to test the service for 'tst' was there</span>
services.getContainer().getRequiredService(TrackerService.createServiceName(<span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This call from the subsystem test harness will call remove for each
level in our subsystem, children first and validate<br>
that the subsystem model is empty at the end.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Checks that the subsystem was removed from the model</span>
<span class="local-variable">super</span>.assertRemoveSubsystemResources(services);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally we check that all the services were removed by the remove
handlers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Check that any services that were installed were removed here</span>
    <span class="keyword">try</span> {
        services.getContainer().getRequiredService(TrackerService.createServiceName(<span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>));
        Assert.fail(<span class="string"><span class="delimiter">&quot;</span><span class="content">Should have removed services</span><span class="delimiter">&quot;</span></span>);
    } <span class="keyword">catch</span> (<span class="exception">Exception</span> expected) {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For good measure let us throw in another test which adds a
<code>deployment-type</code> and also changes its attribute at runtime. So first of
all boot up the controller with the same xml we have been using so far</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="annotation">@Test</span>
<span class="directive">public</span> <span class="type">void</span> testExecuteOperations() <span class="directive">throws</span> <span class="exception">Exception</span> {
    <span class="predefined-type">String</span> subsystemXml =
            <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;subsystem xmlns=</span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> + SubsystemExtension.NAMESPACE + <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">   &lt;deployment-types&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">       &lt;deployment-type suffix=</span><span class="char">\&quot;</span><span class="content">tst</span><span class="char">\&quot;</span><span class="content"> tick=</span><span class="char">\&quot;</span><span class="content">12345</span><span class="char">\&quot;</span><span class="content">/&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">   &lt;/deployment-types&gt;</span><span class="delimiter">&quot;</span></span> +
            <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/subsystem&gt;</span><span class="delimiter">&quot;</span></span>;
    KernelServices services = <span class="local-variable">super</span>.createKernelServicesBuilder(<span class="predefined-constant">null</span>).setSubsystemXml(subsystemXml).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now create an operation which does the same as the following CLI command
<code>/subsystem=tracker/type=foo:add(tick=1000)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Add another type</span>
PathAddress fooTypeAddr = PathAddress.pathAddress(
        PathElement.pathElement(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME),
        PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>));
ModelNode addOp = <span class="keyword">new</span> ModelNode();
addOp.get(OP).set(ADD);
addOp.get(OP_ADDR).set(fooTypeAddr.toModelNode());
addOp.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>).set(<span class="integer">1000</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Execute the operation and make sure it was successful</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">ModelNode result = services.executeOperation(addOp);
Assert.assertEquals(SUCCESS, result.get(OUTCOME).asString());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Read the whole model and make sure that the original data is still there
(i.e. the same as what was done by <code>testInstallIntoController()</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">ModelNode model = services.readWholeModel();
Assert.assertTrue(model.get(SUBSYSTEM).hasDefined(SubsystemExtension.SUBSYSTEM_NAME));
Assert.assertTrue(model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME).hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>));
Assert.assertTrue(model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>).hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>));
Assert.assertTrue(model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>).hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>));
Assert.assertEquals(<span class="integer">12345</span>, model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">tst</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>).asLong());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then make sure our new <code>type</code> has been added:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Assert.assertTrue(model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>).hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>));
Assert.assertTrue(model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>).hasDefined(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>));
Assert.assertEquals(<span class="integer">1000</span>, model.get(SUBSYSTEM, SubsystemExtension.SUBSYSTEM_NAME, <span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>).asLong());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we call <code>write-attribute</code> to change the <code>tick</code> value of
<code>/subsystem=tracker/type=foo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Call write-attribute</span>
ModelNode writeOp = <span class="keyword">new</span> ModelNode();
writeOp.get(OP).set(WRITE_ATTRIBUTE_OPERATION);
writeOp.get(OP_ADDR).set(fooTypeAddr.toModelNode());
writeOp.get(NAME).set(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>);
writeOp.get(VALUE).set(<span class="integer">3456</span>);
result = services.executeOperation(writeOp);
Assert.assertEquals(SUCCESS, result.get(OUTCOME).asString());</code></pre>
</div>
</div>
<div class="paragraph">
<p>To give you exposure to other ways of doing things, now instead of
reading the whole model to check the attribute, we call <code>read-attribute</code>
instead, and make sure it has the value we set it to.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">//Check that write attribute took effect, this time by calling read-attribute instead of reading the whole model</span>
ModelNode readOp = <span class="keyword">new</span> ModelNode();
readOp.get(OP).set(READ_ATTRIBUTE_OPERATION);
readOp.get(OP_ADDR).set(fooTypeAddr.toModelNode());
readOp.get(NAME).set(<span class="string"><span class="delimiter">&quot;</span><span class="content">tick</span><span class="delimiter">&quot;</span></span>);
result = services.executeOperation(readOp);
Assert.assertEquals(<span class="integer">3456</span>, checkResultAndGetContents(result).asLong());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since each <code>type</code> installs its own copy of <code>TrackerService</code>, we get the
<code>TrackerService</code> for <code>type=foo</code> from the service container exposed by
the kernel services and make sure it has the right value</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    TrackerService service = (TrackerService)services.getContainer().getService(TrackerService.createServiceName(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>)).getValue();
    Assert.assertEquals(<span class="integer">3456</span>, service.getTick());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>TypeDefinition.TICK.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="add-the-deployers"><a class="anchor" href="#add-the-deployers"></a>2.5. Add the deployers</h3>
<div class="paragraph">
<p>When discussing <code>SubsystemAdd</code> we did not mention the work done
to install the deployers, which is done in the following method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> performBoottime(OperationContext context, ModelNode operation, ModelNode model,
            ServiceVerificationHandler verificationHandler, <span class="predefined-type">List</span>&lt;ServiceController&lt;?&gt;&gt; newControllers)
            <span class="directive">throws</span> OperationFailedException {
<span class="error"> </span>
        log.info(<span class="string"><span class="delimiter">&quot;</span><span class="content">Populating the model</span><span class="delimiter">&quot;</span></span>);
<span class="error"> </span>
        <span class="comment">//Add deployment processors here</span>
        <span class="comment">//Remove this if you don't need to hook into the deployers, or you can add as many as you like</span>
        <span class="comment">//see SubDeploymentProcessor for explanation of the phases</span>
        context.addStep(<span class="keyword">new</span> AbstractDeploymentChainStep() {
            <span class="directive">public</span> <span class="type">void</span> execute(DeploymentProcessorTarget processorTarget) {
                processorTarget.addDeploymentProcessor(SubsystemExtension.SUBSYSTEM_NAME, SubsystemDeploymentProcessor.PHASE, SubsystemDeploymentProcessor.PRIORITY, <span class="keyword">new</span> SubsystemDeploymentProcessor());
<span class="error"> </span>
            }
        }, OperationContext.Stage.RUNTIME);
<span class="error"> </span>
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This adds an extra step which is responsible for installing deployment
processors. You can add as many as you like, or avoid adding any all
together depending on your needs. Each processor has a <code>Phase</code> and a
<code>priority</code>. Phases are sequential, and a deployment passes through each
phases deployment processors. The <code>priority</code> specifies where within a
phase the processor appears. See <code>org.jboss.as.server.deployment.Phase</code>
for more information about phases.</p>
</div>
<div class="paragraph">
<p>In our case we are keeping it simple and staying with one deployment
processor with the phase and priority created for us by the maven
archetype. The phases will be explained in the next section. The
deployment processor is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SubsystemDeploymentProcessor</span> <span class="directive">implements</span> DeploymentUnitProcessor {
    ...
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> deploy(DeploymentPhaseContext phaseContext) <span class="directive">throws</span> DeploymentUnitProcessingException {
        <span class="predefined-type">String</span> name = phaseContext.getDeploymentUnit().getName();
        TrackerService service = getTrackerService(phaseContext.getServiceRegistry(), name);
        <span class="keyword">if</span> (service != <span class="predefined-constant">null</span>) {
            ResourceRoot root = phaseContext.getDeploymentUnit().getAttachment(Attachments.DEPLOYMENT_ROOT);
            VirtualFile cool = root.getRoot().getChild(<span class="string"><span class="delimiter">&quot;</span><span class="content">META-INF/cool.txt</span><span class="delimiter">&quot;</span></span>);
            service.addDeployment(name);
            <span class="keyword">if</span> (cool.exists()) {
                service.addCoolDeployment(name);
            }
        }
    }
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> undeploy(DeploymentUnit context) {
        context.getServiceRegistry();
        <span class="predefined-type">String</span> name = context.getName();
        TrackerService service = getTrackerService(context.getServiceRegistry(), name);
        <span class="keyword">if</span> (service != <span class="predefined-constant">null</span>) {
            service.removeDeployment(name);
        }
    }
<span class="error"> </span>
    <span class="directive">private</span> TrackerService getTrackerService(<span class="predefined-type">ServiceRegistry</span> registry, <span class="predefined-type">String</span> name) {
        <span class="type">int</span> last = name.lastIndexOf(<span class="string"><span class="delimiter">&quot;</span><span class="content">.</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">String</span> suffix = name.substring(last + <span class="integer">1</span>);
        ServiceController&lt;?&gt; container = registry.getService(TrackerService.createServiceName(suffix));
        <span class="keyword">if</span> (container != <span class="predefined-constant">null</span>) {
            TrackerService service = (TrackerService)container.getValue();
            <span class="keyword">return</span> service;
        }
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>deploy()</code> method is called when a deployment is being deployed. In
this case we look for the <code>TrackerService</code> instance for the service name
created from the deployment&#8217;s suffix. If there is one it means that we
are meant to be tracking deployments with this suffix (i.e.
<code>TypeAddHandler</code> was called for this suffix), and if we find one we add
the deployment&#8217;s name to it. Similarly <code>undeploy()</code> is called when a
deployment is being undeployed, and if there is a <code>TrackerService</code>
instance for the deployment&#8217;s suffix, we remove the deployment&#8217;s name
from it.</p>
</div>
<div class="sect3">
<h4 id="deployment-phases-and-attachments"><a class="anchor" href="#deployment-phases-and-attachments"></a>2.5.1. Deployment phases and attachments</h4>
<div class="paragraph">
<p>The code in the SubsystemDeploymentProcessor uses an <em>attachment</em>, which
is the means of communication between the individual deployment
processors. A deployment processor belonging to a phase may create an
attachment which is then read further along the chain of deployment unit
processors. In the above example we look for the
<code>Attachments.DEPLOYMENT_ROOT</code> attachment, which is a view of the file
structure of the deployment unit put in place before the chain of
deployment unit processors is invoked.</p>
</div>
<div class="paragraph">
<p>As mentioned above, the deployment unit processors are organized in
phases, and have a relative order within each phase. A deployment unit
passes through all the deployment unit processors in that order. A
deployment unit processor may choose to take action or not depending on
what attachments are available. Let&#8217;s take a quick look at what the
deployment unit processors for in the phases described in
<code>org.jboss.as.server.deployment.Phase</code>.</p>
</div>
<div class="sect4">
<h5 id="structure"><a class="anchor" href="#structure"></a>STRUCTURE</h5>
<div class="paragraph">
<p>The deployment unit processors in this phase determine the structure of
a deployment, and looks for sub deployments and metadata files.</p>
</div>
</div>
<div class="sect4">
<h5 id="parse"><a class="anchor" href="#parse"></a>PARSE</h5>
<div class="paragraph">
<p>In this phase the deployment unit processors parse the deployment
descriptors and build up the annotation index. <code>Class-Path</code> entries from
the META-INF/MANIFEST.MF are added.</p>
</div>
</div>
<div class="sect4">
<h5 id="dependencies"><a class="anchor" href="#dependencies"></a>DEPENDENCIES</h5>
<div class="paragraph">
<p>Extra class path dependencies are added. For example if deploying a
<code>war</code> file, the commonly needed dependencies for a web application are
added.</p>
</div>
</div>
<div class="sect4">
<h5 id="configure_module"><a class="anchor" href="#configure_module"></a>CONFIGURE_MODULE</h5>
<div class="paragraph">
<p>In this phase the modular class loader for the deployment is created. No
attempt should be made loading classes from the deployment until <strong>after</strong>
this phase.</p>
</div>
</div>
<div class="sect4">
<h5 id="post_module"><a class="anchor" href="#post_module"></a>POST_MODULE</h5>
<div class="paragraph">
<p>Now that our class loader has been constructed we have access to the
classes. In this stage deployment processors may use the
<code>Attachments.REFLECTION_INDEX</code> attachment which is a deployment index
used to obtain members of classes in the deployment, and to invoke upon
them, bypassing the inefficiencies of using <code>java.lang.reflect</code>
directly.</p>
</div>
</div>
<div class="sect4">
<h5 id="install"><a class="anchor" href="#install"></a>INSTALL</h5>
<div class="paragraph">
<p>Install new services coming from the deployment.</p>
</div>
</div>
<div class="sect4">
<h5 id="cleanup"><a class="anchor" href="#cleanup"></a>CLEANUP</h5>
<div class="paragraph">
<p>Attachments put in place earlier in the deployment unit processor chain
may be removed here.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integrate-with-wildfly"><a class="anchor" href="#integrate-with-wildfly"></a>2.6. Integrate with WildFly</h3>
<div class="paragraph">
<p>Now that we have all the code needed for our subsystem, we can build our
project by running <code>mvn install</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[kabir ~/sourcecontrol/temp/archetype-test/acme-subsystem]
$mvn install
[INFO] Scanning for projects...
[...]
main:
   [delete] Deleting: /Users/kabir/sourcecontrol/temp/archetype-test/acme-subsystem/null1004283288
   [delete] Deleting directory /Users/kabir/sourcecontrol/temp/archetype-test/acme-subsystem/target/module
     [copy] Copying 1 file to /Users/kabir/sourcecontrol/temp/archetype-test/acme-subsystem/target/module/com/acme/corp/tracker/main
     [copy] Copying 1 file to /Users/kabir/sourcecontrol/temp/archetype-test/acme-subsystem/target/module/com/acme/corp/tracker/main
     [echo] Module com.acme.corp.tracker has been created in the target/module directory. Copy to your JBoss AS 7 installation.
[INFO] Executed tasks
[INFO]
[INFO] --- maven-install-plugin:2.3.1:install (default-install) @ acme-subsystem ---
[INFO] Installing /Users/kabir/sourcecontrol/temp/archetype-test/acme-subsystem/target/acme-subsystem.jar to /Users/kabir/.m2/repository/com/acme/corp/acme-subsystem/1.0-SNAPSHOT/acme-subsystem-1.0-SNAPSHOT.jar
[INFO] Installing /Users/kabir/sourcecontrol/temp/archetype-test/acme-subsystem/pom.xml to /Users/kabir/.m2/repository/com/acme/corp/acme-subsystem/1.0-SNAPSHOT/acme-subsystem-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.851s
[INFO] Finished at: Mon Jul 11 23:24:58 BST 2011
[INFO] Final Memory: 7M/81M
[INFO] ------------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will have built our project and assembled a module for us that can
be used for installing it into WildFly. If you go to the <code>target/module</code>
folder where you built the project you will see the module</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>$ls target/module/com/acme/corp/tracker/main/
acme-subsystem.jar  module.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>module.xml</code> comes from <code>src/main/resources/module/main/module.xml</code>
and is used to define your module. It says that it contains the
<code>acme-subsystem.jar</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml"><span class="tag">&lt;module</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:jboss:module:1.9</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.corp.tracker</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;resources&gt;</span>
        <span class="tag">&lt;resource-root</span> <span class="attribute-name">path</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">acme-subsystem.jar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;/resources&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And has a default set of dependencies needed by every subsystem created.
If your subsystem requires additional module dependencies you can add
them here before building and installing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml">    <span class="tag">&lt;dependencies&gt;</span>
        <span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java.se</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.staxmapper</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.as.controller</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.as.server</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.modules</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.msc</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.logging</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;module</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.vfs</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;/dependencies&gt;</span>
<span class="tag">&lt;/module&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the name of the module corresponds to the directory structure
containing it. Now copy the <code>target/module/com/acme/corp/tracker/main/</code>
directory and its contents to
<code>$WFLY/modules/com/acme/corp/tracker/main/</code> (where <code>$WFLY</code> is the root
of your WildFly install).</p>
</div>
<div class="paragraph">
<p>Next we need to modify <code>$WFLY/standalone/configuration/standalone.xml</code>.
First we need to add our new module to the <code>&lt;extensions&gt;</code> section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    &lt;extensions&gt;
        ...
        &lt;extension module=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.as.weld</span><span class="delimiter">&quot;</span></span>/&gt;
        &lt;extension module=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.corp.tracker</span><span class="delimiter">&quot;</span></span>/&gt;
    &lt;/extensions&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then we have to add our subsystem to the <code>&lt;profile&gt;</code> section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml">    <span class="tag">&lt;profile&gt;</span>
    ...
 
        <span class="tag">&lt;subsystem</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:com.acme.corp.tracker:1.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
            <span class="tag">&lt;deployment-types&gt;</span>
                <span class="tag">&lt;deployment-type</span> <span class="attribute-name">suffix</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">sar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">tick</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">10000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;deployment-type</span> <span class="attribute-name">suffix</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">war</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">tick</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">10000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
            <span class="tag">&lt;/deployment-types&gt;</span>
        <span class="tag">&lt;/subsystem&gt;</span>
    ...
    <span class="tag">&lt;/profile&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding this to a managed domain works exactly the same apart from in
this case you need to modify <code>$WFLY/domain/configuration/domain.xml</code>.</p>
</div>
<div class="paragraph">
<p>Now start up WildFly by running <code>$WFLY/bin/standalone.sh</code> and you should
see messages like these after the server has started, which means our
subsystem has been added and our <code>TrackerService</code> is working:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>15:27:33,838 INFO  [org.jboss.as] (Controller Boot Thread) JBoss AS 7.0.0.Final "Lightning" started in 2861ms - Started 94 of 149 services (55 services are passive or on-demand)
15:27:42,966 INFO  [stdout] (Thread-8) Current deployments deployed while sar tracking active:
15:27:42,966 INFO  [stdout] (Thread-8) []
15:27:42,967 INFO  [stdout] (Thread-8) Cool: 0
15:27:42,967 INFO  [stdout] (Thread-9) Current deployments deployed while war tracking active:
15:27:42,967 INFO  [stdout] (Thread-9) []
15:27:42,967 INFO  [stdout] (Thread-9) Cool: 0
15:27:52,967 INFO  [stdout] (Thread-8) Current deployments deployed while sar tracking active:
15:27:52,967 INFO  [stdout] (Thread-8) []
15:27:52,967 INFO  [stdout] (Thread-8) Cool: 0</pre>
</div>
</div>
<div class="paragraph">
<p>If you run the command line interface you can execute some commands to
see more about the subsystem. For example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[standalone@localhost:9999 /] /subsystem=tracker/:read-resource-description(recursive=true, operations=true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>will return a lot of information, including a description of our subsystem
generated automatically by a <code>DescriptionProvider</code></p>
</div>
<div class="paragraph">
<p>To see the current subsystem state you can execute</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[standalone@localhost:9999 /] /subsystem=tracker/:read-resource(recursive=true)
{
    &quot;outcome&quot; =&gt; &quot;success&quot;,
    &quot;result&quot; =&gt; {&quot;type&quot; =&gt; {
        &quot;war&quot; =&gt; {&quot;tick&quot; =&gt; 10000L},
        &quot;sar&quot; =&gt; {&quot;tick&quot; =&gt; 10000L}
    }}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can remove both the deployment types which removes them from the
model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[standalone@localhost:9999 /] /subsystem=tracker/type=sar:remove
{&quot;outcome&quot; =&gt; &quot;success&quot;}
[standalone@localhost:9999 /] /subsystem=tracker/type=war:remove
{&quot;outcome&quot; =&gt; &quot;success&quot;}
[standalone@localhost:9999 /] /subsystem=tracker/:read-resource(recursive=true)
{
    &quot;outcome&quot; =&gt; &quot;success&quot;,
    &quot;result&quot; =&gt; {&quot;type&quot; =&gt; undefined}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should now see the output from the <code>TrackerService</code> instances having
stopped.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s add the war tracker again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[standalone@localhost:9999 /] /subsystem=tracker/type=war:add
{&quot;outcome&quot; =&gt; &quot;success&quot;}
[standalone@localhost:9999 /] /subsystem=tracker/:read-resource(recursive=true)
{
    &quot;outcome&quot; =&gt; &quot;success&quot;,
    &quot;result&quot; =&gt; {&quot;type&quot; =&gt; {&quot;war&quot; =&gt; {&quot;tick&quot; =&gt; 10000L}}}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the WildFly console should show the messages coming from the war
<code>TrackerService</code> again.</p>
</div>
<div class="paragraph">
<p>Now let us deploy something. You can find two maven projects for test
wars already built at <a href="downloads/test1.zip">test1.zip</a> and
<a href="downloads/test2.zip">test2.zip</a>. If you download them and
extract them to <code>/Downloads/test1</code> and <code>/Downloads/test2</code>, you can see
that <code>/Downloads/test1/target/test1.war</code> contains a <code>META-INF/cool.txt</code>
while <code>/Downloads/test2/target/test2.war</code> does not contain that file.
From CLI deploy <code>test1.war</code> first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">[standalone<span class="annotation">@localhost</span>:<span class="integer">9999</span> /] deploy ~/Downloads/test1/target/test1.war
<span class="string"><span class="delimiter">'</span><span class="content">test1.war</span><span class="delimiter">'</span></span> deployed successfully.</code></pre>
</div>
</div>
<div class="paragraph">
<p>And you should now see the output from the war <code>TrackerService</code> list the
deployments:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>15:35:03,712 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-2) Starting deployment of "test1.war"
15:35:03,988 INFO  [org.jboss.web] (MSC service thread 1-1) registering web context: /test1
15:35:03,996 INFO  [org.jboss.as.server.controller] (pool-2-thread-9) Deployed "test1.war"
15:35:13,056 INFO  [stdout] (Thread-9) Current deployments deployed while war tracking active:
15:35:13,056 INFO  [stdout] (Thread-9) [test1.war]
15:35:13,057 INFO  [stdout] (Thread-9) Cool: 1</pre>
</div>
</div>
<div class="paragraph">
<p>So our <code>test1.war</code> got picked up as a 'cool' deployment. Now if we
deploy <code>test2.war</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[standalone@localhost:9999 /] deploy ~/sourcecontrol/temp/archetype-test/test2/target/test2.war
'test2.war' deployed successfully.</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will see that deployment get picked up as well but since there is no
<code>META-INF/cool.txt</code> it is not marked as a 'cool' deployment:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>15:37:05,634 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-4) Starting deployment of "test2.war"
15:37:05,699 INFO  [org.jboss.web] (MSC service thread 1-1) registering web context: /test2
15:37:05,982 INFO  [org.jboss.as.server.controller] (pool-2-thread-15) Deployed "test2.war"
15:37:13,075 INFO  [stdout] (Thread-9) Current deployments deployed while war tracking active:
15:37:13,075 INFO  [stdout] (Thread-9) [test1.war, test2.war]
15:37:13,076 INFO  [stdout] (Thread-9) Cool: 1</pre>
</div>
</div>
<div class="paragraph">
<p>An undeploy</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">[standalone<span class="annotation">@localhost</span>:<span class="integer">9999</span> /] undeploy test1.war
Successfully undeployed test1.war.</code></pre>
</div>
</div>
<div class="paragraph">
<p>is also reflected in the <code>TrackerService</code> output:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>15:38:47,901 INFO  [org.jboss.as.server.controller] (pool-2-thread-21) Undeployed "test1.war"
15:38:47,934 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-3) Stopped deployment test1.war in 40ms
15:38:53,091 INFO  [stdout] (Thread-9) Current deployments deployed while war tracking active:
15:38:53,092 INFO  [stdout] (Thread-9) [test2.war]
15:38:53,092 INFO  [stdout] (Thread-9) Cool: 0</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we registered a write attribute handler for the <code>tick</code> property
of the <code>type</code> so we can change the frequency</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[standalone@localhost:9999 /] /subsystem=tracker/type=war:write-attribute(name=tick,value=1000)
{&quot;outcome&quot; =&gt; &quot;success&quot;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should now see the output from the <code>TrackerService</code> happen every
second</p>
</div>
<div class="literalblock">
<div class="content">
<pre>15:39:43,100 INFO  [stdout] (Thread-9) Current deployments deployed while war tracking active:
15:39:43,100 INFO  [stdout] (Thread-9) [test2.war]
15:39:43,101 INFO  [stdout] (Thread-9) Cool: 0
15:39:44,101 INFO  [stdout] (Thread-9) Current deployments deployed while war tracking active:
15:39:44,102 INFO  [stdout] (Thread-9) [test2.war]
15:39:44,105 INFO  [stdout] (Thread-9) Cool: 0
15:39:45,106 INFO  [stdout] (Thread-9) Current deployments deployed while war tracking active:
15:39:45,106 INFO  [stdout] (Thread-9) [test2.war]</pre>
</div>
</div>
<div class="paragraph">
<p>If you open <code>$WFLY/standalone/configuration/standalone.xml</code> you can see
that our subsystem entry reflects the current state of the subsystem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml">        <span class="tag">&lt;subsystem</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:com.acme.corp.tracker:1.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
            <span class="tag">&lt;deployment-types&gt;</span>
                <span class="tag">&lt;deployment-type</span> <span class="attribute-name">suffix</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">war</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">tick</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
            <span class="tag">&lt;/deployment-types&gt;</span>
        <span class="tag">&lt;/subsystem&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions"><a class="anchor" href="#expressions"></a>2.7. Expressions</h3>
<div class="paragraph">
<p>Expressions are mechanism that enables you to support variables in your
attributes, for instance when you want the value of attribute to be
resolved using system / environment properties.</p>
</div>
<div class="paragraph">
<p>An example expression is</p>
</div>
<div class="literalblock">
<div class="content">
<pre>${jboss.bind.address.management:127.0.0.1}</pre>
</div>
</div>
<div class="paragraph">
<p>which means that the value should be taken from a system property named
<code>jboss.bind.address.management</code> and if it is not defined use
<code>127.0.0.1</code>.</p>
</div>
<div class="sect3">
<h4 id="what-expression-types-are-supported"><a class="anchor" href="#what-expression-types-are-supported"></a>2.7.1. What expression types are supported</h4>
<div class="ulist">
<ul>
<li>
<p>System properties, which are resolved using
<code>java.lang.System.getProperty(String key)</code></p>
</li>
<li>
<p>Environment properties, which are resolved using
<code>java.lang.System.getEnv(String name)</code>.</p>
</li>
<li>
<p>Encrypted expressions, resolved against the expression
resolver in the <code>elytron</code> subsystem.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In all cases, the syntax for the expression is</p>
</div>
<div class="literalblock">
<div class="content">
<pre>${expression_to_resolve}</pre>
</div>
</div>
<div class="paragraph">
<p>For an expression meant to be resolved against environment properties,
the <code>expression_to_resolve</code> must be prefixed with <code>env.</code>. The portion
after <code>env.</code> will be the name passed to
<code>java.lang.System.getEnv(String name)</code>.</p>
</div>
<div class="paragraph">
<p>Encrypted expressions do not support default values (i.e. the
<code>127.0.0.1</code> in the <code>jboss.bind.address.management:127.0.0.1</code> example
above.)</p>
</div>
</div>
<div class="sect3">
<h4 id="how-to-support-expressions-in-subsystems"><a class="anchor" href="#how-to-support-expressions-in-subsystems"></a>2.7.2. How to support expressions in subsystems</h4>
<div class="paragraph">
<p>The easiest way is by using AttributeDefinition, which provides support
for expressions just by using it correctly.</p>
</div>
<div class="paragraph">
<p>When we create an AttributeDefinition all we need to do is mark that is
allows expressions. Here is an example how to define an attribute that
allows expressions to be used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">SimpleAttributeDefinition MY_ATTRIBUTE =
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">new</span> SimpleAttributeDefinitionBuilder(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-attribute</span><span class="delimiter">&quot;</span></span>, ModelType.INT, <span class="predefined-constant">true</span>)
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="error"> </span><span class="error"> </span> .setAllowExpression(<span class="predefined-constant">true</span>)
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> .setFlags(AttributeAccess.Flag.RESTART_ALL_SERVICES)
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> .setDefaultValue(<span class="keyword">new</span> ModelNode(<span class="integer">1</span>))
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then later when you are parsing the xml configuration you should use the
MY_ATTRIBUTE attribute definition to set the value to the management
operation ModelNode you are creating.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">....
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="predefined-type">String</span> attr = reader.getAttributeLocalName(i);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="predefined-type">String</span> value = reader.getAttributeValue(i);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="keyword">if</span> (attr.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-attribute</span><span class="delimiter">&quot;</span></span>)) {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> MY_ATTRIBUTE.parseAndSetParameter(value, operation, reader);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> } <span class="keyword">else</span> <span class="keyword">if</span> (attr.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">suffix</span><span class="delimiter">&quot;</span></span>)) {
.....</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this just helps you to properly set the value to the model
node you are working on, so no need to additionally set anything to the
model for this attribute. Method parseAndSetParameter parses the value
that was read from xml for possible expressions in it and if it finds
any it creates special model node that defines that node is of type
<code>ModelType.EXPRESSION</code>.</p>
</div>
<div class="paragraph">
<p>Later in your operation handlers where you implement populateModel and
have to store the value from the operation to the configuration model
you also use this MY_ATTRIBUTE attribute definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"> <span class="annotation">@Override</span>
<span class="error"> </span><span class="directive">protected</span> <span class="type">void</span> populateModel(ModelNode operation, ModelNode model) <span class="directive">throws</span> OperationFailedException {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> MY_ATTRIBUTE.validateAndSet(operation,model);
<span class="error"> </span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will make sure that the attribute that is stored from the operation
to the model is valid and nothing is lost. It also checks the value
stored in the operation <code>ModelNode</code>, and if it isn&#8217;t already
<code>ModelType.EXPRESSION</code>, it checks if the value is a string that contains
the expression syntax. If so, the value stored in the model will be of
type <code>ModelType.EXPRESSION</code>. Doing this ensures that expressions are
properly handled when they appear in operations that weren&#8217;t created by
the subsystem parser, but are instead passed in from CLI or admin
console users.</p>
</div>
<div class="paragraph">
<p>As last step we need to use the value of the attribute. This is usually
needed inside of the <code>performRuntime</code> method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"> <span class="directive">protected</span> <span class="type">void</span> performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, <span class="predefined-type">List</span>&lt;ServiceController&lt;?&gt;&gt; newControllers) <span class="directive">throws</span> OperationFailedException {
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> ....
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> <span class="directive">final</span> <span class="type">int</span> attributeValue = MY_ATTRIBUTE.resolveModelAttribute(context, model).asInt();<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> ...
<span class="error"> </span>
<span class="error"> </span><span class="error"> </span><span class="error"> </span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see resolving of attribute&#8217;s value is not done until it is
needed for use in the subsystem&#8217;s runtime services. The resolved value
is not stored in the configuration model, the unresolved expression is.
That way we do not lose any information in the model and can assure that
also marshalling is done properly, where we must marshall back the
unresolved value.</p>
</div>
<div class="paragraph">
<p>Attribute definitinon also helps you with that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"> <span class="directive">public</span> <span class="type">void</span> writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) <span class="directive">throws</span> XMLStreamException {
<span class="error"> </span><span class="error"> </span><span class="error"> </span> ....
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> MY_ATTRIBUTE.marshallAsAttribute(sessionData, writer);
<span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span> MY_OTHER_ATTRIBUTE.marshallAsElement(sessionData, <span class="predefined-constant">false</span>, writer);
<span class="error"> </span><span class="error"> </span><span class="error"> </span> ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Working_with_WildFly_Capabilities"><a class="anchor" href="#Working_with_WildFly_Capabilities"></a>3. Working with WildFly Capabilities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An extension to WildFly will likely want to make use of services
provided by the WildFly kernel, may want to make use of services
provided by other subsystems, and may wish to make functionality
available to other extensions. Each of these cases involves integration
between different parts of the system. In releases prior to WildFly 10,
this kind of integration was done on an ad-hoc basis, resulting in
overly tight coupling between different parts of the system and overly
weak integration contracts. For example, a service installed by
subsystem A might depend on a service installed by subsystem B, and to
record that dependency A&#8217;s authors copy a ServiceName from B&#8217;s code, or
even refer to a constant or static method from B&#8217;s code. The result is
B&#8217;s code cannot evolve without risking breaking A. And the authors of B
may not even intend for other subsystems to use its services. There is
no proper integration contract between the two subsystems.</p>
</div>
<div class="paragraph">
<p>Beginning with WildFly Core 2 and WildFly 10 the WildFly kernel&#8217;s
management layer provides a mechanism for allowing different parts of
the system to integrate with each other in a loosely coupled manner.
This is done via WildFly Capabilities. Use of capabilities provides the
following benefits:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A standard way for system components to define integration contracts
for their use by other system components.</p>
</li>
<li>
<p>A standard way for system components to access integration contracts
provided by other system components.</p>
</li>
<li>
<p>A mechanism for configuration model referential integrity checking,
such that if one component&#8217;s configuration has an attribute that refers
to an other component (e.g. a <code>socket-binding</code> attribute in a subsystem
that opens a socket referring to that socket&#8217;s configuration), the
validity of that reference can be checked when validating the
configuration model.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="capabilities"><a class="anchor" href="#capabilities"></a>3.1. Capabilities</h3>
<div class="paragraph">
<p>A capability is a piece of functionality used in a WildFly Core based
process that is exposed via the WildFly Core management layer.
Capabilities may depend on other capabilities, and this interaction
between capabilities is mediated by the WildFly Core management layer.</p>
</div>
<div class="paragraph">
<p>Some capabilities are automatically part of a WildFly Core based
process, but in most cases the configuration provided by the end user
(i.e. in standalone.xml, domain.xml and host.xml) determines what
capabilities are present at runtime. It is the responsibility of the
handlers for management operations to register capabilities and to
register any requirements those capabilities may have for the presence
of other capabilities. This registration is done during the MODEL stage
of operation execution</p>
</div>
<div class="paragraph">
<p>A capability has the following basic characteristics:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It has a name.</p>
</li>
<li>
<p>It may install an MSC service that can be depended upon by services
installed by other capabilities. If it does, it provides a mechanism for
discovering the name of that service.</p>
</li>
<li>
<p>It may expose some other API not based on service dependencies
allowing other capabilities to integrate with it at runtime.</p>
</li>
<li>
<p>It may depend on, or <strong>require</strong> other capabilities.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>During boot of the process, and thereafter whenever a management
operation makes a change to the process' configuration, at the end of
the MODEL stage of operation execution the kernel management layer will
validate that all capabilities required by other capabilities are
present, and will fail any management operation step that introduced an
unresolvable requirement. This will be done before execution of the
management operation proceeds to the RUNTIME stage, where interaction
with the process' MSC Service Container is done. As a result, in the
RUNTIME stage the handler for an operation can safely assume that the
runtime services provided by a capability for which it has registered a
requirement are available.</p>
</div>
<div class="sect3">
<h4 id="comparison-to-other-concepts"><a class="anchor" href="#comparison-to-other-concepts"></a>3.1.1. Comparison to other concepts</h4>
<div class="sect4">
<h5 id="capabilities-vs-modules"><a class="anchor" href="#capabilities-vs-modules"></a>Capabilities vs modules</h5>
<div class="paragraph">
<p>A JBoss Modules module is the means of making resources available to the
classloading system of a WildFly Core based process. To make a
capability available, you must package its resources in one or more
modules and make them available to the classloading system. But a module
is not a capability in and of itself, and simply copying a module to a
WildFly installation does not mean a capability is available. Modules
can include resources completely unrelated to management capabilities.</p>
</div>
</div>
<div class="sect4">
<h5 id="capabilities-vs-extensions"><a class="anchor" href="#capabilities-vs-extensions"></a>Capabilities vs Extensions</h5>
<div class="paragraph">
<p>An extension is the means by which the WildFly Core management layer is
made aware of manageable functionality that is not part of the WildFly
Core kernel. The extension registers with the kernel new management
resource types and handlers for operations on those resources. One of
the things a handler can do is register or unregister a capability and
its requirements. An extension may register a single capability,
multiple capabilities, or possibly none at all. Further, not all
capabilities are registered by extensions; the WildFly Core kernel
itself may register a number of different capabilities.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="capability-names"><a class="anchor" href="#capability-names"></a>3.1.2. Capability Names</h4>
<div class="paragraph">
<p>Capability names are simple strings, with the dot character serving as a
separator to allow namespacing.</p>
</div>
<div class="paragraph">
<p>The 'org.wildfly' namespace is reserved for projects associated with the
WildFly organization on github ( <a href="https://github.com/wildfly" class="bare">https://github.com/wildfly</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="statically-vs-dynamically-named-capabilities"><a class="anchor" href="#statically-vs-dynamically-named-capabilities"></a>3.1.3. Statically vs Dynamically Named Capabilities</h4>
<div class="paragraph">
<p>The full name of a capability is either statically known, or it may
include a statically known base element and then a dynamic element. The
dynamic part of the name is determined at runtime based on the address
of the management resource that registers the capability. For example,
the management resource at the address
'/socket-binding-group=standard-sockets/socket-binding=web' will
register a dynamically named capability named
'org.wildfly.network.socket-binding.web'. The
'org.wildfly.network.socket-binding' portion is the static part of the
name.</p>
</div>
<div class="paragraph">
<p>All dynamically named capabilities that have the same static portion of
their name should provide a consistent feature set and set of
requirements.</p>
</div>
</div>
<div class="sect3">
<h4 id="service-provided-by-a-capability"><a class="anchor" href="#service-provided-by-a-capability"></a>3.1.4. Service provided by a capability</h4>
<div class="paragraph">
<p>Typically a capability functions by registering a service with the
WildFly process' MSC ServiceContainer, and then dependent capabilities
depend on that service. The WildFly Core management layer orchestrates
registration of those services and service dependencies by providing a
means to discover service names.</p>
</div>
</div>
<div class="sect3">
<h4 id="custom-integration-apis-provided-by-a-capability"><a class="anchor" href="#custom-integration-apis-provided-by-a-capability"></a>3.1.5. Custom integration APIs provided by a capability</h4>
<div class="paragraph">
<p>Instead of or in addition to providing MSC services, a capability may
expose some other API to dependent capabilities. This API must be
encapsulated in a single class (although that class can use other
non-JRE classes as method parameters or return types).</p>
</div>
</div>
<div class="sect3">
<h4 id="capability-requirements"><a class="anchor" href="#capability-requirements"></a>3.1.6. Capability Requirements</h4>
<div class="paragraph">
<p>A capability may rely on other capabilities in order to provide its
functionality at runtime. The management operation handlers that
register capabilities are also required to register their requirements.</p>
</div>
<div class="paragraph">
<p>There are three basic types of requirements a capability may have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hard requirements. The required capability must always be present for
the dependent capability to function.</p>
</li>
<li>
<p>Optional requirements. Some aspect of the configuration of the
dependent capability controls whether the depended on capability is
actually necessary. So the requirement cannot be known until the running
configuration is analyzed.</p>
</li>
<li>
<p>Runtime-only requirements. The dependent capability will check for the
presence of the depended upon capability at runtime, and if present it
will utilize it, but if it is not present it will function properly
without the capability. There is nothing in the dependent capability&#8217;s
configuration that controls whether the depended on capability must be
present. Only capabilities that declare themselves as being suitable for
use as a runtime-only requirement should be depended upon in this
manner.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hard and optional requirements may be for either statically named or
dynamically named capabilities. Runtime-only requirements can only be
for statically named capabilities, as such a requirement cannot be
specified via configuration, and without configuration the dynamic part
of the required capability name is unknown.</p>
</div>
<div class="sect4">
<h5 id="supporting-runtime-only-requirements"><a class="anchor" href="#supporting-runtime-only-requirements"></a>Supporting runtime-only requirements</h5>
<div class="paragraph">
<p>Not all capabilities are usable as a runtime-only requirement.</p>
</div>
<div class="paragraph">
<p>Any dynamically named capability is not usable as a runtime-only
requirement.</p>
</div>
<div class="paragraph">
<p>For a capability to support use as a runtime-only requirement, it must
guarantee that a configuration change to a running process that removes
the capability will not impact currently running capabilities that have
a runtime-only requirement for it. This means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A capability that supports runtime-only usage must ensure that it
never removes its runtime service except via a full process reload.</p>
</li>
<li>
<p>A capability that exposes a custom integration API generally is not
usable as a runtime-only requirement. If such a capability does support
use as a runtime-only requirement, it must ensure that any functionality
provided via its integration API remains available as long as a full
process reload has not occurred.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="capability-contract"><a class="anchor" href="#capability-contract"></a>3.2. Capability Contract</h3>
<div class="paragraph">
<p>A capability provides a stable contract to users of the capability. The
contract includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The name of the capability (including whether it is dynamically
named).</p>
</li>
<li>
<p>Whether it installs an MSC Service, and if it does, the value type of
the service. That value type then becomes a stable API users of the
capability can rely upon.</p>
</li>
<li>
<p>Whether it provides a custom integration API, and if it does, the type
that represents that API. That type then becomes a stable API users of
the capability can rely upon.</p>
</li>
<li>
<p>Whether the capability supports use as a runtime-only requirement.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Developers can learn about available capabilities and the contracts they
provide by reading the WildFly <em>capabilty registry</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="capability-registry"><a class="anchor" href="#capability-registry"></a>3.3. Capability Registry</h3>
<div class="paragraph">
<p>The WildFly organization on github maintains a git repo where
information about available capabilities is published.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/wildfly/wildfly-capabilities" class="bare">https://github.com/wildfly/wildfly-capabilities</a></p>
</div>
<div class="paragraph">
<p>Developers can learn about available capabilities and the contracts they
provide by reading the WildFly capabilty registry.</p>
</div>
<div class="paragraph">
<p>The README.md file at the root of that repo explains the how to find out
information about the registry.</p>
</div>
<div class="paragraph">
<p>Developers of new capabilities are <strong>strongly encouraged</strong> to document and
register their capability by submitting a pull request to the
wildfly-capabilities github repo. This both allows others to learn about
your capability and helps prevent capability name collisions.
Capabilities that are used in the WildFly or WildFly Core code base
itself <strong>must</strong> have a registry entry before the code referencing them
will be merged.</p>
</div>
<div class="paragraph">
<p>External organizations that create capabilities should include an
organization-specific namespace as part their capability names to avoid
name collisions.</p>
</div>
</div>
<div class="sect2">
<h3 id="using-capabilities"><a class="anchor" href="#using-capabilities"></a>3.4. Using Capabilities</h3>
<div class="paragraph">
<p>Now that all the background information is presented, here are some
specifics about how to use WildFly capabilities in your code.</p>
</div>
<div class="sect3">
<h4 id="basics-of-using-your-own-capability"><a class="anchor" href="#basics-of-using-your-own-capability"></a>3.4.1. Basics of Using Your Own Capability</h4>
<div class="sect4">
<h5 id="creating-your-capability"><a class="anchor" href="#creating-your-capability"></a>Creating your capability</h5>
<div class="paragraph">
<p>A capability is an instance of the immutable
<code>org.jboss.as.controller.capability.RuntimeCapability</code> class. A
capability is usually registered by a resource, so the usual way to use
one is to store it in constant in the resource&#8217;s <code>ResourceDefinition</code>.
Use a <code>RuntimeCapability.Builder</code> to create one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">MyResourceDefinition</span> <span class="directive">extends</span> SimpleResourceDefinition {

    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;<span class="predefined-type">Void</span>&gt; FOO_CAPABILITY = RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.foo</span><span class="delimiter">&quot;</span></span>).build();
<span class="error"> </span>
    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That creates a statically named capability named <code>com.example.foo</code>.</p>
</div>
<div class="paragraph">
<p>If the capability is dynamically named, add the <code>dynamic</code> parameter to
state this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;<span class="predefined-type">Void</span>&gt; FOO_CAPABILITY =
            RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.foo</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">true</span>).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most capabilities install a service that requiring capabilities can
depend on. If your capability does this, you need to declare the
service&#8217;s <em>value type</em> (the type of the object returned by
<code>org.jboss.msc.Service.getValue()</code>). For example, if FOO_CAPABILITY
provides a <code>Service&lt;javax.sql.DataSource&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;<span class="predefined-type">Void</span>&gt; FOO_CAPABILITY =
            RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.foo</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">DataSource</span>.class).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a dynamic capability:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;<span class="predefined-type">Void</span>&gt; FOO_CAPABILITY =
           RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.foo</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">true</span>, <span class="predefined-type">DataSource</span>.class).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the capability provides a custom integration API, you need to
instantiate an instance of that API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">JTSCapability</span> {
<span class="error"> </span>
    <span class="directive">static</span> <span class="directive">final</span> JTSCapability INSTANCE = <span class="keyword">new</span> JTSCapability();
<span class="error"> </span>
    <span class="directive">private</span> JTSCapability() {}
<span class="error"> </span>
    <span class="comment">/**
     * Gets the names of the {@link org.omg.PortableInterceptor.ORBInitializer} implementations that should be included
     * as part of the {@link org.omg.CORBA.ORB#init(String[], java.util.Properties) initialization of an ORB}.
     *
     * @return the names of the classes implementing {@code ORBInitializer}. Will not be {@code null}.
     */</span>
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; getORBInitializerClasses() {
        <span class="keyword">return</span> <span class="predefined-type">Collections</span>.unmodifiableList(<span class="predefined-type">Arrays</span>.asList(
            <span class="string"><span class="delimiter">&quot;</span><span class="content">com.arjuna.ats.jts.orbspecific.jacorb.interceptors.interposition.InterpositionORBInitializerImpl</span><span class="delimiter">&quot;</span></span>,
            <span class="string"><span class="delimiter">&quot;</span><span class="content">com.arjuna.ats.jbossatx.jts.InboundTransactionCurrentInitializer</span><span class="delimiter">&quot;</span></span>));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and provide it to the builder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;JTSCapability&gt; FOO_CAPABILITY =
            RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.foo</span><span class="delimiter">&quot;</span></span>, JTSCapability.INSTANCE).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a dynamic capability:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;JTSCapability&gt; FOO_CAPABILITY = RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.foo</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">true</span>, JTSCapability.INSTANCE).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A capability can provide both a custom integration API and install a
service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;JTSCapability&gt; FOO_CAPABILITY =
            RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.foo</span><span class="delimiter">&quot;</span></span>, JTSCapability.INSTANCE)
                .setServiceType(<span class="predefined-type">DataSource</span>.class)
                .build();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="registering-and-unregistering-your-capability"><a class="anchor" href="#registering-and-unregistering-your-capability"></a>Registering and unregistering your capability</h5>
<div class="paragraph">
<p>Once you have your capability, you need to ensure it gets registered
with the WildFly Core kernel when your resource is added. This is easily
done simply by providing a reference to the capability to the resource&#8217;s
<code>ResourceDefinition</code>. This assumes your resource definition is a
subclass of the standard
<code>org.jboss.as.controller.SimpleResourceDefinition</code>.
<code>SimpleResourceDefinition</code> provides a <code>Parameters</code> class that provides a
builder-style API for setting up all the data needed by your definition.
This includes a <code>setCapabilities</code> method that can be used to declare the
capabilities provided by resources of this type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">MyResourceDefinition</span> <span class="directive">extends</span> SimpleResourceDefinition {

    . . .
<span class="error"> </span>
    MyResourceDefinition() {
        <span class="local-variable">super</span>(<span class="keyword">new</span> SimpleResourceDefinition.Parameters(PATH, RESOLVER)
            .setAddHandler(MyAddHandler.INSTANCE)
            .setRemoveHandler(MyRemoveHandler.INSTANCE)
            .setCapabilities(FOO_CAPABILITY)
            );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your add handler needs to extend the standard
<code>org.jboss.as.controller.AbstractAddStepHandler</code> class or one of its
subclasses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">MyAddHandler</span> <span class="directive">extends</span> AbstractAddStepHandler() {</code></pre>
</div>
</div>
<div class="paragraph">
<p>`AbstractAddStepHandler&#8217;s logic will register the capability when it
executes.</p>
</div>
<div class="paragraph">
<p>Your remove handler must also extend of the standard
<code>org.jboss.as.controller.AbstractRemoveStepHandler</code> or one of its
subclasses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">MyRemoveHandler</span> <span class="directive">extends</span> AbstractRemoveStepHandler() {</code></pre>
</div>
</div>
<div class="paragraph">
<p>`AbstractRemoveStepHandler&#8217;s logic will deregister the capability when
it executes.</p>
</div>
<div class="paragraph">
<p>If for some reason you cannot base your <code>ResourceDefinition</code> on
<code>SimpleResourceDefinition</code> or your handlers on <code>AbstractAddStepHandler</code>
and <code>AbstractRemoveStepHandler</code> then you will need to take
responsibility for registering the capability yourself. This is not
expected to be a common situation. See the implementation of those
classes to see how to do it.</p>
</div>
</div>
<div class="sect4">
<h5 id="installing-accessing-and-removing-the-service-provided-by-your-capability"><a class="anchor" href="#installing-accessing-and-removing-the-service-provided-by-your-capability"></a>Installing, accessing and removing the service provided by your</h5>
<div class="paragraph">
<p>capability</p>
</div>
<div class="paragraph">
<p>If your capability installs a service, you should use the
<code>RuntimeCapability</code> when you need to determine the service&#8217;s name. For
example in the <code>Stage.RUNTIME</code> handling of your "add" step handler.
Here&#8217;s an example for a statically named capability:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">MyAddHandler</span> <span class="directive">extends</span> AbstractAddStepHandler() {
<span class="error"> </span>
    . . .
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> performRuntime(<span class="directive">final</span> OperationContext context, <span class="directive">final</span> ModelNode operation,
                                  <span class="directive">final</span> Resource resource) <span class="directive">throws</span> OperationFailedException {

        ServiceName serviceName = FOO_CAPABILITY.getCapabilityServiceName();
        Service&lt;<span class="predefined-type">DataSource</span>&gt; service = createDataSourceService(context, resource);
        context.getServiceTarget().addService(serviceName, service).install();

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the capability is dynamically named, get the dynamic part of the name
from the <code>OperationContext</code> and use that when getting the service name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">MyAddHandler</span> <span class="directive">extends</span> AbstractAddStepHandler() {
<span class="error"> </span>
    . . .
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> performRuntime(<span class="directive">final</span> OperationContext context, <span class="directive">final</span> ModelNode operation,
                                  <span class="directive">final</span> Resource resource) <span class="directive">throws</span> OperationFailedException {

        <span class="predefined-type">String</span> myName = context.getCurrentAddressValue();
        ServiceName serviceName = FOO_CAPABILITY.getCapabilityServiceName(myName);
        Service&lt;<span class="predefined-type">DataSource</span>&gt; service = createDataSourceService(context, resource);
        context.getServiceTarget().addService(serviceName, service).install();

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same patterns should be used when accessing or removing the service
in handlers for <code>remove</code>, <code>write-attribute</code> and custom operations.</p>
</div>
<div class="paragraph">
<p>If you use <code>ServiceRemoveStepHandler</code> for the <code>remove</code> operation, simply
provide your <code>RuntimeCapability</code> to the <code>ServiceRemoveStepHandler</code>
constructor and it will automatically remove your capability&#8217;s service
when it executes.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basics-of-using-other-capabilities"><a class="anchor" href="#basics-of-using-other-capabilities"></a>3.4.2. Basics of Using Other Capabilities</h4>
<div class="paragraph">
<p>When a capability needs another capability, it only refers to it by its
string name. A capability should not reference the <code>RuntimeCapability</code>
object of another capability.</p>
</div>
<div class="paragraph">
<p>Before a capability can look up the service name for a required
capability&#8217;s service, or access its custom integration API, it must
first register a requirement for the capability. This must be done in
Stage.MODEL, while service name lookups and accessing the custom
integration API is done in Stage.RUNTIME.</p>
</div>
<div class="paragraph">
<p>Registering a requirement for a capability is simple.</p>
</div>
<div class="sect4">
<h5 id="registering-a-hard-requirement-for-a-static-capability"><a class="anchor" href="#registering-a-hard-requirement-for-a-static-capability"></a>Registering a hard requirement for a static capability</h5>
<div class="paragraph">
<p>If your capability has a hard requirement for a statically named
capability, simply declare that to the builder for your
<code>RuntimeCapability</code>. For example, WildFly&#8217;s JTS capability requires both
a basic transaction support capability and IIOP capabilities:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;JTSCapability&gt; JTS_CAPABILITY =
            RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.wildfly.transactions.jts</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> JTSCapability())
                .addRequirements(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.wildfly.transactions</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">org.wildfly.iiop.orb</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">org.wildfly.iiop.corba-naming</span><span class="delimiter">&quot;</span></span>)
                .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When your capability is registered with the system, the WildFly Core
kernel will automatically register any static hard requirements declared
this way.</p>
</div>
</div>
<div class="sect4">
<h5 id="registering-a-requirement-for-a-dynamically-named-capability"><a class="anchor" href="#registering-a-requirement-for-a-dynamically-named-capability"></a>Registering a requirement for a dynamically named capability</h5>
<div class="paragraph">
<p>If the capability you require is dynamically named, usually your
capability&#8217;s resource will include an attribute whose value is the
dynamic part of the required capability&#8217;s name. You should declare this
fact in the <code>AttributeDefinition</code> for the attribute using the
<code>SimpleAttributeDefinitionBuilder.setCapabilityReference</code> method.</p>
</div>
<div class="paragraph">
<p>For example, the WildFly "remoting" subsystem&#8217;s
"org.wildfly.remoting.connector" capability has a requirement for a
dynamically named socket-binding capability:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ConnectorResource</span> <span class="directive">extends</span> SimpleResourceDefinition {
<span class="error"> </span>
    . . .
<span class="error"> </span>
    <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SOCKET_CAPABILITY_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.wildfly.network.socket-binding</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">static</span> <span class="directive">final</span> RuntimeCapability&lt;<span class="predefined-type">Void</span>&gt; CONNECTOR_CAPABILITY =
            RuntimeCapability.Builder.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.wildfly.remoting.connector</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">true</span>)
                    .build();
<span class="error"> </span>
    . . .
<span class="error"> </span>
    <span class="directive">static</span> <span class="directive">final</span> SimpleAttributeDefinition SOCKET_BINDING =
            <span class="keyword">new</span> SimpleAttributeDefinitionBuilder(CommonAttributes.SOCKET_BINDING, ModelType.STRING, <span class="predefined-constant">false</span>)
                .addAccessConstraint(SensitiveTargetAccessConstraintDefinition.SOCKET_BINDING_REF)
                .setCapabilityReference(SOCKET_CAPABILITY_NAME, CONNECTOR_CAPABILITY)
                .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the "add" operation handler for your resource extends
<code>AbstractAddStepHandler</code> and the handler for <code>write-attribute</code> extends
<code>AbstractWriteAttributeHandler</code>, the declaration above is sufficient to
ensure that the appropriate capability requirement will be registered
when the attribute is modified.</p>
</div>
</div>
<div class="sect4">
<h5 id="depending-upon-a-service-provided-by-another-capability"><a class="anchor" href="#depending-upon-a-service-provided-by-another-capability"></a>Depending upon a service provided by another capability</h5>
<div class="paragraph">
<p>Once the requirement for the capability is registered, your
<code>OperationStepHandler</code> can use the <code>OperationContext</code> to discover the
name of the service provided by the required capability.</p>
</div>
<div class="paragraph">
<p>For example, the "add" handler for a remoting connector uses the
<code>OperationContext</code> to find the name of the needed \{{SocketBinding}
service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        <span class="directive">final</span> <span class="predefined-type">String</span> socketName = ConnectorResource.SOCKET_BINDING.resolveModelAttribute(context, fullModel).asString();
        <span class="directive">final</span> ServiceName socketBindingName = context.getCapabilityServiceName(ConnectorResource.SOCKET_CAPABILITY_NAME, socketName, SocketBinding.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>That service name is then used to add a dependency on the
<code>SocketBinding</code> service to the remoting connector service.</p>
</div>
<div class="paragraph">
<p>If the required capability isn&#8217;t dynamically named, <code>OperationContext</code>
exposes an overloaded <code>getCapabilityServiceName</code> variant. For example,
if a capability requires a remoting Endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        ServiceName endpointService = context.getCapabilityServiceName(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.wildfly.remoting.endpoint</span><span class="delimiter">&quot;</span></span>, Endpoint.class);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-a-custom-integration-api-provided-by-another-capability"><a class="anchor" href="#using-a-custom-integration-api-provided-by-another-capability"></a>Using a custom integration API provided by another capability</h5>
<div class="paragraph">
<p>In your <code>Stage.RUNTIME</code> handler, use
<code>OperationContext.getCapabilityRuntimeAPI</code> to get a reference to the
required capability&#8217;s custom integration API. Then use it as necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; orbInitializers = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;();
        . . .
        JTSCapability jtsCapability = context.getCapabilityRuntimeAPI(IIOPExtension.JTS_CAPABILITY, JTSCapability.class);
        orbInitializers.addAll(jtsCapability.getORBInitializerClasses());</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="runtime-only-requirements"><a class="anchor" href="#runtime-only-requirements"></a>Runtime-only requirements</h5>
<div class="paragraph">
<p>If your capability has a runtime-only requirement for another
capability, that means that if that capability is present in
<code>Stage.RUNTIME</code> you&#8217;ll use it, and if not you won&#8217;t. There is nothing
about the configuration of your capability that triggers the need for
the other capability; you&#8217;ll just use it if it&#8217;s there.</p>
</div>
<div class="paragraph">
<p>In this case, use <code>OperationContext.hasOptionalCapability</code> in your
<code>Stage.RUNTIME</code> handler to check if the capability is present:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">protected</span> <span class="type">void</span> performRuntime(<span class="directive">final</span> OperationContext context, <span class="directive">final</span> ModelNode operation, <span class="directive">final</span> ModelNode model) <span class="directive">throws</span> OperationFailedException {
<span class="error"> </span>
        ServiceName myServiceName = MyResource.FOO_CAPABILITY.getCapabilityServiceName();
        Service&lt;<span class="predefined-type">DataSource</span>&gt; myService = createService(context, model);
        ServiceBuilder&lt;<span class="predefined-type">DataSource</span>&gt; builder = context.getTarget().addService(myServiceName, myService);
<span class="error"> </span>
        <span class="comment">// Inject a &quot;Bar&quot; into our &quot;Foo&quot; if bar capability is present</span>
        <span class="keyword">if</span> (context.hasOptionalCapability(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.bar</span><span class="delimiter">&quot;</span></span>, MyResource.FOO_CAPABILITY.getName(), <span class="predefined-constant">null</span>) {
            ServiceName barServiceName = context.getCapabilityServiceName(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.bar</span><span class="delimiter">&quot;</span></span>, Bar.class);
            builder.addDependency(barServiceName, Bar.class, myService.getBarInjector());
        }
<span class="error"> </span>
        builder.install();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The WildFly Core kernel will not register a requirement for the
"com.example.bar" capability, so if a configuration change occurs that
means that capability will no longer be present, that change will not be
rolled back. Because of this, runtime-only requirements can only be used
with capabilities that declare in their contract that they support such
use.</p>
</div>
</div>
<div class="sect4">
<h5 id="using-a-capability-in-a-deploymentunitprocessor"><a class="anchor" href="#using-a-capability-in-a-deploymentunitprocessor"></a>Using a capability in a DeploymentUnitProcessor</h5>
<div class="paragraph">
<p>A <code>DeploymentUnitProcessor</code> is likely to have a need to interact with
capabilities, in order to create service dependencies from a deployment
service to a capability provided service or to access some aspect of a
capability&#8217;s custom integration API that relates to deployments.</p>
</div>
<div class="paragraph">
<p>If a <code>DeploymentUnitProcessor</code> associated with a capability
implementation needs to utilize its own capability object, the
<code>DeploymentUnitProcessor</code> authors should simply provide it with a
reference to the <code>RuntimeCapability</code> instance. Service name lookups or
access to the capabilities custom integration API can then be performed
by invoking the methods on the <code>RuntimeCapability</code>.</p>
</div>
<div class="paragraph">
<p>If you need to access service names or a custom integration API
associated with a different capability, you will need to use the
<code>org.jboss.as.controller.capability.CapabilityServiceSupport</code> object
associated with the deployment unit. This can be found as an attachment
to the <code>DeploymentPhaseContext</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="type">class</span> <span class="class">MyDUP</span> <span class="directive">implements</span> DeploymentUntiProcessor {
<span class="error"> </span>
    <span class="directive">public</span> <span class="type">void</span> deploy(DeploymentPhaseContext phaseContext) <span class="directive">throws</span> DeploymentUnitProcessingException {
<span class="error"> </span>
        AttachmentKey&lt;CapabilityServiceSupport&gt; key = org.jboss.as.server.deployment.Attachments.DEPLOYMENT_COMPLETE_SERVICES;
        CapabilityServiceSupport capSvcSupport = phaseContext.getAttachment(key);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have the <code>CapabilityServiceSupport</code> you can use it to look up
service names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        ServiceName barSvcName = capSvcSupport.getCapabilityServiceName(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.bar</span><span class="delimiter">&quot;</span></span>);
        <span class="comment">// Determine what 'baz' the user specified in the deployment descriptor</span>
        <span class="predefined-type">String</span> bazDynamicName = getSelectedBaz(phaseContext);
        ServiceName bazSvcName = capSvcSupport.getCapabilityServiceName(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.baz</span><span class="delimiter">&quot;</span></span>, bazDynamicName);</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
It&#8217;s important to note that when you request a service name associated
with a capability, the <code>CapabilityServiceSupport</code> will give you one
regardless of whether the capability is actually registered with the
kernel. If the capability isn&#8217;t present, any service dependency your DUP
creates using that service name will eventually result in a service
start failure, due to the missing dependency. This behavior of not
failing immediately when the capability service name is requested is
deliberate. It allows deployment operations that use the
<code>rollback-on-runtime-failure=false</code> header to successfully install (but
not start) all of the services related to a deployment. If a subsequent
operation adds the missing capability, the missing service dependency
problem will then be resolved and the MSC service container will
automatically start the deployment services.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also use the <code>CapabilityServiceSupport</code> to obtain a reference to
the capability&#8217;s custom integration API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        <span class="comment">// We need custom integration with the baz capability beyond service injection</span>
        BazIntegrator bazIntegrator;
        <span class="keyword">try</span> {
            bazIntegrator = capSvcSupport.getCapabilityRuntimeAPI(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.baz</span><span class="delimiter">&quot;</span></span>, bazDynamicName, BazIntegrator.class);
        } <span class="keyword">catch</span> (NoSuchCapabilityException e) {
            <span class="comment">//</span>
            <span class="predefined-type">String</span> msg = <span class="predefined-type">String</span>.format(<span class="string"><span class="delimiter">&quot;</span><span class="content">Deployment %s requires use of the 'bar' capability but it is not currently registered</span><span class="delimiter">&quot;</span></span>,
                                       phaseContext.getDeploymentUnit().getName());
            <span class="keyword">throw</span> <span class="keyword">new</span> DeploymentUnitProcessingException(msg);
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that here, unlike the case with service name lookups, the
<code>CapabilityServiceSupport</code> will throw a checked exception if the desired
capability is not installed. This is because the kernel has no way to
satisfy the request for a custom integration API if the capability is
not installed. The <code>DeploymentUnitProcessor</code> will need to catch and
handle the exception.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="detailed-api"><a class="anchor" href="#detailed-api"></a>3.4.3. Detailed API</h4>
<div class="paragraph">
<p>The WildFly Core kernel&#8217;s API for using capabilities is covered in
detail in the javadoc for the
<a href="https://github.com/wildfly/wildfly-core/blob/main/controller/src/main/java/org/jboss/as/controller/capability/RuntimeCapability.java">RuntimeCapability
and RuntimeCapability.Builder</a> classes and the
<a href="https://github.com/wildfly/wildfly-core/blob/main/controller/src/main/java/org/jboss/as/controller/OperationContext.java">OperationContext</a>
and
<a href="https://github.com/wildfly/wildfly-core/blob/main/controller/src/main/java/org/jboss/as/controller/capability/CapabilityServiceSupport.java">CapabilityServiceSupport</a>
interfaces.</p>
</div>
<div class="paragraph">
<p>Many of the methods in <code>OperationContext</code> related to capabilities have
to do with registering capabilities or registering requirements for
capabilities. Typically non-kernel developers won&#8217;t need to worry about
these, as the abstract <code>OperationStepHandler</code> implementations provided
by the kernel take care of this for you, as described in the preceding
sections. If you do find yourself in a situation where you need to use
these in an extension, please read the javadoc thoroughly.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Domain_Mode_Subsystem_Transformers"><a class="anchor" href="#Domain_Mode_Subsystem_Transformers"></a>4. Domain Mode Subsystem Transformers</h2>
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
A WildFly domain may consist of a new Domain Controller (DC) controlling
secondary Host Controllers (HC) running older versions. Each secondary HC
maintains a copy of the centralized domain configuration, which they use
for controlling their own servers. In order for the secondary HCs to
understand the configuration from the DC, transformation is needed,
whereby the DC translates the configuration and operations into
something the secondary HCs can understand.
</blockquote>
</div>
<div class="sect2">
<h3 id="background"><a class="anchor" href="#background"></a>4.1. Background</h3>
<div class="paragraph">
<p>WildFly comes with a <a href="Admin_Guide.html#Domain_Setup">domain mode</a> which allows
you to have one Host Controller acting as the Domain Controller. The
Domain Controller&#8217;s job is to maintain the centralized domain
configuration. Another term for the DC is 'Primary Host Controller'.
Before explaining why transformers are important and when they should be
used, we will revisit how the domain configuration is used in domain
mode.</p>
</div>
<div class="paragraph">
<p>The centralized domain configuration is stored in <code>domain.xml</code>. This is
only ever parsed on the DC, and it has the following structure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>extensions</code> - contains:</p>
<div class="ulist">
<ul>
<li>
<p><code>extension</code> - a references to a module that bootstraps the
<code>org.jboss.as.controller.Extension</code> implementation used to bootstrap
your subsystem parsers and initialize the resource definitions for your
subsystems.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>profiles</code> - contains:</p>
<div class="ulist">
<ul>
<li>
<p><code>profile</code> - a named set of:</p>
<div class="ulist">
<ul>
<li>
<p><code>subsystem</code> - contains the configuration for a subsystem, using the
parser initialized by the subsystem&#8217;s extension.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>socket-binding-groups</code> - contains:</p>
<div class="ulist">
<ul>
<li>
<p><code>socket-binding-group</code> - a named set of:</p>
<div class="ulist">
<ul>
<li>
<p><code>socket-binding</code> - A named port on an interface which can be
referenced from the <code>subsystem</code> configurations for subsystems opening
sockets.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>server-groups</code> - contains</p>
<div class="ulist">
<ul>
<li>
<p><code>server-group</code> - this has a name and references a <code>profile</code> and a
<code>socket-binding-group</code>. The HCs then reference the <code>server-group</code> name
from their <code>&lt;servers&gt;</code> section in <code>host.xml</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the DC parses <code>domain.xml</code>, it is transformed into <code>add</code> (and in
some cases <code>write-attribute</code>) operations just as explained in
<a href="Parsing_and_marshalling_of_the_subsystem_xml.html">Parsing and
marshalling of the subsystem xml</a>. These operations build up the model
on the DC.</p>
</div>
<div class="paragraph">
<p>A HC wishing to join the domain and use the DC&#8217;s centralized
configuration is known as a 'secondary HC'. A secondary HC maintains a copy of
the DC&#8217;s centralized domain configuration. This copy of the domain
configuration is used to start its servers. This is done by asking the
domain model to <code>describe</code> itself, which in turn asks the subsystems to
<code>describe</code> themselves. The <code>describe</code> operation for a subsystem looks at
the state of the subsystem model and produces the <code>add</code> operations
necessary to create the subsystem on the server. The same mechanism also
takes place on the DC (bear in mind that the DC is also a HC, which can
have its own servers), although of course its copy of the domain
configuration is the centralized one.</p>
</div>
<div class="paragraph">
<p>There are two steps involved in keeping the secondary HC&#8217;s
domain configuration in sync with the centralized domain configuration.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>getting the initial domain model</p>
</li>
<li>
<p>an operation changes something in the domain configuration</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s look a bit closer at what happens in each of these steps.</p>
</div>
<div class="sect3">
<h4 id="getting-the-initial-domain-model"><a class="anchor" href="#getting-the-initial-domain-model"></a>4.1.1. Getting the initial domain model</h4>
<div class="paragraph">
<p>When a secondary HC connects to the DC it obtains a copy of the domain model
from the DC. This is done in a simpler serialized format, different from
the operations that built up the model on the DC, or the operations
resulting from the <code>describe</code> step used to bootstrap the servers. They
describe each address that exists in the DC&#8217;s model, and contain the
attributes set for the resource at that address. This serialized form
looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[{
    &quot;domain-resource-address&quot; =&gt; [],
    &quot;domain-resource-model&quot; =&gt; {
        &quot;management-major-version&quot; =&gt; 2,
        &quot;management-minor-version&quot; =&gt; 0,
        &quot;management-micro-version&quot; =&gt; 0,
        &quot;release-version&quot; =&gt; &quot;8.0.0.Beta1-SNAPSHOT&quot;,
        &quot;release-codename&quot; =&gt; &quot;WildFly&quot;
    }
},
{
    &quot;domain-resource-address&quot; =&gt; [(&quot;extension&quot; =&gt; &quot;org.jboss.as.clustering.infinispan&quot;)],
    &quot;domain-resource-model&quot; =&gt; {&quot;module&quot; =&gt; &quot;org.jboss.as.clustering.infinispan&quot;}
},
--SNIP - the rest of the extensions --
{
    &quot;domain-resource-address&quot; =&gt; [(&quot;extension&quot; =&gt; &quot;org.jboss.as.weld&quot;)],
    &quot;domain-resource-model&quot; =&gt; {&quot;module&quot; =&gt; &quot;org.jboss.as.weld&quot;}
},
{
    &quot;domain-resource-address&quot; =&gt; [(&quot;system-property&quot; =&gt; &quot;java.net.preferIPv4Stack&quot;)],
    &quot;domain-resource-model&quot; =&gt; {
        &quot;value&quot; =&gt; &quot;true&quot;,
        &quot;boot-time&quot; =&gt; undefined
    }
},
{
    &quot;domain-resource-address&quot; =&gt; [(&quot;profile&quot; =&gt; &quot;full-ha&quot;)],
    &quot;domain-resource-model&quot; =&gt; undefined
},
{
    &quot;domain-resource-address&quot; =&gt; [
        (&quot;profile&quot; =&gt; &quot;full-ha&quot;),
        (&quot;subsystem&quot; =&gt; &quot;logging&quot;)
    ],
    &quot;domain-resource-model&quot; =&gt; {}
},
{
    &quot;domain-resource-address&quot; =&gt; [sss|WFLY8:Example subsystem],
    &quot;domain-resource-model&quot; =&gt; {
        &quot;level&quot; =&gt; &quot;INFO&quot;,
        &quot;enabled&quot; =&gt; undefined,
        &quot;encoding&quot; =&gt; undefined,
        &quot;formatter&quot; =&gt; &quot;%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%E%n&quot;,
        &quot;filter-spec&quot; =&gt; undefined,
        &quot;autoflush&quot; =&gt; undefined,
        &quot;target&quot; =&gt; undefined,
        &quot;named-formatter&quot; =&gt; undefined
    }
},
--SNIP---</code></pre>
</div>
</div>
<div class="paragraph">
<p>The secondary HC then applies these one at a time and builds up the initial
domain model. It needs to do this before it can start any of its
servers.</p>
</div>
</div>
<div class="sect3">
<h4 id="an-operation-changes-something-in-the-domain-configuration"><a class="anchor" href="#an-operation-changes-something-in-the-domain-configuration"></a>4.1.2. An operation changes something in the domain configuration</h4>
<div class="paragraph">
<p>Once a domain is up and running we can still change things in the domain
configuration. These changes must happen when connected to the DC, and
are then propagated to the secondary HCs, which then in turn propagate the
changes to any servers running in a server group affected by the changes
made. In this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>[disconnected /] connect
[domain@localhost:9990 /] /profile=full/subsystem=datasources/data-source=ExampleDS:write-attribute(name=enabled,value=false)
{
    &quot;outcome&quot; =&gt; &quot;success&quot;,
    &quot;result&quot; =&gt; undefined,
    &quot;server-groups&quot; =&gt; {&quot;main-server-group&quot; =&gt; {&quot;host&quot; =&gt; {
        &quot;secondary&quot; =&gt; {&quot;server-one&quot; =&gt; {&quot;response&quot; =&gt; {
            &quot;outcome&quot; =&gt; &quot;success&quot;,
            &quot;result&quot; =&gt; undefined,
            &quot;response-headers&quot; =&gt; {
                &quot;operation-requires-restart&quot; =&gt; true,
                &quot;process-state&quot; =&gt; &quot;restart-required&quot;
            }
        }}},
        &quot;primary&quot; =&gt; {
            &quot;server-one&quot; =&gt; {&quot;response&quot; =&gt; {
                &quot;outcome&quot; =&gt; &quot;success&quot;,
                &quot;response-headers&quot; =&gt; {
                    &quot;operation-requires-restart&quot; =&gt; true,
                    &quot;process-state&quot; =&gt; &quot;restart-required&quot;
                }
            }},
            &quot;server-two&quot; =&gt; {&quot;response&quot; =&gt; {
                &quot;outcome&quot; =&gt; &quot;success&quot;,
                &quot;response-headers&quot; =&gt; {
                    &quot;operation-requires-restart&quot; =&gt; true,
                    &quot;process-state&quot; =&gt; &quot;restart-required&quot;
                }
            }}
        }
    }}}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the DC propagates the changes to itself <code>host=primary</code>, which in turn
propagates it to its two servers belonging to <code>main-server-group</code> which
uses the <code>full</code> profile. More interestingly, it also propagates it to
<code>host=secondary</code> which updates its local copy of the domain model, and then
propagates the change to its <code>server-one</code> which belongs to
<code>main-server-group</code> which uses the <code>full</code> profile.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="versions-and-backward-compatibility"><a class="anchor" href="#versions-and-backward-compatibility"></a>4.2. Versions and backward compatibility</h3>
<div class="paragraph">
<p>A HC and its servers will always be the same version of WildFly (they
use the same module path and jars). However, the DC and the secondary HCs do
not necessarily need to be the same version. One of the points in the
original specification for WildFly is that</p>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
A Domain Controller should be able to manage secondary Host Controllers
older than itself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This means that for example a WildFly 10.1 DC should be able to work
with secondary HCs running WildFly 10. The opposite is not true, the DC must
be the same or the newest version in the domain.</p>
</div>
<div class="sect3">
<h4 id="versioning-of-subsystems"><a class="anchor" href="#versioning-of-subsystems"></a>4.2.1. Versioning of subsystems</h4>
<div class="paragraph">
<p>To help with being able to know what is compatible we have versions
within the subsystems, this is stored in the subsystem&#8217;s extension. When
registering the subsystem you will typically see something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SomeExtension</span> <span class="directive">implements</span> Extension {
<span class="error"> </span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SUBSYSTEM_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">my-subsystem</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">'</span><span class="content">
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    /**
     * {@inheritDoc}
     * @see org.jboss.as.controller.Extension#initialize(org.jboss.as.controller.ExtensionContext)
     */
    @Override
    public void initialize(ExtensionContext context) {
 
        // IMPORTANT: Management API version != xsd version! Not all Management API changes result in XSD changes
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
 
        //Register the resource definitions
        ....
    }
    ....
}</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which sets the <code>ModelVersion</code> of the subsystem.</p>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Whenever something changes in the subsystem, such as:
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>an attribute is added or removed from a resource</p>
</li>
<li>
<p>a attribute is renamed in a resource</p>
</li>
<li>
<p>an attribute has its type changed</p>
</li>
<li>
<p>an attribute or operation parameter&#8217;s nillable or allows expressions
is changed</p>
</li>
<li>
<p>an attribute or operation parameter&#8217;s default value changes</p>
</li>
<li>
<p>a child resource type is added or removed</p>
</li>
<li>
<p>an operation is added or removed</p>
</li>
<li>
<p>an operation has its parameters changed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and the current version of the subsystem has been part of a Final
release of WildFly, we <strong>must</strong> bump the version of the subsystem.</p>
</div>
<div class="paragraph">
<p>Once it has been increased you can of course make more changes until the
next Final release without more version bumps. It is also worth noting
that a new WildFly release does not automatically mean a new version for
the subsystem, the new version is only needed if something was changed.
For example the <code>jaxrs</code> subsystem remained on 1.0.0 for all versions
of WildFly and JBoss AS 7 through Wildfly 18.</p>
</div>
<div class="paragraph">
<p>You can find the <code>ModelVersion</code> of a subsystem by querying its
extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>domain@localhost:9990 /] /extension=org.jboss.as.clustering.infinispan:read-resource(recursive=true)
{
    &quot;outcome&quot; =&gt; &quot;success&quot;,
    &quot;result&quot; =&gt; {
        &quot;module&quot; =&gt; &quot;org.jboss.as.clustering.infinispan&quot;,
        &quot;subsystem&quot; =&gt; {&quot;infinispan&quot; =&gt; {
            &quot;management-major-version&quot; =&gt; 2,
            &quot;management-micro-version&quot; =&gt; 0,
            &quot;management-minor-version&quot; =&gt; 0,
            &quot;xml-namespaces&quot; =&gt; [jboss:domain:infinispan:1.0&quot;,
                &quot;urn:jboss:domain:infinispan:1.1&quot;,
                &quot;urn:jboss:domain:infinispan:1.2&quot;,
                &quot;urn:jboss:domain:infinispan:1.3&quot;,
                &quot;urn:jboss:domain:infinispan:1.4&quot;,
                &quot;urn:jboss:domain:infinispan:2.0&quot;]
        }}
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the-role-of-transformers"><a class="anchor" href="#the-role-of-transformers"></a>4.3. The role of transformers</h3>
<div class="paragraph">
<p>Now that we have mentioned the secondary HCs registration process with the
DC, and know about ModelVersions, it is time to mention that when
registering with the DC, the secondary HC will send across a list of all its
subsystem ModelVersions. The DC maintains this information in a registry
for each secondary HC, so that it knows which transformers (if any) to
invoke for a legacy secondary. We will see how to write and register
transformers later on in
<a href="#how-do-i-write-a-transformer">#How
do I write a transformer</a>. secondary HCs from version 7.2.0 onwards will
also include a list of resources that they ignore (see
<a href="#ignoring-resources-on-legacy-hosts">#Ignoring
resources on legacy hosts</a>), and the DC will maintain this information
in its registry. The DC will not send across any resources that it knows
a secondary ignores during the initial domain model transfer. When
forwarding operations onto the secondary HCs, the DC will skip forwarding
those to secondary HCs ignoring those resources.</p>
</div>
<div class="paragraph">
<p>There are two kinds of transformers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>resource transformers</p>
</li>
<li>
<p>operation transformers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The main function of transformers is to transform a subsystem to
something that the legacy secondary HC can understand, or to aggressively
reject things that the legacy secondary HC will not understand. Rejection,
in this context, essentially means, that the resource or operation
cannot safely be transformed to something valid on the secondary HC, so the
transformation fails. We will see later how to reject attributes in
<a href="#rejecting-attributes">#Rejecting
attributes</a>, and child resources in
<a href="#reject-child-resource">#Reject
child resource</a>.</p>
</div>
<div class="paragraph">
<p>Both resource and operation transformers are needed, but take effect at
different times. Let us use the <code>weld</code> subsystem, which is relatively
simple, as an example. In JBoss AS 7.2.0 and lower it had a ModelVersion
of 1.0.0, and its resource description was as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>                {
                    &quot;description&quot; =&gt; &quot;The configuration of the weld subsystem.&quot;,
                    &quot;attributes&quot; =&gt; {},
                    &quot;operations&quot; =&gt; {
                        &quot;remove&quot; =&gt; {
                            &quot;operation-name&quot; =&gt; &quot;remove&quot;,
                            &quot;description&quot; =&gt; &quot;Operation removing the weld subsystem.&quot;,
                            &quot;request-properties&quot; =&gt; {},
                            &quot;reply-properties&quot; =&gt; {}
                        },
                        &quot;add&quot; =&gt; {
                            &quot;operation-name&quot; =&gt; &quot;add&quot;,
                            &quot;description&quot; =&gt; &quot;Operation creating the weld subsystem.&quot;,
                            &quot;request-properties&quot; =&gt; {},
                            &quot;reply-properties&quot; =&gt; {}
                        }
                    },
                    &quot;children&quot; =&gt; {}
                },</code></pre>
</div>
</div>
<div class="paragraph">
<p>In WildFly 29, it has a ModelVersion of 2.0.0 and has added two
attributes, <code>require-bean-descriptor</code> and <code>non-portable</code> mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>{
        &quot;description&quot; =&gt; &quot;The configuration of the weld subsystem.&quot;,
        &quot;attributes&quot; =&gt; {
            &quot;require-bean-descriptor&quot; =&gt; {
                &quot;type&quot; =&gt; BOOLEAN,
                &quot;description&quot; =&gt; &quot;If true then implicit bean archives without bean descriptor file (beans.xml) are ignored by Weld&quot;,
                &quot;expressions-allowed&quot; =&gt; true,
                &quot;nillable&quot; =&gt; true,
                &quot;default&quot; =&gt; false,
                &quot;access-type&quot; =&gt; &quot;read-write&quot;,
                &quot;storage&quot; =&gt; &quot;configuration&quot;,
                &quot;restart-required&quot; =&gt; &quot;no-services&quot;
            },
            &quot;non-portable-mode&quot; =&gt; {
                &quot;type&quot; =&gt; BOOLEAN,
                &quot;description&quot; =&gt; &quot;If true then the non-portable mode is enabled. The non-portable mode is suggested by the specification to overcome problems with legacy applications that do not use CDI SPI properly and may be rejected by more strict validation in CDI 1.1.&quot;,
                &quot;expressions-allowed&quot; =&gt; true,
                &quot;nillable&quot; =&gt; true,
                &quot;default&quot; =&gt; false,
                &quot;access-type&quot; =&gt; &quot;read-write&quot;,
                &quot;storage&quot; =&gt; &quot;configuration&quot;,
                &quot;restart-required&quot; =&gt; &quot;no-services&quot;
            }
        },
        &quot;operations&quot; =&gt; {
            &quot;remove&quot; =&gt; {
                &quot;operation-name&quot; =&gt; &quot;remove&quot;,
                &quot;description&quot; =&gt; &quot;Operation removing the weld subsystem.&quot;,
                &quot;request-properties&quot; =&gt; {},
                &quot;reply-properties&quot; =&gt; {}
            },
            &quot;add&quot; =&gt; {
                &quot;operation-name&quot; =&gt; &quot;add&quot;,
                &quot;description&quot; =&gt; &quot;Operation creating the weld subsystem.&quot;,
                &quot;request-properties&quot; =&gt; {
                    &quot;require-bean-descriptor&quot; =&gt; {
                        &quot;type&quot; =&gt; BOOLEAN,
                        &quot;description&quot; =&gt; &quot;If true then implicit bean archives without bean descriptor file (beans.xml) are ignored by Weld&quot;,
                        &quot;expressions-allowed&quot; =&gt; true,
                        &quot;required&quot; =&gt; false,
                        &quot;nillable&quot; =&gt; true,
                        &quot;default&quot; =&gt; false
                    },
                    &quot;non-portable-mode&quot; =&gt; {
                        &quot;type&quot; =&gt; BOOLEAN,
                        &quot;description&quot; =&gt; &quot;If true then the non-portable mode is enabled. The non-portable mode is suggested by the specification to overcome problems with legacy applications that do not use CDI SPI properly and may be rejected by more strict validation in CDI 1.1.&quot;,
                        &quot;expressions-allowed&quot; =&gt; true,
                        &quot;required&quot; =&gt; false,
                        &quot;nillable&quot; =&gt; true,
                        &quot;default&quot; =&gt; false
                    }
                },
                &quot;reply-properties&quot; =&gt; {}
            }
        },
        &quot;children&quot; =&gt; {}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the rest of this section we will assume that we are running a DC
running WildFly 29 so it will have ModelVersion 2.0.0 of the weld
subsystem, and that we are running a secondary HC using ModelVersion 1.0.0 of
the weld subsystem.</p>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Transformation always takes place on the Domain Controller, and is done
when sending across the initial domain model AND forwarding on
operations to legacy secondary HCs.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="resource-transformers"><a class="anchor" href="#resource-transformers"></a>4.3.1. Resource transformers</h4>
<div class="paragraph">
<p>When copying over the centralized domain configuration as mentioned in
<a href="#getting-the-initial-domain-model">#Getting
the initial domain model</a>, we need to make sure that the copy of the
domain model is something that the servers running on the legacy secondary
HC understand. So if the centralized domain configuration had any of the
two new attributes set, we would need to reject the transformation in
the transformers. One reason for this is to keep things consistent, it
doesn&#8217;t look good if you connect to the secondary HC and find attributes
and/or child resources when doing <code>:read-resource</code> which are not there
when you do <code>:read-resource-description</code>. Also, to make life easier for
subsystem writers, most instances of the <code>describe</code> operation use a
standard implementation which would include these attributes when
creating the <code>add</code> operation for the server, which could cause problems
there.</p>
</div>
<div class="paragraph">
<p>Another, more concrete example from the logging subsystem is that it
allows a ' <code>%K{&#8230;&#8203;</code>}' in the pattern formatter which makes the formatter
use color:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml">            <span class="tag">&lt;pattern-formatter</span> <span class="attribute-name">pattern</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">%K{level}%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%E%n</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This ' <code>%K{&#8230;&#8203;</code>}' however was introduced in JBoss AS &lt; 7.1.3
(ModelVersion 1.2.0), so if that makes it across to a secondary HC running
an older version, the servers <strong>will</strong> fail to start up. So the logging
extension registers transformers to strip out the ' <code>%K{&#8230;&#8203;</code>}' from the
attribute value (leaving ' <code>%-5p</code> <code>%c</code> `(%t) %s%E%n"&#8217;) so that the old
secondary HC&#8217;s servers can understand it.</p>
</div>
<div class="sect4">
<h5 id="rejection-in-resource-transformers"><a class="anchor" href="#rejection-in-resource-transformers"></a>Rejection in resource transformers</h5>
<div class="paragraph">
<p>Only secondary HCs from JBoss AS 7.2.0 and newer inform the DC about their
ignored resources (see
<a href="#ignoring-resources-on-legacy-hosts">#Ignoring
resources on legacy hosts</a>). This means that if a transformer on the DC
rejects transformation for a legacy secondary HC, exactly what happens to
the secondary HC depends on the version of the secondary HC. If the secondary HC is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>older than 7.2.0</em> - the DC has no means of knowing if the secondary HC
has ignored the resource being rejected or not. So we log a warning on
the DC, and send over the serialized part of that model anyway. If the
secondary HC has ignored the resource in question, it does not apply it. If
the secondary HC has not ignored the resource in question, it will apply it,
but no failure will happen until it tries to start a server which
references this bad configuration.</p>
</li>
<li>
<p><em>7.2.0 or newer</em> - If a resource is ignored on the secondary HC, the DC
knows about this, and will not attempt to transform or send the resource
across to the secondary HC. If the resource transformation is rejected, we
know the resource was not ignored on the secondary HC and so we can
aggressively fail the transformation, which in turn will cause the secondary
HC to fail to start up.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="operation-transformers"><a class="anchor" href="#operation-transformers"></a>4.3.2. Operation transformers</h4>
<div class="paragraph">
<p>When
<a href="#an-operation-changes-something-in-the-domain-configuration">#An
operation changes something in the domain configuration</a> the operation
gets sent across to the secondary HCs to update their copies of the domain
model. The secondary HCs then forward this operation onto the affected
servers. The same considerations as in
<a href="#resource-transformers">#Resource
transformers</a> are true, although operation transformers give you quicker
'feedback' if something is not valid. If you try to execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>/profile=full/subsystem=weld:write-attribute(name=require-bean-descriptor, value=false)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will fail on the legacy secondary HC since its version of the subsystem
does not contain any such attribute. However, it is best to aggressively
reject in such cases.</p>
</div>
<div class="sect4">
<h5 id="rejection-in-operation-transformers"><a class="anchor" href="#rejection-in-operation-transformers"></a>Rejection in operation transformers</h5>
<div class="paragraph">
<p>For transformed operations we can always know if the operation is on an
ignored resource in the legacy secondary HC. In 7.2.0 onwards, we know this
through the DC&#8217;s registry of ignored resources on the secondary HC. In older
versions of secondary HCs, we send the operation across to the secondary HC, which
tries to invoke the operation. If the operation is against an ignored
resource we inform the DC about this fact. So as part of the
transformation process, if something gets rejected we can (and do!) fail
the transformation aggressively. If the operation invoked on the DC
results in the operation being sent across to 10 secondary HCs and one of
them has a legacy version which ends up rejecting the transformation, we
rollback the operation across the whole domain.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="different-profiles-for-different-versions"><a class="anchor" href="#different-profiles-for-different-versions"></a>4.3.3. Different profiles for different versions</h4>
<div class="paragraph">
<p>Now for the <code>weld</code> example we have been using there is a slight twist.
We have the new <code>require-bean-descriptor</code> and <code>non-portable-mode</code>
attributes. These have been added in WildFly 29 which supports Jakarta EE,
and thus CDI.
In CDI 1.1 the values of these attributes are tweakable, so they can be set
to either <code>true</code> or <code>false</code>. The default behaviour for these in CDI 1.1,
if not set, is that they are <code>false</code>. However, for CDI 1.0 these were
not tweakable, and with the way the subsystem in JBoss AS 7.x worked is
similar to if they are set to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The above discussion implies that to use the weld subsystem on a legacy
secondary HC, the <code>domain.xml</code> configuration for it must look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml"><span class="tag">&lt;subsystem</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:jboss:domain:weld:2.0</span><span class="delimiter">&quot;</span></span>
      <span class="attribute-name">require-bean-descriptor</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
      <span class="attribute-name">non-portable-mode</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We will see the exact mechanics for how this is actually done later but
in short when pushing this to a legacy secondary HC we register transformers
which reject the transformation if these attributes are not set to
<code>true</code> since that implies some behavior not supported on the legacy
secondary HC. If they are <code>true</code>, all is well, and the transformers discard,
or remove, these attributes since they don&#8217;t exist in the legacy model.
This removal is fine since they have the values which would result in
the behavior assumed on the legacy secondary HC.</p>
</div>
<div class="paragraph">
<p>That way the older secondary HCs will work fine. However, we might also have
WildFly 29 secondary HCs in our domain, and they are missing out on the new
features introduced by the attributes introduced in ModelVersion 2.0.0.
If we do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml"><span class="tag">&lt;subsystem</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:jboss:domain:weld:2.0</span><span class="delimiter">&quot;</span></span>
      <span class="attribute-name">require-bean-descriptor</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span>
      <span class="attribute-name">non-portable-mode</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>then it will fail when doing transformation for the legacy controller.
The solution is to put these in two different profiles in <code>domain.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml"><span class="tag">&lt;domain&gt;</span>
....
  <span class="tag">&lt;profiles&gt;</span>
    <span class="tag">&lt;profile</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">full</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      <span class="tag">&lt;subsystem</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:jboss:domain:weld:2.0</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">require-bean-descriptor</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">non-portable-mode</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
      ...
    <span class="tag">&lt;/profile&gt;</span>
    <span class="tag">&lt;profile</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">full-legacy</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      <span class="tag">&lt;subsystem</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:jboss:domain:weld:2.0</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">require-bean-descriptor</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">non-portable-mode</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
      ...
    <span class="tag">&lt;/profile&gt;</span>
  <span class="tag">&lt;/profiles&gt;</span>
  ...
  <span class="tag">&lt;server-groups&gt;</span>
    <span class="tag">&lt;server-group</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">main-server-group</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">full</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      ....
    <span class="tag">&lt;server-group&gt;</span>
    <span class="tag">&lt;server-group</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">main-server-group-legacy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">full-legacy</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
      ....
    <span class="tag">&lt;server-group&gt;</span>
  <span class="tag">&lt;/server-groups&gt;</span>
<span class="tag">&lt;/domain&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then have the HCs using WildFly 29 make their servers reference the
<code>main-server-group</code> server group, and the HCs using older versions of
WildFly 29 make their servers reference the <code>main-server-group-legacy</code>
server group.</p>
</div>
<div class="sect4">
<h5 id="ignoring-resources-on-legacy-hosts"><a class="anchor" href="#ignoring-resources-on-legacy-hosts"></a>Ignoring resources on legacy hosts</h5>
<div class="paragraph">
<p>Booting the above configuration will still cause problems on legacy
secondary HCs, especially if they are JBoss AS 7.2.0 or later. The reason
for this is that when they register themselves with the DC it lets the
DC know which <code>ignored resources</code> they have. If the DC comes to
transform something it should reject for a secondary HC and it is not part
of its ignored resources it will aggressively fail the transformation.
Versions of JBoss AS older than 7.2.0 still have this ignored resources
mechanism, but don&#8217;t let the DC know about what they have ignored so the
DC cannot reject aggressively - instead it will log some warnings.
However, it is still good practice to ignore resources you are not
interested in regardless of which legacy version the secondary HC is
running.</p>
</div>
<div class="paragraph">
<p>To ignore the profile we cannot understand we do the following in the
legacy secondary HC&#8217;s <code>host.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="xml"><span class="tag">&lt;host</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:jboss:domain:1.3</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">secondary</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
...
    <span class="tag">&lt;domain-controller&gt;</span>
       <span class="tag">&lt;remote</span> <span class="attribute-name">host</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jboss.test.host.primary.address}</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">port</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jboss.domain.primary.port:9999}</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">authentication-context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">primary-context</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
            <span class="tag">&lt;ignored-resources</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profile</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;instance</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">full-legacy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
            <span class="tag">&lt;/ignored-resources&gt;</span>
       <span class="tag">&lt;/remote&gt;</span>
    <span class="tag">&lt;/domain-controller&gt;</span>
....
<span class="tag">&lt;/host&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Any top-level resource type can be ignored <code>profile</code>, <code>extension</code>,
<code>server-group</code> etc. Ignoring a resource instance ignores that resource,
and all its children.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="how-do-i-know-what-needs-to-be-transformed"><a class="anchor" href="#how-do-i-know-what-needs-to-be-transformed"></a>4.4. How do I know what needs to be transformed?</h3>
<div class="paragraph">
<p>There is a set of related classes in the <code>org.wildfly.legacy.util</code>
package to help you determine this. These now live at
<a href="https://github.com/wildfly/wildfly-legacy-test/tree/main/tools/src/main/java/org/wildfly/legacy/util" class="bare">https://github.com/wildfly/wildfly-legacy-test/tree/main/tools/src/main/java/org/wildfly/legacy/util</a>.<br>
They are all runnable in your IDE, just start the WildFly or JBoss AS 7
instances as described below.</p>
</div>
<div class="sect3">
<h4 id="getting-data-for-a-previous-version"><a class="anchor" href="#getting-data-for-a-previous-version"></a>4.4.1. Getting data for a previous version</h4>
<div class="paragraph">
<p><a href="https://github.com/wildfly/wildfly-legacy-test/tree/main/tools/src/main/resources/legacy-models" class="bare">https://github.com/wildfly/wildfly-legacy-test/tree/main/tools/src/main/resources/legacy-models</a>
contains the output for the previous WildFly/JBoss AS 7 versions, so
check if the files for the version you want to check backwards
compatibility are there yet. If not, then you need to do the following
to get the subsystem definitions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start the <strong>old</strong> version of WildFly/JBoss AS 7 using
<code>--server-config=standalone-full-ha.xml</code></p>
</li>
<li>
<p>Run <code>org.wildfly.legacy.util.GrabModelVersionsUtil</code>, which will
output the subsystem versions to
<code>target/standalone-model-versions-running.dmr</code></p>
</li>
<li>
<p>Run <code>org.wildfly.legacy.util.DumpStandaloneResourceDefinitionUtil</code>
which will output the full resource definition to
<code>target/standalone-resource-definition-running.dmr</code></p>
</li>
<li>
<p>Stop the running version of WildFly/JBoss AS 7</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="see-what-changed"><a class="anchor" href="#see-what-changed"></a>4.4.2. See what changed</h4>
<div class="paragraph">
<p>To do this follow the following steps</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start the <strong>new</strong> version of WildFly using
<code>--server-config=standalone-full-ha.xml</code></p>
</li>
<li>
<p>Run <code>org.wildfly.legacy.util.CompareModelVersionsUtil</code> and answer
the following questions"</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Enter Legacy AS version:</p>
<div class="ulist">
<ul>
<li>
<p>If it is known version in the <code>tools/src/test/resources/legacy-models</code>
folder, enter the version number.</p>
</li>
<li>
<p>If it is a not known version, and you got the data yourself in the
last step, enter ' `running&#8217;</p>
</li>
</ul>
</div>
</li>
<li>
<p>Enter type:</p>
<div class="ulist">
<ul>
<li>
<p>Answer ' `S&#8217;</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Read from target directory or from the legacy-models directory:</p>
<div class="ulist">
<ul>
<li>
<p>If it is known version in the
<code>controller/src/test/resources/legacy-models</code> folder, enter ' `l&#8217;.</p>
</li>
<li>
<p>If it is a not known version, and you got the data yourself in the
last step, enter ' `t&#8217;</p>
</li>
</ul>
</div>
</li>
<li>
<p>Report on differences in the model when the management versions are
different?:</p>
<div class="ulist">
<ul>
<li>
<p>Answer ' `y&#8217;</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here is some example output, as a subsystem developer you can ignore
everything down to <code>======= Comparing subsystem models ======</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>Enter legacy AS version: 7.2.0.Final
Using target model: 7.2.0.Final
Enter type [S](standalone)/H(host)/D(domain)/F(domain + host):S
Read from target directory or from the legacy-models directory - t/[l]:
Report on differences in the model when the management versions are different? y/[n]: y
Reporting on differences in the model when the management versions are different
Loading legacy model versions for 7.2.0.Final....
Loaded legacy model versions
Loading model versions for currently running server...
Oct 01, 2013 6:26:03 PM org.xnio.Xnio &lt;clinit&gt;
INFO: XNIO version 3.1.0.CR7
Oct 01, 2013 6:26:03 PM org.xnio.nio.NioXnio &lt;clinit&gt;
INFO: XNIO NIO Implementation Version 3.1.0.CR7
Oct 01, 2013 6:26:03 PM org.jboss.remoting3.EndpointImpl &lt;clinit&gt;
INFO: JBoss Remoting version 4.0.0.Beta1
Loaded current model versions
Loading legacy resource descriptions for 7.2.0.Final....
Loaded legacy resource descriptions
Loading resource descriptions for currently running STANDALONE...
Loaded current resource descriptions
Starting comparison of the current....
 
======= Comparing core models ======
-- SNIP --
 
======= Comparing subsystem models ======
-- SNIP --
======= Resource root address: [&quot;subsystem&quot; =&gt; &quot;remoting&quot;] - Current version: 2.0.0; legacy version: 1.2.0 =======
--- Problems for relative address to root []:
Missing child types in current: []; missing in legacy [http-connector]
--- Problems for relative address to root [&quot;remote-outbound-connection&quot; =&gt; &quot;*&quot;]:
Missing attributes in current: []; missing in legacy [protocol]
Missing parameters for operation 'add' in current: []; missing in legacy [protocol]
-- SNIP --
======= Resource root address: [&quot;subsystem&quot; =&gt; &quot;weld&quot;] - Current version: 2.0.0; legacy version: 1.0.0 =======
--- Problems for relative address to root []:
Missing attributes in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]
Missing parameters for operation 'add' in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]
 
Done comparison of STANDALONE!</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we can see that for the <code>remoting</code> subsystem, we have added a child
type called <code>http-connector</code>, and we have added an attribute called
<code>protocol</code> (they are missing in legacy).<br>
in the <code>weld</code> subsystem, we have added the <code>require-bean-descriptor</code> and
<code>non-portable-mode</code> attributes in the current version. It will also
point out other issues like changed attribute types, changed defaults
etc.</p>
</div>
<div class="paragraph">
<p>Warning</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Note that CompareModelVersionsUtil simply inspects the raw resource
descriptions of the specified legacy and current models. Its results
show the differences between the two. They do not take into account
whether one or more transformers have already been written for those
versions differences. You will need to check that transformers are not
already in place for those versions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One final point to consider are that some subsystems register
runtime-only resources and operations. For example the <code>modcluster</code>
subsystem has a <code>stop</code> method. These do not get registered on the <code>DC</code>,
e.g. there is no <code>/profile=full-ha/subsystem=modcluster:stop</code> operation,
it only exists on the servers, for example
<code>/host=xxx/server=server-one/subsystem=modcluster:stop</code>. What this means
is that you don&#8217;t have to transform such operations and resources. The
reason is they are not callable on the DC, and so do not need
propagation to the servers in the domain, which in turn means no
transformation is needed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="how-do-i-write-a-transformer"><a class="anchor" href="#how-do-i-write-a-transformer"></a>4.5. How do I write a transformer?</h3>
<div class="paragraph">
<p>There are two APIs available to write transformers for a resource. There
is the original low-level API where you register transformers directly,
the general idea is that you get hold of a <code>TransformersSubRegistration</code>
for each level and implement the <code>ResourceTransformer</code>,
<code>OperationTransformer</code> and <code>PathAddressTransformer</code> interfaces directly.
It is, however, a pretty complex thing to do, so we recommend the other
approach. For completeness here is the entry point to handling
transformation in this way.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SomeExtension</span> <span class="directive">implements</span> Extension {
<span class="error"> </span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SUBSYSTEM_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">my-subsystem</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">'</span><span class="content">
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }
 
    static void registerTransformers(final SubsystemRegistration subsystem) {
        registerTransformers_1_1_0(subsystem);
        registerTransformers_1_2_0(subsystem);
    }
 
    /**
     * Registers transformers from the current version to ModelVersion 1.1.0
     */
    private static void registerTransformers_1_1_0(final SubsystemRegistration subsystem) {
        final ModelVersion version = ModelVersion.create(1, 1, 0);
 
        //The default resource transformer forwards all operations
        final TransformersSubRegistration registration = subsystem.registerModelTransformers(version, ResourceTransformer.DEFAULT);
        final TransformersSubRegistration child = registration.registerSubResource(PathElement.pathElement(&quot;child&quot;));
        //We can do more things on the TransformersSubRegistation instances
 
 
        registerRelayTransformers(stack);
    }</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Having implemented a number of transformers using the above approach, we
decided to simplify things, so we introduced the
<code>org.jboss.as.controller.transform.description.ResourceTransformationDescriptionBuilder</code>
API. It is a lot simpler and avoids a lot of the duplication of
functionality required by the low-level API approach. While it doesn&#8217;t
give you the full power that the low-level API does, we found that there
are very few places in the WildFly codebase where this does not work, so
we will focus on the <code>ResourceTransformationDescriptionBuilder</code> API
here. (If you come across a problem where this does not work, get in
touch with someone from the WildFly Domain Management Team and we should
be able to help). The builder API makes all the nasty calls to
<code>TransformersSubRegistration</code> for you under the hood. It also allows you
to fall back to the low-level API in places, although that will not be
covered in the current version of this guide. The entry point for using
the builder API here is taken from the WeldExtension (in current WildFly
this has ModelVersion 2.0.0).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> <span class="type">void</span> registerTransformers(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        <span class="comment">//These new attributes are assumed to be 'true' in the old version but default to false in the current version. So discard if 'true' and reject if 'undefined'.</span>
        builder.getAttributeBuilder()
                .setDiscard(<span class="keyword">new</span> DiscardAttributeChecker.DiscardAttributeValueChecker(<span class="predefined-constant">false</span>, <span class="predefined-constant">false</span>, <span class="keyword">new</span> ModelNode(<span class="predefined-constant">true</span>)),
                        WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .addRejectCheck(<span class="keyword">new</span> RejectAttributeChecker.DefaultRejectAttributeChecker() {
<span class="error"> </span>
                    <span class="annotation">@Override</span>
                    <span class="directive">public</span> <span class="predefined-type">String</span> getRejectionLogMessage(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, ModelNode&gt; attributes) {
                        <span class="keyword">return</span> WeldMessages.MESSAGES.rejectAttributesMustBeTrue(attributes.keySet());
                    }
<span class="error"> </span>
                    <span class="annotation">@Override</span>
                    <span class="directive">protected</span> <span class="type">boolean</span> rejectAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue,
                            TransformationContext context) {
                        <span class="comment">//This will not get called if it was discarded, so reject if it is undefined (default==false) or if defined and != 'true'</span>
                        <span class="keyword">return</span> !attributeValue.isDefined() || !attributeValue.asString().equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>);
                    }
                }, WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we register a <code>discard check</code> and a <code>reject check</code>. As mentioned in
<a href="#attribute-transformation-lifecycle">#Attribute
transformation lifecycle</a> all attributes are inspected for whether they
should be discarded first. Then all attributes which were not discarded
are checked for if they should be rejected. We will dig more into what
this code means in the next few sections, but in short it means that we
discard the <code>require-bean-descriptor</code> and <code>non-portable</code> attributes on
the <code>weld</code> subsystem resource if they have the value <code>true</code>. If they
have any other value, they will not get discarded and so reach the
reject check, which will reject the transformation of the attributes if
they have any other value.</p>
</div>
<div class="paragraph">
<p>Here we are saying that we should discard the <code>require-bean-descriptor</code>
and <code>non-portable-mode</code> attributes on the <code>weld</code> subsystem resource if
they are undefined, and reject them if they are defined. So that means
that if the weld subsystem looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    {
        <span class="string"><span class="delimiter">&quot;</span><span class="content">non-portable-mode</span><span class="delimiter">&quot;</span></span> =&gt; <span class="predefined-constant">false</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">require-bean-descriptor</span><span class="delimiter">&quot;</span></span> =&gt; <span class="predefined-constant">false</span>
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    {
        <span class="string"><span class="delimiter">&quot;</span><span class="content">non-portable-mode</span><span class="delimiter">&quot;</span></span> =&gt; undefined,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">require-bean-descriptor</span><span class="delimiter">&quot;</span></span> =&gt; undefined
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>or any other combination (the default values for these attributes if
undefined is <code>false</code>) we will reject the transformation for the secondary
legacy HC.</p>
</div>
<div class="paragraph">
<p>If the resource has true for these attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    {
        <span class="string"><span class="delimiter">&quot;</span><span class="content">non-portable-mode</span><span class="delimiter">&quot;</span></span> =&gt; <span class="predefined-constant">true</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">require-bean-descriptor</span><span class="delimiter">&quot;</span></span> =&gt; <span class="predefined-constant">true</span>
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>they both get discarded (i.e. removed), so they will not get inspected
for rejection, and an empty model not containing these attributes gets
sent to the legacy HC.</p>
</div>
<div class="paragraph">
<p>Here we will discuss this API a bit more, to outline the most important
features/most commonly needed tasks.</p>
</div>
<div class="sect3">
<h4 id="resourcetransformationdescriptionbuilder"><a class="anchor" href="#resourcetransformationdescriptionbuilder"></a>4.5.1. ResourceTransformationDescriptionBuilder</h4>
<div class="paragraph">
<p>The <code>ResourceTransformationDescriptionBuilder</code> contains transformations
for a resource type. The initial one is for the subsystem, obtained by
the following call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        ResourceTransformationDescriptionBuilder subsystemBuilder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ResourceTransformationDescriptionBuilder</code> contains functionality
for how to handle child resources, which we will look at in this
section. It is also the entry point to how to handle transformation of
attributes as we will see in
<a href="#attributetransformationdescriptionbuilder">#AttributeTransformationDescriptionBuilder</a>.
Also, it allows you to further override operation transformation as
discussed in
<a href="#operationtransformationoverridebuilder">#OperationTransformationOverrideBuilder</a>.
When we have finished with our builder, we register it with the
<code>SubsystemRegistration</code> against the target ModelVersion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        TransformationDescription.Tools.register(subsystemBuilder.build(), subsystem, ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you have several old ModelVersions you could be transforming to, you
need a separate builder for each of those.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="silently-discard-child-resources"><a class="anchor" href="#silently-discard-child-resources"></a>Silently discard child resources</h5>
<div class="paragraph">
<p>To make the <code>ResourceTransformationDescriptionBuilder</code> do something, we
need to call some of its methods. For example, if we want to silently
discard a child resource, we can do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    subsystemBuilder.discardChildResource(PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">child</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">discarded</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that any usage of <code>/subsystem=my-subsystem/child=discarded</code>
never make it to the legacy secondary HC running ModelVersion 1.0.0. During
the initial domain model transfer, that part of the serialized domain
model is stripped out, and any operations on this address are not
forwarded on to the legacy secondary HCs running that version of the
subsystem. (For brevity this section will leave out the leading
<code>/profile=xxx</code> part used in domain mode, and use
<code>/subsystem=my-subsystem</code> as the 'top-level' address).</p>
</div>
<div class="paragraph">
<p>Warning</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Note that discarding, although the simplest option in theory, is <strong>rarely
the right thing to do</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The presence of the defined child normally implies some behaviour on the
DC, and that behaviour is not available on the legacy secondary HC, so
normally rejection is a better policy for those cases. Remember we can
have different profiles targeting different groups of versions of legacy
secondary HCs.</p>
</div>
</div>
<div class="sect4">
<h5 id="reject-child-resource"><a class="anchor" href="#reject-child-resource"></a>Reject child resource</h5>
<div class="paragraph">
<p>If we want to reject transformation if a child resource exists, we can
do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    subsystemBuilder.rejectChildResource(PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">child</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">reject</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, if there are any legacy secondary HCs running ModelVersion 1.0.0, any
usage of <code>/subsystem=my-subsystem/child=reject</code> will get rejected for
those secondary HCs. Both during the initial domain model transfer, and if any
operations are invoked on that address. For example the <code>remoting</code>
subsystem did not have a <code>http-connector=*</code> child until ModelVersion
2.0.0, so it is set up to reject that child when transforming to legacy
HCs for all previous ModelVersions (1.1.0, 1.2.0 and 1.3.0). (See
<a href="#rejection-in-resource-transformers">#Rejection
in resource transformers</a> and
<a href="#rejection-in-operation-transformers">#Rejection
in operation transformers</a> for exactly what happens when something is
rejected).</p>
</div>
</div>
<div class="sect4">
<h5 id="redirect-address-for-child-resource"><a class="anchor" href="#redirect-address-for-child-resource"></a>Redirect address for child resource</h5>
<div class="paragraph">
<p>Sometimes we rename the addresses for a child resource between model
versions. To do that we use one of the <code>addChildRedirection()</code> methods,
note that these also return a builder for the child resource (since we
are not rejecting or discarding it), we can do this for all children of
a given type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    ResourceTransformationDescriptionBuilder childBuilder =
       subsystemBuilder.addChildRedirection(PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">newChild</span><span class="delimiter">&quot;</span></span>), PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">oldChild</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, in the initial domain transfer
<code>/subsystem=my-subsystem/newChild=test</code> becomes
<code>/subsystem=my-subsystem/oldChild=test</code>. Similarly all operations
against the former address get mapped to the latter when executing
operations on the DC before sending them to the legacy secondary HC running
ModelVersion 1.1.0 of the subsystem.</p>
</div>
<div class="paragraph">
<p>We can also rename a specific named child:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    ResourceTransformationDescriptionBuilder childBuilder =
       subsystemBuilder.addChildRedirection(PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">newChild</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">newName</span><span class="delimiter">&quot;</span></span>), PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">oldChild</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">oldName</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, <code>/subsystem=my-subsystem/newChild=newName</code> becomes
<code>/subsystem=my-subsystem/oldChild=oldName</code> both in the initial domain
transfer, and when mapping operations to the legacy secondary HC. For example,
under the <code>web</code> subsystem <code>ssl=configuration</code> got renamed to
<code>configuration=ssl</code> in later versions, meaning we need a redirect from
<code>configuration=ssl</code> to <code>ssl=configuration</code> in its transformers.</p>
</div>
</div>
<div class="sect4">
<h5 id="getting-a-child-resource-builder"><a class="anchor" href="#getting-a-child-resource-builder"></a>Getting a child resource builder</h5>
<div class="paragraph">
<p>Sometimes we don&#8217;t want to transform the subsystem resource, but we want
to transform something in one of its child resources. Again, since we
are not discarding or rejecting, we get a reference to the builder for
the child resource.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    ResourceTransformationDescriptionBuilder childBuilder =
       subsystemBuilder.addChildResource(PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">some-child</span><span class="delimiter">&quot;</span></span>));
    <span class="comment">//We don't actually want to transform anything in /subsystem-my-subsystem/some-child=* either :-)</span>
    <span class="comment">//We are interested in /subsystem-my-subsystem/some-child=*/another-level</span>
    ResourceTransformationDescriptionBuilder anotherBuilder =
       childBuilder.addChildResource(PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">another-level</span><span class="delimiter">&quot;</span></span>));
<span class="error"> </span>
    <span class="comment">//Use anotherBuilder to add child-resource and/or attribute transformation</span>
    ....</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="attributetransformationdescriptionbuilder"><a class="anchor" href="#attributetransformationdescriptionbuilder"></a>4.5.2. AttributeTransformationDescriptionBuilder</h4>
<div class="paragraph">
<p>To transform attributes you call
<code>ResourceTransformationDescriptionBuilder.getAttributeBuilder()</code> which
returns you a <code>AttributeTransformationDescriptionBuilder</code> which is used
to define transformation for the resource&#8217;s attributes. For example this
gets the attribute builder for the subsystem resource:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    AttributeTransformationDescriptionBuilder attributeBuilder = subSystemBuilder.getAttributeBuilder();</code></pre>
</div>
</div>
<div class="paragraph">
<p>or we could get it for one of the child resources:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    ResourceTransformationDescriptionBuilder childBuilder =
       subsystemBuilder.addChildResource(PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">some-child</span><span class="delimiter">&quot;</span></span>));
    AttributeTransformationDescriptionBuilder attributeBuilder = childBuilder.getAttributeBuilder();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attribute transformations defined by the
<code>AttributeTransformationDescriptionBuilder</code> will also impact the
parameters to all operations defined on the resource. This means that if
you have defined the <code>example</code> attribute of
<code>/subsystem=my-subsystem/some-child=*</code> to reject transformation if its
value is <code>true</code>, the inital domain transfer will reject if it is <code>true</code>,
also the transformation of the following operations will reject:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>    /subsystem=my-subsystem/some-child=test:add(example=true)
    /subsystem=my-subsystem:write-attribute(name=example, value=true)
    /subsystem=my-subsystem:custom-operation(example=true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following operations will pass in this example, since the <code>example</code>
attribute is not getting set to <code>true</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>    /subsystem=my-subsystem/some-child=test:add(example=false)
    /subsystem=my-subsystem/some-child=test:add()             //Here it 'example' is simply left undefined
    /subsystem=my-subsystem:write-attribute(name=example, value=false)
    /subsystem=my-subsystem:undefine-attribute(name=example)  //Again this makes 'example' undefined
    /subsystem=my-subsystem:custom-operation(example=false)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the rest of the examples in this section we assume that the
<code>attributeBuilder</code> is for <code>/subsystem=my-subsystem</code></p>
</div>
<div class="sect4">
<h5 id="attribute-transformation-lifecycle"><a class="anchor" href="#attribute-transformation-lifecycle"></a>Attribute transformation lifecycle</h5>
<div class="paragraph">
<p>There is a well defined lifecycle used for attribute transformation that
is worth explaining before jumping into specifics. Transformation is
done in the following phases, in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>discard</code> - All attributes in the domain model transfer or invoked
operation that have been registered for a discard check, are checked to
see if the attribute should be discarded. If an attribute should be
discarded, it is removed from the resource&#8217;s attributes/operation&#8217;s
parameters and it does not get passed to the next phases. Once discarded
it does not get sent to the legacy secondary HC.</p>
</li>
<li>
<p><code>reject</code> - All attributes that have been registered for a reject
check (and which not have been discarded) are checked to see if the
attribute should be rejected. As explained in
<a href="#rejection-in-resource-transformers">#Rejection
in resource transformers</a> and
<a href="#rejection-in-operation-transformers">#Rejection
in operation transformers</a> exactly what happens when something is
rejected varies depending on whether we are transforming a resource or
an operation, and the version of the legacy secondary HC we are transforming
for. If a transformer rejects an attribute, all other reject
transformers still get invoked, and the next phases also get invoked.
This is because we don&#8217;t know in all cases what will happen if a reject
happens. Although this might sound cumbersome, in practice it actually
makes it easier to write transformers since you only need one kind
regardless of if it is a resource, an operation, and legacy secondary HC
version. However, as we will see in
<a href="#common-transformation-use-cases">Common
transformation use-cases</a>, it means some extra checks are needed when
writing reject and convert transformers.</p>
</li>
<li>
<p><code>convert</code> - All attributes that have been registered for conversion
are checked to see if the attribute should be converted. If the
attribute does not exist in the original operation/resource it may be
introduced. This is useful for setting default values for the target
legacy secondary HC.</p>
</li>
<li>
<p><code>rename</code> - All attributes registered for renaming are renamed.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next, let us have a look at how to register attributes for each of these
phases.</p>
</div>
</div>
<div class="sect4">
<h5 id="discarding-attributes"><a class="anchor" href="#discarding-attributes"></a>Discarding attributes</h5>
<div class="paragraph">
<p>The general idea behind a discard is that we remove attributes which do
not exist in the legacy secondary HC&#8217;s model. However, as hopefully
described below, we normally can&#8217;t simply discard everything, we need to
check the values first.</p>
</div>
<div class="paragraph">
<p>To discard an attribute we need an instance of
<code>org.jboss.as.controller.transform.description.DiscardAttributeChecker</code>,
and call the following method on the
<code>AttributeTransformationDescriptionBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     DiscardAttributeChecker discardCheckerA = ....;
     attributeBuilder.setDiscard(discardCheckerA, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr2</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown, you can register the <code>DiscardAttributeChecker</code> for several
attributes at once, in the above example both <code>attr1</code> and <code>attr2</code> get
checked for if they should be discarded. You can also register different
<code>DiscardAttributeChecker</code> instances for different attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     DiscardAttributeChecker discardCheckerA = ....;
     DiscardAttributeChecker discardCheckerB = ....;
     attributeBuilder.setDiscard(discardCheckerA, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>);
     attributeBuilder.setDiscard(discardCheckerA, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr2</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can only have one <code>DiscardAttributeChecker</code> per attribute,
so the following would cause an error (if running with assertions
enabled, otherwise <code>discardCheckerB</code> will overwrite <code>discardCheckerA</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     DiscardAttributeChecker discardCheckerA = ....;
     DiscardAttributeChecker discardCheckerB = ....;
     attributeBuilder.setDiscard(discardCheckerA, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>);
     attributeBuilder.setDiscard(discardCheckerB, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="the-discardattributechecker-interface"><a class="anchor" href="#the-discardattributechecker-interface"></a>The DiscardAttributeChecker interface</h6>
<div class="paragraph">
<p><code>org.jboss.as.controller.transform.description.DiscardAttributeChecker</code>
contains both the <code>DiscardAttributeChecker</code> and some helper
implementations. The implementations of this interface get called for
each attribute they are registered against. The interface itself is
quite simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">DiscardAttributeChecker</span> {
<span class="error"> </span>
    <span class="comment">/**
     * Returns {@code true} if the attribute should be discarded if expressions are used
     *
     * @return whether to discard if expressions are used
     */</span>
    <span class="type">boolean</span> isDiscardExpressions();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> here to discard the attribute if it is an expression. If
it is an expression, and this method returns <code>true</code>, the
<code>isOperationParameterDiscardable</code> and <code>isResourceAttributeDiscardable</code>
methods will not get called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="comment">/**
     * Returns {@code true} if the attribute should be discarded if it is undefined
     *
     * @return whether to discard if the attribute is undefined
     */</span>
    <span class="type">boolean</span> isDiscardUndefined();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> here to discard the attribute if it is <code>undefined</code>. If it
is <code>undefined</code>, and this method returns <code>true</code>, the
<code>isDiscardExpressions</code>, <code>isOperationParameterDiscardable</code> and
<code>isResourceAttributeDiscardable</code> methods will not get called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="comment">/**
     * Gets whether the given operation parameter can be discarded
     *
     * @param address the address of the operation
     * @param attributeName the name of the operation parameter.
     * @param attributeValue the value of the operation parameter.
     * @param operation the operation executed. This is unmodifiable.
     * @param context the context of the transformation
     *
     * @return {@code true} if the operation parameter value should be discarded, {@code false} otherwise.
     */</span>
    <span class="type">boolean</span> isOperationParameterDiscardable(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming an operation, this method gets called for each
operation parameter. We have access to the address of the operation, the
name and value of the operation parameter, an unmodifiable copy of the
original operation and the <code>TransformationContext</code>. The
<code>TransformationContext</code> allows you access to the original resource the
operation is working on before any transformation happened, which is
useful if you want to check other values in the resource if this is, say
a <code>write-attribute</code> operation. Return <code>true</code> to discard the operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="comment">/**
     * Gets whether the given attribute can be discarded
     *
     * @param address the address of the resource
     * @param attributeName the name of the attribute
     * @param attributeValue the value of the attribute
     * @param context the context of the transformation
     *
     * @return {@code true} if the attribute value should be discarded, {@code false} otherwise.
     */</span>
    <span class="type">boolean</span> isResourceAttributeDiscardable(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming a resource, this method gets called for each
attribute in the resource. We have access to the address of the
resource, the name and value of the attribute, and the
<code>TransformationContext</code>. Return <code>true</code> to discard the operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="discardattributechecker-helper-classesimplementations"><a class="anchor" href="#discardattributechecker-helper-classesimplementations"></a>DiscardAttributeChecker helper classes/implementations</h6>
<div class="paragraph">
<p><code>DiscardAttributeChecker</code> contains a few helper implementations for the
most common cases to save you writing the same stuff again and again.</p>
</div>
<div class="sect6">
<h7 id="discardattributechecker.defaultdiscardattributechecker"><a class="anchor" href="#discardattributechecker.defaultdiscardattributechecker"></a>DiscardAttributeChecker.DefaultDiscardAttributeChecker</h7>
<div class="paragraph">
<p><code>DiscardAttributeChecker.DefaultDiscardAttributeChecker</code> is an abstract
convenience class. In most cases you don&#8217;t need a separate check for if
an operation or a resource is being transformed, so it makes both the
<code>isResourceAttributeDiscardable()</code> and
<code>isOperationParameterDiscardable()</code> methods call the following method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">boolean</span> isValueDiscardable(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>All you lose, in the case of an operation transformation, is the name of
the transformed operation. The constructor of
<code>DiscardAttributeChecker.DefaultDiscardAttributeChecker</code> also allows you
to define values for <code>isDiscardExpressions()</code> and
<code>isDiscardUndefined()</code>.</p>
</div>
</div>
<div class="sect6">
<h7 id="discardattributechecker.discardattributevaluechecker"><a class="anchor" href="#discardattributechecker.discardattributevaluechecker"></a>DiscardAttributeChecker.DiscardAttributeValueChecker</h7>
<div class="paragraph">
<p>This is another convenience class, which allows you to discard an
attribute if it has one or more values. Here is a real-world example
from the <code>jpa</code> subsystem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> <span class="type">void</span> initializeTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .setDiscard(
                   <span class="keyword">new</span> DiscardAttributeChecker.DiscardAttributeValueChecker(<span class="keyword">new</span> ModelNode(ExtendedPersistenceInheritance.DEEP.toString())),
                   JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .addRejectCheck(RejectAttributeChecker.DEFINED, JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(<span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">0</span>));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will come back to the reject checks in the
<a href="#rejecting-attributes">#Rejecting
attributes</a> section. We are saying that we should discard the
<code>JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</code> attribute if it
has the value <code>deep</code>. The reasoning here is that this attribute did not
exist in the old model, but the legacy secondary HCs <em>implied behaviour</em> is
that this was <code>deep</code>. In the current version we added the possibility to
toggle this setting, but only <code>deep</code> is consistent with what is
available in the legacy secondary HC. In this case we are using the
constructor for <code>DiscardAttributeChecker.DiscardAttributeValueChecker</code>
which says don&#8217;t discard if it uses expressions, and discard if it is
<code>undefined</code>. If it is <code>undefined</code> in the current model, looking at the
default value of
<code>JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</code>, it is <code>deep</code>,
so a discard is in line with the implied legacy behaviour. If an
expression is used, we cannot discard since we have no idea what the
expression will resolve to on the secondary HC.</p>
</div>
</div>
<div class="sect6">
<h7 id="discardattributechecker.always"><a class="anchor" href="#discardattributechecker.always"></a>DiscardAttributeChecker.ALWAYS</h7>
<div class="paragraph">
<p><code>DiscardAttributeChecker.ALWAYS</code> will always discard an attribute. Use
this sparingly, since normally the presence of an attribute in the
current model implies some behaviour should be turned on, and if that
does not exist in the legacy model it implies that that behaviour does
not exist in the legacy secondary HC and its servers. Normally the legacy
secondary HC&#8217;s subsystem has some implied behaviour which is better checked
for by using a <code>DiscardAttributeChecker.DiscardAttributeValueChecker</code>.
One valid use for <code>DiscardAttributeChecker.ALWAYS</code> can be found in the
<code>ejb3</code> subsystem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> registerTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance()
                .getAttributeBuilder()
                 ...
                <span class="comment">// We can always discard this attribute, because it's meaningless without the security-manager subsystem, and</span>
                <span class="comment">// a legacy secondary HC can't have that subsystem in its profile.</span>
                .setDiscard(DiscardAttributeChecker.ALWAYS, EJB3SubsystemRootResourceDefinition.DISABLE_DEFAULT_EJB_PERMISSIONS)
   ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the comment says, this attribute only makes sense with the
security-manager susbsystem, which does not exist on legacy secondary HCs
running ModelVersion 1.1.0 of the <code>ejb3</code> subsystem.</p>
</div>
</div>
<div class="sect6">
<h7 id="discardattributechecker.undefined"><a class="anchor" href="#discardattributechecker.undefined"></a>DiscardAttributeChecker.UNDEFINED</h7>
<div class="paragraph">
<p><code>DiscardAttributeChecker.UNDEFINED</code> will discard an attribute if it is
<code>undefined</code>. This is normally safer than
<code>DiscardAttributeChecker.ALWAYS</code> since the attribute is not set in the
current model, we don&#8217;t need to send it to the legacy model. However,
you should check that this attribute not existing in the legacy secondary
HC, implies the same functionality as being undefined in the current DC.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rejecting-attributes"><a class="anchor" href="#rejecting-attributes"></a>Rejecting attributes</h5>
<div class="paragraph">
<p>The next step is to check attributes and values which we know for sure
will not work on the target legacy secondary HC.</p>
</div>
<div class="paragraph">
<p>To reject an attribute we need an instance of
<code>org.jboss.as.controller.transform.description.RejectAttributeChecker</code>,
and call the following method on the
<code>AttributeTransformationDescriptionBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     RejectAttributeChecker rejectCheckerA = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr2</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown you can register the <code>RejectAttributeChecker</code> for several
attributes at once, in the above example both <code>attr1</code> and <code>attr2</code> get
checked for if they should be discarded. You can also register different
<code>RejectAttributeChecker</code> instances for different attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     RejectAttributeChecker rejectCheckerA = ....;
     RejectAttributeChecker rejectCheckerB = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>);
     attributeBuilder.addRejectCheck(rejectCheckerB, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr2</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register several <code>RejectAttributeChecker</code> instances per
attribute</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     RejectAttributeChecker rejectCheckerA = ....;
     RejectAttributeChecker rejectCheckerB = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>);
     attributeBuilder.addRejectCheck(rejectCheckerB, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1, </span><span class="delimiter">&quot;</span></span>attr2<span class="string"><span class="delimiter">&quot;</span><span class="content">);</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case <code>attr1</code> gets both <code>rejectCheckerA</code> and <code>rejectCheckerB</code>.
For attributes with several <code>RejectAttributeChecker</code> registered, they
get processed in the order that they have been added. So when checking
<code>attr1</code> for rejection, <code>rejectCheckerA</code> gets run before
<code>rejectCheckerB</code>. As mentioned in
<a href="#attribute-transformation-lifecycle">#Attribute
transformation lifecycle</a>, if an attribute is rejected, we still invoke
the rest of the reject checkers.</p>
</div>
<div class="sect5">
<h6 id="the-rejectattributechecker-interface"><a class="anchor" href="#the-rejectattributechecker-interface"></a>The RejectAttributeChecker interface</h6>
<div class="paragraph">
<p><code>org.jboss.as.controller.transform.description.RejectAttributeChecker</code>
contains both the <code>RejectAttributeChecker</code> and some helper
implementations. The implementations of this interface get called for
each attribute they are registered against. The interface itself is
quite simple, and its main methods are similar to
<code>DiscardAttributeChecker</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">RejectAttributeChecker</span> {
    <span class="comment">/**
     * Determines whether the given operation parameter value is not understandable by the target process and needs
     * to be rejected.
     *
     * @param address        the address of the operation
     * @param attributeName  the name of the attribute
     * @param attributeValue the value of the attribute
     * @param operation      the operation executed. This is unmodifiable.
     * @param context        the context of the transformation
     * @return {@code true} if the parameter value is not understandable by the target process and so needs to be rejected, {@code false} otherwise.
     */</span>
    <span class="type">boolean</span> rejectOperationParameter(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming an operation, this method gets called for each
operation parameter. We have access to the address of the operation, the
name and value of the operation parameter, an unmodifiable copy of the
original operation and the <code>TransformationContext</code>. The
<code>TransformationContext</code> allows you access to the original resource the
operation is working on before any transformation happened, which is
useful if you want to check other values in the resource if this is, say
a <code>write-attribute</code> operation. Return <code>true</code> to reject the operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="comment">/**
     * Gets whether the given resource attribute value is not understandable by the target process and needs
     * to be rejected.
     *
     * @param address        the address of the resource
     * @param attributeName  the name of the attribute
     * @param attributeValue the value of the attribute
     * @param context        the context of the transformation
     * @return {@code true} if the attribute value is not understandable by the target process and so needs to be rejected, {@code false} otherwise.
     */</span>
    <span class="type">boolean</span> rejectResourceAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming a resource, this method gets called for each
attribute in the resource. We have access to the address of the
resource, the name and value of the attribute, and the
<code>TransformationContext</code>. Return <code>true</code> to discard the operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="comment">/**
     * Returns the log message id used by this checker. This is used to group it so that all attributes failing a type of rejection
     * end up in the same error message
     *
     * @return the log message id
     */</span>
    <span class="predefined-type">String</span> getRejectionLogMessageId();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we need a unique id for the log message from the
<code>RejectAttributeChecker</code>. It is used to group rejected attributes by
their log message. A typical implementation will contain \{\{return
getRejectionLogMessage(Collections.&lt;String, ModelNode&gt;emptyMap());}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="comment">/**
     * Gets the log message if the attribute failed rejection
     *
     * @param attributes a map of all attributes failed in this checker and their values
     * @return the formatted log message
     */</span>
    <span class="predefined-type">String</span> getRejectionLogMessage(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, ModelNode&gt; attributes);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we return a message saying why the attributes were rejected, with
the possibility to format the message to include the names of all the
rejected attributes and the values they had.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="rejectattributechecker-helper-classesimplementations"><a class="anchor" href="#rejectattributechecker-helper-classesimplementations"></a>RejectAttributeChecker helper classes/implementations</h6>
<div class="paragraph">
<p><code>RejectAttributeChecker</code> contains a few helper classes for the most
common scenarios to save you from writing the same stuff again and
again.</p>
</div>
<div class="sect6">
<h7 id="rejectattributechecker.defaultrejectattributechecker"><a class="anchor" href="#rejectattributechecker.defaultrejectattributechecker"></a>RejectAttributeChecker.DefaultRejectAttributeChecker</h7>
<div class="paragraph">
<p><code>RejectAttributeChecker.DefaultRejectAttributeChecker</code> is an abstract
convenience class. In most cases you don&#8217;t need a separate check for if
an operation or a resource is being transformed, so it makes both the
<code>rejectOperationParameter()</code> and <code>rejectResourceAttribute()</code> methods
call the following method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">boolean</span> rejectAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>DefaultDiscardAttributeChecker</code>, all you loose is the name of the
transformed operation, in the case of operation transformation.</p>
</div>
</div>
<div class="sect6">
<h7 id="rejectattributechecker.defined"><a class="anchor" href="#rejectattributechecker.defined"></a>RejectAttributeChecker.DEFINED</h7>
<div class="paragraph">
<p><code>RejectAttributeChecker.DEFINED</code> is used to reject any attribute that
has a defined value. Normally this is because the attribute does not
exist on the target legacy secondary HC. A typical use case for these is for
the <em>implied behavior</em> example we looked at in the <code>jpa</code> subsystem in
<a href="#discardattributechecker.discardattributevaluechecker">#DiscardAttributeChecker.DiscardAttributeValueChecker</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> <span class="type">void</span> initializeTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .setDiscard(
                   <span class="keyword">new</span> DiscardAttributeChecker.DiscardAttributeValueChecker(<span class="keyword">new</span> ModelNode(ExtendedPersistenceInheritance.DEEP.toString())),
                   JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .addRejectCheck(RejectAttributeChecker.DEFINED, JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(<span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">0</span>));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we discard the
<code>JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</code> value if it is
not an expression, and also has the value <code>deep</code>. Now if it was not
discarded, it would will still be defined so we reject it.</p>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Reject and discard often work in pairs.
</td>
</tr>
</table>
</div>
</div>
<div class="sect6">
<h7 id="rejectattributechecker.simple_expressions"><a class="anchor" href="#rejectattributechecker.simple_expressions"></a>RejectAttributeChecker.SIMPLE_EXPRESSIONS</h7>
<div class="paragraph">
<p><code>RejectAttributeChecker.SIMPLE_EXPRESSIONS</code> can be used to reject an
attribute that contains expressions. This was used a lot for
transformations to subsystems in JBoss AS 7.1.x, since we had not fully
realized the importance of where to support expressions until JBoss AS
7.2.0 was released, so a lot of attributes in earlier versions were
missing expressions support.</p>
</div>
</div>
<div class="sect6">
<h7 id="rejectattributechecker.listrejectattributechecker"><a class="anchor" href="#rejectattributechecker.listrejectattributechecker"></a>RejectAttributeChecker.ListRejectAttributeChecker</h7>
<div class="paragraph">
<p>The
<code>RejectAttributeChecker}}s we have seen so far work on simple attributes, i.e. where the attribute has a ModelType which is one of the primitives. We also have a {{RejectAttributeChecker.ListRejectAttributeChecker</code>
which allows you to define a checker for the elements of a list, when
the type of an attribute is <code>ModelType.LIST</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    attributeBuilder
            .addRejectCheck(<span class="keyword">new</span> ListRejectAttributeChecker(RejectAttributeChecker.EXPRESSIONS), <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <code>attr1</code> it will check each element of the list and run
<code>RejectAttributeChecker.EXPRESSIONS</code> to check that each element is not
an expression. You can of course pass in another kind of
<code>RejectAttributeChecker</code> to check the elements as well.</p>
</div>
</div>
<div class="sect6">
<h7 id="rejectattributechecker.objectfieldsrejectattributechecker"><a class="anchor" href="#rejectattributechecker.objectfieldsrejectattributechecker"></a>RejectAttributeChecker.ObjectFieldsRejectAttributeChecker</h7>
<div class="paragraph">
<p>For attributes where the type is <code>ModelType.OBJECT</code> we have
<code>RejectAttributeChecker.ObjectFieldsRejectAttributeChecker</code> which allows
you to register different reject checkers for the different fields of
the registered object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, RejectAttributeChecker&gt; fieldRejectCheckers = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;<span class="predefined-type">String</span>, RejectAttributeChecker&gt;();
    fieldRejectCheckers.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">time</span><span class="delimiter">&quot;</span></span>, RejectAttributeChecker.SIMPLE_EXPRESSIONS);
    fieldRejectCheckers.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">unit</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Lunar Month</span><span class="delimiter">&quot;</span></span>);
    attributeBuilder
            .addRejectCheck(<span class="keyword">new</span> ObjectFieldsRejectAttributeChecker(fieldRejectCheckers), <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if <code>attr1</code> is a complex type where
<code>attr1.get("time").getType() == ModelType.EXPRESSION</code> or
<code>attr1.get("unit").asString().equals("Lunar Month")</code> we reject the
attribute.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="converting-attributes"><a class="anchor" href="#converting-attributes"></a>Converting attributes</h5>
<div class="paragraph">
<p>To convert an attribute you register an
<code>org.jboss.as.controller.transform.description.AttributeConverter</code>
instance against the attributes you want to convert:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    AttributeConverter converterA = ...;
    AttributeConverter converterB = ...;
    attributeBuilder
            .setValueConverter(converterA, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr2</span><span class="delimiter">&quot;</span></span>);
    attributeBuilder
            .setValueConverter(converterB, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr3</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if <code>attr1</code> and <code>attr2</code> get converted with <code>converterA</code>, while
<code>attr3</code> gets converted with <code>converterB</code>.</p>
</div>
<div class="sect5">
<h6 id="the-attributeconverter-interface"><a class="anchor" href="#the-attributeconverter-interface"></a>The AttributeConverter interface</h6>
<div class="paragraph">
<p>The <code>AttributeConverter</code> interface gets called for each attribute for
which the <code>AttributeConverter</code> has been registered</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AttributeConverter</span> {
<span class="error"> </span>
    <span class="comment">/**
     * Converts an operation parameter
     *
     * @param address the address of the operation
     * @param attributeName the name of the operation parameter
     * @param attributeValue the value of the operation parameter to be converted
     * @param operation the operation executed. This is unmodifiable.
     * @param context the context of the transformation
     */</span>
    <span class="type">void</span> convertOperationParameter(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming an operation, this method gets called for each
operation parameter for which the con. We have access to the address of
the operation, the name and value of the operation parameter, an
unmodifiable copy of the original operation and the
<code>TransformationContext</code>. The <code>TransformationContext</code> allows you access
to the original resource the operation is working on before any
transformation happened, which is useful if you want to check other
values in the resource if this is, say a write-attribute operation. To
change the attribute value, you modify the <code>attributeValue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="comment">/**
     * Converts a resource attribute
     *
     * @param address the address of the operation
     * @param attributeName the name of the attribute
     * @param attributeValue the value of the attribute to be converted
     * @param context the context of the transformation
     */</span>
    <span class="type">void</span> convertResourceAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming a resource, this method gets called for each
attribute in the resource. We have access to the address of the
resource, the name and value of the attribute, and the
<code>TransformationContext</code>. To change the attribute value, you modify the
<code>attributeValue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A hypothetical example is if the current and legacy subsystems both
contain an attribute called <code>timeout</code>. In the legacy model this was
specified to be milliseconds, however in the current model it has been
changed to be seconds, hence we need to convert the value when sending
it to secondary HCs using the legacy model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     AttributeConverter secondsToMs = <span class="keyword">new</span> AttributeConverter.DefaultAttributeConverter() {
                  <span class="annotation">@Override</span>
                  <span class="directive">protected</span> <span class="type">void</span> convertAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue,
                           TransformationContext context) {
                      <span class="keyword">if</span> (attributeValue.isDefined()) {
                           <span class="type">int</span> seconds = attributeValue.asInt();
                           <span class="type">int</span> milliseconds = seconds * <span class="integer">1000</span>;
                           attributeValue.set(milliseconds);
                      }
                  }
          };
<span class="error"> </span>
     attributeBuilder.
          .setValueConverter(secondsToMs , <span class="string"><span class="delimiter">&quot;</span><span class="content">timeout</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We need to be a bit careful here. If the <code>timeout</code> attribute is an
expression our nice conversion will not work, so we need to add a reject
check to make sure it is not an expression as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     attributeBuilder.
          .addRejectCheck(SIMPLE_EXPRESSIONS, <span class="string"><span class="delimiter">&quot;</span><span class="content">timeout</span><span class="delimiter">&quot;</span></span>)
          .setValueConverter(secondsToMs , <span class="string"><span class="delimiter">&quot;</span><span class="content">timeout</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now it should be fine.</p>
</div>
<div class="paragraph">
<p><code>AttributeConverter.DefaultAttributeConverter</code> is is an abstract
convenience class. In most cases you don&#8217;t need a separate check for if
an operation or a resource is being transformed, so it makes both the
convertOperationParameter() and convertResourceAttribute() methods call
the following method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> convertAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>DefaultDiscardAttributeChecker</code> and
<code>DefaultRejectAttributeChecker</code>, all you loose is the name of the
transformed operation, in the case of operation transformation.</p>
</div>
<div class="sect6">
<h7 id="introducing-attributes-during-transformation"><a class="anchor" href="#introducing-attributes-during-transformation"></a>Introducing attributes during transformation</h7>
<div class="paragraph">
<p>Say both the current and the legacy models have an attribute called
<code>port</code>. In the legacy version this attribute had to be specified, and
the default xml configuration had <code>1234</code> for its value. In the current
version this attribute has been made optional with a default value of
<code>1234</code> so that it does not need to be specified. When transforming to a
secondary HC using the old version we will need to introduce this attribute
if the new model does not contain it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     attributeBuilder.
         setValueConverter(AttributeConverter.Factory.createHardCoded(<span class="keyword">new</span> ModelNode(<span class="integer">1234</span>) <span class="predefined-constant">true</span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">port</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>So what this factory method does is to create an implementation of
<code>AttributeConverter.DefaultAttributeConverter</code> where in
<code>convertAttribute()</code> we set <code>attributeValue</code> to have the value <code>1234</code> if
it is <code>undefined</code>. As long as <code>attributeValue</code> gets set in that method
it will get set in the model, regardless of if it existed already or
not.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="renaming-attributes"><a class="anchor" href="#renaming-attributes"></a>Renaming attributes</h5>
<div class="paragraph">
<p>To rename an attribute, you simply do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    attributeBuilder.addRename(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">legacy-name</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, in the initial domain transfer to the legacy secondary HC, we rename
<code>/subsystem=my-subsystem&#8217;s `my-name</code> attribute to <code>legacy-name</code>. Also,
the operations involving this attribute are affected, so</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code>    /subsystem=my-subsystem/:add(my-name=true)  -&gt;
         /subsystem=my-subsystem/:add(legacy-name=true)
    /subsystem=my-subsystem:write-attribute(name=my-name, value=true) -&gt;
         /subsystem=my-subsystem:write-attribute(name=legacy-name, value=true)
    /subsystem=my-subsystem:undefine-attribute(name=my-name) -&gt;
         /subsystem=my-subsystem:undefine-attribute(name=legacy-name)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="operationtransformationoverridebuilder"><a class="anchor" href="#operationtransformationoverridebuilder"></a>4.5.3. OperationTransformationOverrideBuilder</h4>
<div class="paragraph">
<p>All operations on a resource automatically get the same transformations
on their parameters as set up by the
<code>AttributeTransformationDescriptionBuilder</code>. In some cases you might
want to change this, so you can use the
<code>OperationTransformationOverrideBuilder</code>, which is got from:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride(<span class="string"><span class="delimiter">&quot;</span><span class="content">some-operation</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the operation will now no longer inherit the
attribute/operation parameter transformations, so they are effectively
turned off. In other cases you might want to include them by calling
<code>inheritResourceAttributeDefinitions()</code>, and to include some more checks
(the <code>OperationTransformationBuilder</code> interface has all the methods
found in <code>AttributeTransformationBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride(<span class="string"><span class="delimiter">&quot;</span><span class="content">some-operation</span><span class="delimiter">&quot;</span></span>);
    operationBuilder.inheritResourceAttributeDefinitions();
    operationBuilder.setValueConverter(AttributeConverter.Factory.createHardCoded(<span class="keyword">new</span> ModelNode(<span class="integer">1234</span>) <span class="predefined-constant">true</span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">port</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also rename operations, in this case the operation
<code>some-operation</code> gets renamed to <code>legacy-operation</code> before getting sent
to the legacy secondary HC.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride(<span class="string"><span class="delimiter">&quot;</span><span class="content">some-operation</span><span class="delimiter">&quot;</span></span>);
    operationBuilder.rename(<span class="string"><span class="delimiter">&quot;</span><span class="content">legacy-operation</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="evolving-transformers-with-subsystem-modelversions"><a class="anchor" href="#evolving-transformers-with-subsystem-modelversions"></a>4.6. Evolving transformers with subsystem ModelVersions</h3>
<div class="paragraph">
<p>Say you have a subsystem with ModelVersions 1.0.0 and 1.1.0. There will
(hopefully!) already be transformers in place for 1.1.0 to 1.0.0
transformations. Let&#8217;s say that the transformers registration looks
like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SomeExtension</span> <span class="directive">implements</span> Extension {
<span class="error"> </span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SUBSYSTEM_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">my-subsystem</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">'</span><span class="content">
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 1;
    private static final int MANAGEMENT_API_MINOR_VERSION = 1;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }
 
    private void registerTransformers(final SubsystemRegistration subsystem) {
        registerTransformers_1_0_0(subsystem);
    }
 
    /**
     * Registers transformers from the current version to ModelVersion 1.0.0
     */
    private void registerTransformers_1_0_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, &quot;attr1&quot;)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }
}</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now say we want to do a new version of the model. This new version
contains a new attribute called 'new-attr' which cannot be defined when
transforming to 1.1.0, we bump the model version to 2.0.0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SomeExtension</span> <span class="directive">implements</span> Extension {
<span class="error"> </span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> SUBSYSTEM_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">my-subsystem</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">'</span><span class="content">
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a few ways to evolve your transformers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#the-old-way">#The old
way</a></p>
</li>
<li>
<p><a href="#chained-transformers">#Chained
transformers</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="the-old-way"><a class="anchor" href="#the-old-way"></a>4.6.1. The old way</h4>
<div class="paragraph">
<p>This is the way that has been used up to WildFly 29.x. However, in
WildFly 9 and later, it is strongly recommended to migrate to what is
mentioned in
<a href="#chained-transformers">#Chained
transformers</a></p>
</div>
<div class="paragraph">
<p>Now we need some new transformers from the current ModelVersion to 1.1.0
where we reject any defined occurrances of our new attribute <code>new-attr</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> <span class="type">void</span> registerTransformers(<span class="directive">final</span> SubsystemRegistration subsystem) {
        registerTransformers_1_0_0(subsystem);
        registerTransformers_1_1_0(subsystem);
    }
<span class="error"> </span>
    <span class="comment">/**
     * Registers transformers from the current version to ModelVersion 1.1.0
     */</span>
    <span class="directive">private</span> <span class="type">void</span> registerTransformers_1_1_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, <span class="string"><span class="delimiter">&quot;</span><span class="content">new-attr</span><span class="delimiter">&quot;</span></span>)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(<span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">0</span>));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So that is all well and good, however we also need to take into account
that <code>new-attr</code> <strong>does not exist in ModelVersion 1.0.0 either</strong>, so we
need to extend our transformer for 1.0.0 to reject it there as well. As
you can see 1.0.0 also rejects a defined 'attr1' in addition to the
'new-attr'(which is rejected in both versions).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="comment">/**
     * Registers transformers from the current version to ModelVersion 1.0.0
     */</span>
    <span class="directive">private</span> <span class="type">void</span> registerTransformers_1_0_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">new-attr</span><span class="delimiter">&quot;</span></span>)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now <code>new-attr</code> will be rejected if defined for all previous model
versions.</p>
</div>
</div>
<div class="sect3">
<h4 id="chained-transformers"><a class="anchor" href="#chained-transformers"></a>4.6.2. Chained transformers</h4>
<div class="paragraph">
<p>Since 'The old way' had a lot of duplication of code, since WildFly 9 we
now have chained transformers. You obtain a
<code>ChainedTransformationDescriptionBuilder</code> which is a different entry
point to the <code>ResourceTransformationDescriptionBuilder</code> we have seen
earlier. Each <code>ResourceTransformationDescriptionBuilder</code> deals with
transformation across one version delta.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> <span class="type">void</span> registerTransformers(SubsystemRegistration subsystem) {
        ModelVersion version1_1_0 = ModelVersion.create(<span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">0</span>);
        ModelVersion version1_0_0 = ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>);
<span class="error"> </span>
        ChainedTransformationDescriptionBuilder chainedBuilder =
              TransformationDescriptionBuilder.Factory.createChainedSubystemInstance(subsystem.getSubsystemVersion());
<span class="error"> </span>
        <span class="comment">//Differences between the current version and 1.1.0</span>
        ResourceTransformationDescriptionBuilder builder110 =
            chainedBuilder.create(subsystem.getSubsystemVersion(), version1_1_0);
        builder110.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, <span class="string"><span class="delimiter">&quot;</span><span class="content">new-attr</span><span class="delimiter">&quot;</span></span>)
            .end();
<span class="error"> </span>
        <span class="comment">//Differences between the 1.1.0 and 1.0.0</span>
        ResourceTransformationDescriptionBuilder builder100 =
            chainedBuilder.create(subsystem.getSubsystemVersion(), version1_0_0);
        builder110.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, <span class="string"><span class="delimiter">&quot;</span><span class="content">attr1</span><span class="delimiter">&quot;</span></span>)
            .end();
<span class="error"> </span>
        chainedBuilder.buildAndRegister(subsystem, <span class="keyword">new</span> ModelVersion<span class="type">[]</span>{version1_0_0, version1_1_0});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>buildAndRegister(ModelVersion[]&#8230;&#8203; chains)</code> method registers a
chain consisting of the built <code>builder110</code> and <code>builder100</code> for
transformation to 1.0.0, and a chain consisting of the built
<code>builder110</code> for transformation to 1.1.0. It allows you to specify more
than one chain.</p>
</div>
<div class="paragraph">
<p>Now when transforming from the current version to 1.0.0, the resource is
first transformed from the current version to 1.1.0 (which rejects a
defined <code>new-attr</code>) and then it is transformed from 1.1.0 to 1.0.0
(which rejects a defined <code>attr1</code>). So when evolving transformers you
should normally only need to add things to the last version delta. The
full current-to-1.1.0 transformation is run before the 1.1.0-to-1.0.0
transformation is run.</p>
</div>
<div class="paragraph">
<p>One thing worth pointing out that the value returned by
<code>TransformationContext.readResource(PathAddress address)</code> and
<code>TransformationContext.readResourceFromRoot(PathAddress address)</code> which
you can use from your custom <code>RejectAttributeChecker</code>,
<code>DiscardAttributeChecker</code> and <code>AttributeConverter</code> behaves slightly
differently depending on if you are transforming an operation or a
resource.</p>
</div>
<div class="paragraph">
<p>During <em>resource transformation</em> this will be the latest model, so in
our above example, in the current-to-1.1.0 transformation it will be the
original model. In the 1.1.0-to-1.0.0 transformation, it will be the
result of the current-to-1.1.0 transformation.</p>
</div>
<div class="paragraph">
<p>During <em>operation transformation</em> these methods will always return the
original model (we are transforming operations, not resources!).</p>
</div>
<div class="paragraph">
<p>In WildFly 9 we are now less aggressive about transforming to all
previous versions of WildFly, however we still have a lot of good tests
for running against 7.1.x, 8. Also, for Red Hat employees we have tests
against EAP versions. These tests no longer get run by default, to run
them you need to specify some system properties when invoking maven.
They are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-Djboss.test.transformers.subsystem.old</code> - enables the non-default
subsystem tests.</p>
</li>
<li>
<p>-Djboss.test.transformers.eap - (Red Hat developers only), enables the
eap tests, but only the ones run by default. If run in conjunction with
<code>-Djboss.test.transformers.subsystem.old</code> you get all the possible
subsystem tests run.</p>
</li>
<li>
<p>-Djboss.test.transformers.core.old - enables the non-default core
model tests.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing-transformers"><a class="anchor" href="#testing-transformers"></a>4.7. Testing transformers</h3>
<div class="paragraph">
<p>To test transformation you need to extend
<code>org.jboss.as.subsystem.test.AbstractSubsystemTest</code> or
<code>org.jboss.as.subsystem.test.AbstractSubsystemBaseTest</code>. Then, in order
to have the best test coverage possible, you should test the fullest
configuration that will work, and you should also test configurations
that don&#8217;t work if you have rejecting transformers registered. The
following example is from the threads subsystem, and I have only
included the tests against 7.1.2 - there are more! First we need to set
up our test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ThreadsSubsystemTestCase</span> <span class="directive">extends</span> AbstractSubsystemBaseTest {
    <span class="directive">public</span> ThreadsSubsystemTestCase() {
        <span class="local-variable">super</span>(ThreadsExtension.SUBSYSTEM_NAME, <span class="keyword">new</span> ThreadsExtension());
    }
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">String</span> getSubsystemXml() <span class="directive">throws</span> <span class="exception">IOException</span> {
        <span class="keyword">return</span> readResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">threads-subsystem-1_1.xml</span><span class="delimiter">&quot;</span></span>);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we say that this test is for the <code>threads</code> subsystem, and that it is
implemented by <code>ThreadsExtension</code>. This is the same test framework as we
use in
<a href="Example_subsystem.html#src-557103_Examplesubsystem-Testingtheparsers">Example
subsystem#Testing the parsers</a>, but we will only talk about the parts
relevant to transformers here.</p>
</div>
<div class="sect3">
<h4 id="testing-a-configuration-that-works"><a class="anchor" href="#testing-a-configuration-that-works"></a>4.7.1. Testing a configuration that works</h4>
<div class="paragraph">
<p>To test a configuration xxx</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> testTransformerAS712() <span class="directive">throws</span> <span class="exception">Exception</span> {
        testTransformer_1_0(ModelTestControllerVersion.V7_1_2_FINAL);
    }
    <span class="comment">/**
     * Tests transformation of model from 1.1.0 version into 1.0.0 version.
     *
     * @throws Exception
     */</span>
    <span class="directive">private</span> <span class="type">void</span> testTransformer_1_0(ModelTestControllerVersion controllerVersion) <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="predefined-type">String</span> subsystemXml = <span class="string"><span class="delimiter">&quot;</span><span class="content">threads-transform-1_0.xml</span><span class="delimiter">&quot;</span></span>;   <span class="comment">//This has no expressions not understood by 1.0</span>
        ModelVersion modelVersion = ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>); <span class="comment">//The old model version</span>
        <span class="comment">//Use the non-runtime version of the extension which will happen on the HC</span>
        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)
                .setSubsystemXmlResource(subsystemXml);
<span class="error"> </span>
        <span class="directive">final</span> PathAddress subsystemAddress = PathAddress.pathAddress(PathElement.pathElement(SUBSYSTEM, mainSubsystemName));
<span class="error"> </span>
        <span class="comment">// Add legacy subsystems</span>
        builder.createLegacyKernelServicesBuilder(<span class="predefined-constant">null</span>, controllerVersion, modelVersion)
                .addOperationValidationResolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">add</span><span class="delimiter">&quot;</span></span>, subsystemAddress.append(PathElement.pathElement(<span class="string"><span class="delimiter">&quot;</span><span class="content">thread-factory</span><span class="delimiter">&quot;</span></span>)))
                .addMavenResourceURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.as:jboss-as-threads:</span><span class="delimiter">&quot;</span></span> + controllerVersion.getMavenGavVersion())
                .excludeFromParent(SingleClassFilter.createFilter(ThreadsLogger.class));
<span class="error"> </span>
        KernelServices mainServices = builder.build();
        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);
        Assert.assertNotNull(legacyServices);
        checkSubsystemModelTransformation(mainServices, modelVersion);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this test does is get the builder to configure the test controller
using <code>threads-transform-1_0.xml</code>. This main builder works with the
current subsystem version, and the jars in the WildFly checkout.</p>
</div>
<div class="paragraph">
<p>Next we configure a 'legacy' controller. This will run the version of
the core libraries (e.g the <code>controller</code> module) as found in the
targeted legacy version of JBoss AS/WildFly), and the subsystem. We need
to pass in that it is using the core AS version 7.1.2.Final (i.e. the
<code>ModelTestControllerVersion.V7_1_2_FINAL</code> part) and that that version is
ModelVersion 1.0.0. Next we have some <code>addMavenResourceURL()</code> calls
passing in the Maven GAVs of the old version of the subsystem and any
dependencies it has needed to boot up. Normally, specifying just the
Maven GAV of the old version of the subsystem is enough, but that
depends on your subsystem. In this case the old subsystem GAV is enough.
When booting up the legacy controller the framework uses the parsed
operations from the main controller and transforms them using the 1.0.0
transformer in the threads subsystem. The
<code>addOperationValidationResolve()</code> and <code>excludeFromParent()</code> calls are
not normally necessary, see the javadoc for more examples.</p>
</div>
<div class="paragraph">
<p>The call to <code>KernelServicesBuilder.build()</code> will build both the main
controller and the legacy controller. As part of that it also boots up a
second copy of the main controller using the transformed operations to
make sure that the 'old' ops to boot our subsystem will still work on
the current controller, which is important for backwards compatibility
of CLI scripts. To tweak how that is done if you see failures there, see
<code>LegacyKernelServicesInitializer.skipReverseControllerCheck()</code> and
<code>LegacyKernelServicesInitializer.configureReverseControllerCheck()</code>. The
<code>LegacyKernelServicesInitializer</code> is what gets returned by
<code>KernelServicesBuilder.createLegacyKernelServicesBuilder()</code>.</p>
</div>
<div class="paragraph">
<p>Finally we call <code>checkSubsystemModelTransformation()</code> which reads the
full legacy subsystem model. The legacy subsystem model will have been
built up from the transformed boot operations from the parsed xml. The
operations get transformed by the operation transformers. Then it takes
the model of the current subsystem and transforms that using the
resource transformers. Then it compares the two models, which should be
the same. In some rare cases it is not possible to get those two models
exactly the same, so there is a version of this method that takes a
<code>ModelFixer</code> to make adjustments. The
<code>checkSubsystemModelTransformation()</code> method also makes sure that the
legacy model is valid according to the legacy subsystem&#8217;s resource
definition.</p>
</div>
<div class="paragraph">
<p>The legacy subsystem resource definitions are read on demand from the
legacy controller when the tests run. In some older versions of
subsystems (before we converted everything to use ResourceDefinition,
and DescriptionProvider implementations were coded by hand) there were
occasional problems with the resource definitions and they needed to be
touched up. In this case you can generate a new one, touch it up and
store the result in a file in the test resources under
<code>/same/package/as/the/test/class/{{subsystem-name</code>- <code>model-version</code>.
This will then prefer the file read from the file system to the one read
at runtime. To generate the .dmr file, you need to generate it by adding
a temporary test (make sure that you adjust <code>controllerVersion</code> and
<code>modelVersion</code> to what you want to generate):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> deleteMeWhenDone() <span class="directive">throws</span> <span class="exception">Exception</span> {
        ModelTestControllerVersion controllerVersion = ModelTestControllerVersion.V7_1_2_FINAL;
        ModelVersion modelVersion = ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>);
        KernelServicesBuilder builder = createKernelServicesBuilder(<span class="predefined-constant">null</span>);
<span class="error"> </span>
        builder.createLegacyKernelServicesBuilder(<span class="predefined-constant">null</span>, controllerVersion, modelVersion)
            .addMavenResourceURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.as:jboss-as-threads:</span><span class="delimiter">&quot;</span></span> + controllerVersion.getMavenGavVersion());
        KernelServices services = builder.build();
<span class="error"> </span>
        generateLegacySubsystemResourceRegistrationDmr(services, modelVersion);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now run the test and delete it. The legacy .dmr file should be in
<code>target/test-classes/org/jboss/as/subsystem/test/&lt;your-subsystem-name&gt;-&lt;your-version&gt;.dmr</code>.
Copy this .dmr file to the correct location in your project&#8217;s test
resources.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-a-configuration-that-does-not-work"><a class="anchor" href="#testing-a-configuration-that-does-not-work"></a>4.7.2. Testing a configuration that does not work</h4>
<div class="paragraph">
<p>The <code>threads</code> subsystem (like several others) did not support the use of
expression values in the version that came with JBoss AS 7.1.2.Final. So
we have a test that attempts to use expressions, and then fixes each
resource and attribute where expressions were not allowed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Test</span>
    <span class="directive">public</span> <span class="type">void</span> testRejectExpressionsAS712() <span class="directive">throws</span> <span class="exception">Exception</span> {
        testRejectExpressions_1_0_0(ModelTestControllerVersion.V7_1_2_FINAL);
    }
<span class="error"> </span>
    <span class="directive">private</span> <span class="type">void</span> testRejectExpressions_1_0_0(ModelTestControllerVersion controllerVersion) <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="comment">// create builder for current subsystem version</span>
        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());
<span class="error"> </span>
        <span class="comment">// create builder for legacy subsystem version</span>
        ModelVersion version_1_0_0 = ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>);
        builder.createLegacyKernelServicesBuilder(<span class="predefined-constant">null</span>, controllerVersion, version_1_0_0)
                .addMavenResourceURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.as:jboss-as-threads:</span><span class="delimiter">&quot;</span></span> + controllerVersion.getMavenGavVersion())
                .excludeFromParent(SingleClassFilter.createFilter(ThreadsLogger.class));
<span class="error"> </span>
        KernelServices mainServices = builder.build();
        KernelServices legacyServices = mainServices.getLegacyServices(version_1_0_0);
<span class="error"> </span>
        Assert.assertNotNull(legacyServices);
        Assert.assertTrue(<span class="string"><span class="delimiter">&quot;</span><span class="content">main services did not boot</span><span class="delimiter">&quot;</span></span>, mainServices.isSuccessfulBoot());
        Assert.assertTrue(legacyServices.isSuccessfulBoot());
<span class="error"> </span>
        <span class="predefined-type">List</span>&lt;ModelNode&gt; xmlOps = builder.parseXmlResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">expressions.xml</span><span class="delimiter">&quot;</span></span>);
<span class="error"> </span>
        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, version_1_0_0, xmlOps, getConfig());
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again we boot up a current and a legacy controller. However, note in
this case that they are both empty, no xml was parsed on boot so there
are no operations to boot up the model. Instead once the controllers
have been booted, we call <code>KernelServicesBuilder.parseXmlResource()</code>
which gets the operations from <code>expressions.xml</code>. <code>expressions.xml</code> uses
expressions in all the places they were not allowed in 7.1.2.Final. For
each resource <code>ModelTestUtils.checkFailedTransformedBootOperations()</code>
will check that the <code>add</code> operation gets rejected, and then correct one
attribute at a time until the resource has been totally corrected. Once
the <code>add</code> operation is totally correct, it will check that the add
operation no longer is rejected. The configuration for this is the
<code>FailedOperationTransformationConfig</code> returned by the <code>getConfig()</code>
method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> FailedOperationTransformationConfig getConfig() {
        PathAddress subsystemAddress = PathAddress.pathAddress(ThreadsExtension.SUBSYSTEM_PATH);
        FailedOperationTransformationConfig.RejectExpressionsConfig allowedAndKeepalive =
                <span class="keyword">new</span> FailedOperationTransformationConfig.RejectExpressionsConfig(PoolAttributeDefinitions.ALLOW_CORE_TIMEOUT, PoolAttributeDefinitions.KEEPALIVE_TIME);
...
        return <span class="keyword">new</span> FailedOperationTransformationConfig()
                .addFailedAttribute(subsystemAddress.append(PathElement.pathElement(CommonAttributes.BLOCKING_BOUNDED_QUEUE_THREAD_POOL)),
                        allowedAndKeepalive)
                .addFailedAttribute(subsystemAddress.append(PathElement.pathElement(CommonAttributes.BOUNDED_QUEUE_THREAD_POOL)),
                        allowedAndKeepalive)
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So what this means is that we expect the <code>allow-core-timeout</code> and
<code>keepalive-time</code> attributes for the
<code>blocking-bounded-queue-thread-pool=<strong></code> and <code>bounded-queue-thread-pool=</strong></code>
add operations to use expressions in the parsed xml. We then expect them
to fail since there should be transformers in place to reject
expressions, and correct them one at a time until the add operation
should pass. As well as doing the <code>add</code> operations the
<code>ModelTestUtils.checkFailedTransformedBootOperations()</code> method will also
try calling <code>write-attribute</code> for each attribute, correcting as it goes
along. As well as allowing you to test rejection of expressions
<code>FailedOperationTransformationConfig</code> also has some helper classes to
help testing rejection of other scenarios.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="common-transformation-use-cases"><a class="anchor" href="#common-transformation-use-cases"></a>4.8. Common transformation use-cases</h3>
<div class="paragraph">
<p>Most transformations are quite similar, so this section covers some of
the actual transformation patterns found in the WildFly codebase. We
will look at the output of CompareModelVersionsUtil, and see what can be
done to transform for the older secondary HCs. The examples come from the
WildFly codebase but are stripped down to focus solely on the use-case
being explained in an attempt to keep things as clear/simple as
possible.</p>
</div>
<div class="sect3">
<h4 id="child-resource-type-does-not-exist-in-legacy-model"><a class="anchor" href="#child-resource-type-does-not-exist-in-legacy-model"></a>4.8.1. Child resource type does not exist in legacy model</h4>
<div class="paragraph">
<p>Looking at the model comparison between WildFly and JBoss AS 7.2.0,
there is a change to the <code>remoting</code> subsystem. The relevant part of the
output is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">======= Resource root address: [<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystem</span><span class="delimiter">&quot;</span></span> =&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">remoting</span><span class="delimiter">&quot;</span></span>] - Current version: <span class="float">2.0</span><span class="float">.0</span>; legacy version: <span class="float">1.2</span><span class="float">.0</span> =======
--- Problems <span class="keyword">for</span> relative address to root <span class="type">[]</span>:
Missing child types in current: <span class="type">[]</span>; missing in legacy [http-connector]</code></pre>
</div>
</div>
<div class="paragraph">
<p>So our current model has added a child type called <code>http-connector</code>
which was not there in 7.2.0. This is configurable, and adds new
behavior, so it can not be part of a configuration sent across to a
legacy secondary HC running version 1.2.0. So we add the following to
<code>RemotingExtension</code> to reject all instances of that child type against
ModelVersion 1.2.0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> initialize(ExtensionContext context) {
        ....
        if (context.isRegisterTransformers()) {
            registerTransformers_1_1(registration);
            registerTransformers_1_2(registration);
        }
    }

    <span class="directive">private</span> <span class="type">void</span> registerTransformers_1_2(SubsystemRegistration registration) {
        TransformationDescription.Tools.register(get1_2_0_1_3_0Description(), registration, VERSION_1_2);
    }

    <span class="directive">private</span> <span class="directive">static</span> TransformationDescription get1_2_0_1_3_0Description() {
        ResourceTransformationDescriptionBuilder builder = ResourceTransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.rejectChildResource(HttpConnectorResource.PATH);

        <span class="keyword">return</span> builder.build();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since this child resource type also does not exist in ModelVersion 1.1.0
we need to reject it there as well using a similar mechanism.</p>
</div>
</div>
<div class="sect3">
<h4 id="attribute-does-not-exist-in-the-legacy-subsystem"><a class="anchor" href="#attribute-does-not-exist-in-the-legacy-subsystem"></a>4.8.2. Attribute does not exist in the legacy subsystem</h4>
<div class="sect4">
<h5 id="default-value-of-the-attribute-is-the-same-as-legacy-implied-behavior"><a class="anchor" href="#default-value-of-the-attribute-is-the-same-as-legacy-implied-behavior"></a>Default value of the attribute is the same as legacy implied</h5>
<div class="paragraph">
<p>behavior</p>
</div>
<div class="paragraph">
<p>This example also comes from the <code>remoting</code> subsystem, and is probably
the most common type of transformation. The comparison tells us that
there is now an attribute under
<code>/subsystem=remoting/remote-outbound-connection=*</code> called <code>protocol</code>
which did not exist in the older version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">======= Resource root address: [<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystem</span><span class="delimiter">&quot;</span></span> =&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">remoting</span><span class="delimiter">&quot;</span></span>] - Current version: <span class="float">2.0</span><span class="float">.0</span>; legacy version: <span class="float">1.2</span><span class="float">.0</span> =======
--- Problems <span class="keyword">for</span> relative address to root <span class="type">[]</span>:
....
--- Problems <span class="keyword">for</span> relative address to root [<span class="string"><span class="delimiter">&quot;</span><span class="content">remote-outbound-connection</span><span class="delimiter">&quot;</span></span> =&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span>]:
Missing attributes in current: <span class="type">[]</span>; missing in legacy [protocol]
Missing parameters <span class="keyword">for</span> operation <span class="string"><span class="delimiter">'</span><span class="content">add</span><span class="delimiter">'</span></span> in current: <span class="type">[]</span>; missing in legacy [protocol]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This difference also affects the <code>add</code> operation. Looking at the current
model the valid values for the <code>protocol</code> attribute are <code>remote</code>,
<code>http-remoting</code> and <code>https-remoting</code>. The last two are new protocols
introduced in WildFly 29, meaning that the <em>implied behaviour</em> in JBoss
7.2.0 and earlier is the <code>remote</code> protocol. Since this attribute does
not exist in the legacy model we want to discard this attribute if it is
<code>undefined</code> or if it has the value <code>remote</code>, both of which are in line
with what the legacy secondary HC is hardwired to use. Also we want to
reject it if it has a value different from <code>remote</code>. So what we need to
do when registering transformers against ModelVersion 1.2.0 to handle
this attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> <span class="type">void</span> registerTransformers_1_2(SubsystemRegistration registration) {
        TransformationDescription.Tools.register(get1_2_0_1_3_0Description(), registration, VERSION_1_2);
    }
<span class="error"> </span>
    <span class="directive">private</span> <span class="directive">static</span> TransformationDescription get1_2_0_1_3_0Description() {
        ResourceTransformationDescriptionBuilder builder = ResourceTransformationDescriptionBuilder.Factory.createSubsystemInstance();
        protocolTransform(builder.addChildResource(RemoteOutboundConnectionResourceDefinition.ADDRESS)
                .getAttributeBuilder());
        <span class="keyword">return</span> builder.build();
    }
<span class="error"> </span>
    <span class="directive">private</span> <span class="directive">static</span> AttributeTransformationDescriptionBuilder protocolTransform(AttributeTransformationDescriptionBuilder builder) {
        builder.setDiscard(<span class="keyword">new</span> DiscardAttributeChecker.DiscardAttributeValueChecker(<span class="keyword">new</span> ModelNode(Protocol.REMOTE.toString())), RemoteOutboundConnectionResourceDefinition.PROTOCOL)
                .addRejectCheck(RejectAttributeChecker.DEFINED, RemoteOutboundConnectionResourceDefinition.PROTOCOL);
        <span class="keyword">return</span> builder;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the first thing to happens is that we register a
<code>DiscardAttributeChecker.DiscardAttributeValueChecker</code> which discards
the attribute if it is either <code>undefined</code> (the default value in the
current model is <code>remote</code>), or <code>defined</code> and has the value <code>remote</code>.
Remembering that the <code>discard</code> phase always happens before the <code>reject</code>
phase, the reject checker checks that the <code>protocol</code> attribute is
defined, and rejects it if it is. The only reason it would be <code>defined</code>
in the reject check, is if it was not discarded by the discard check.
Hopefully this example shows that the discard and reject checkers often
work in pairs.</p>
</div>
<div class="paragraph">
<p>An alternative way to write the <code>protocolTransform()</code> method would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">     <span class="directive">private</span> <span class="directive">static</span> AttributeTransformationDescriptionBuilder protocolTransform(AttributeTransformationDescriptionBuilder builder) {
        builder.setDiscard(<span class="keyword">new</span> DiscardAttributeChecker.DefaultDiscardAttributeChecker() {
                    <span class="annotation">@Override</span>
                    <span class="directive">protected</span> <span class="type">boolean</span> isValueDiscardable(<span class="directive">final</span> PathAddress address, <span class="directive">final</span> <span class="predefined-type">String</span> attributeName, <span class="directive">final</span> ModelNode attributeValue, <span class="directive">final</span> TransformationCon
                        <span class="keyword">return</span> !attributeValue.isDefined() || attributeValue.asString().equals(Protocol.REMOTE.toString());
                    }
                }, RemoteOutboundConnectionResourceDefinition.PROTOCOL)
         .addRejectCheck(RejectAttributeChecker.DEFINED, RemoteOutboundConnectionResourceDefinition.PROTOCOL);
         <span class="keyword">return</span> builder;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reject check remains the same, but we have implemented the discard
check by using <code>DiscardAttributeChecker.DefaultDiscardAttributeChecker</code>
instead. However, the effect of the discard check is exactly the same as
when we used <code>DiscardAttributeChecker.DiscardAttributeValueChecker</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="default-value-of-the-attribute-is-different-from-legacy-implied-behaviour"><a class="anchor" href="#default-value-of-the-attribute-is-different-from-legacy-implied-behaviour"></a>Default value of the attribute is different from legacy implied</h5>
<div class="paragraph">
<p>behaviour</p>
</div>
<div class="paragraph">
<p>We touched on this in the weld subsystem example we used earlier in this
guide, but let&#8217;s take a more thorough look. Our comparison tells us that
we have two new attributes <code>require-bean-descriptor</code> and
<code>non-portable-mode</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>====== Resource root address: ["subsystem" =&gt; "weld"] - Current version: 2.0.0; legacy version: 1.0.0 =======
--- Problems for relative address to root []:
Missing attributes in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]
Missing parameters for operation 'add' in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]</pre>
</div>
</div>
<div class="paragraph">
<p>Now when we look at this we see that the default value for both of the
attributes in the current model is <code>false</code>, which allows us more
flexible behavior introduced in CDI 1.1 (which was introduced with this
version of the subsystem). The old model does not have these attributes,
and implements CDI 1.0, which under the hood (using our weld subsystem
expertise knowledge) implies the values <code>true</code> for both of these. So our
transformer must reject anything that is not <code>true</code> for these
attributes. Let us look at the transformer registered by the
WeldExtension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">private</span> <span class="type">void</span> registerTransformers(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        <span class="comment">//These new attributes are assumed to be 'true' in the old version but default to false in the current version. So discard if 'true' and reject if 'undefined'.</span>
        builder.getAttributeBuilder()
                .setDiscard(<span class="keyword">new</span> DiscardAttributeChecker.DiscardAttributeValueChecker(<span class="predefined-constant">false</span>, <span class="predefined-constant">false</span>, <span class="keyword">new</span> ModelNode(<span class="predefined-constant">true</span>)),
                        WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .addRejectCheck(<span class="keyword">new</span> RejectAttributeChecker.DefaultRejectAttributeChecker() {
<span class="error"> </span>
                    <span class="annotation">@Override</span>
                    <span class="directive">public</span> <span class="predefined-type">String</span> getRejectionLogMessage(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, ModelNode&gt; attributes) {
                        <span class="keyword">return</span> WeldMessages.MESSAGES.rejectAttributesMustBeTrue(attributes.keySet());
                    }
<span class="error"> </span>
                    <span class="annotation">@Override</span>
                    <span class="directive">protected</span> <span class="type">boolean</span> rejectAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue,
                            TransformationContext context) {
                        <span class="comment">//This will not get called if it was discarded, so reject if it is undefined (default==false) or if defined and != 'true'</span>
                        <span class="keyword">return</span> !attributeValue.isDefined() || !attributeValue.asString().equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>);
                    }
                }, WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This looks a bit more scary than the previous transformer we have seen,
but isn&#8217;t actually too bad. The first thing we do is register a
<code>DiscardAttributeChecker.DiscardAttributeValueChecker</code> which will
discard the attribute if it has the value <code>true</code>. It will not discard if
it is <code>undefined</code> since that defaults to <code>false</code>. This is registered for
both attributes.</p>
</div>
<div class="paragraph">
<p>If the attributes had the value <code>true</code> they will get discarded we will
not hit the reject checker since discarded attributes never get checked
for rejection. If on the other hand they were an expression (since we
are interested in the actual value, but cannot evaluate what value an
expression will resolve to on the target from the DC running the
transformers), <code>false</code>, or <code>undefined</code> (which will then default to
<code>false</code>) they will not get discarded and will need to be rejected. So
our
<code>RejectAttributeChecker.DefaultRejectAttributeChecker.rejectAttribute()</code>
method will return <code>true</code> (i.e. reject) if the attribute value is
<code>undefined</code> (since that defaults to <code>false</code>) or if it is defined and
'not equal to `true&#8217;. It is better to check for 'not equal to `true&#8217;
than to check for 'equal to `false&#8217; since if an expression was used we
still want to reject, and only the 'not equal to `true&#8217; check would
actually kick in in that case.</p>
</div>
<div class="paragraph">
<p>The other thing we need in our
<code>DiscardAttributeChecker.DiscardAttributeValueChecker</code> is to override
the <code>getRejectionLogMessage()</code> method to get the message to be displayed
when rejecting the transformation. In this case it says something along
the lines "These attributes must be 'true' for use with CDI 1.0 '%s'",
with the names of the attributes having been rejected substituting the
<code>%s</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="attribute-has-a-different-default-value"><a class="anchor" href="#attribute-has-a-different-default-value"></a>4.8.3. Attribute has a different default value</h4>
<div class="paragraph">
<p>– TODO</p>
</div>
<div class="paragraph">
<p>(The gist of this is to use a value converter, such that if the
attribute is undefined, and hence the default value will take effect,
then the value gets converted to the current version&#8217;s default value.
This ensures that the legacy HC will use the same effective setting as
current version HCs.</p>
</div>
<div class="paragraph">
<p>Note however that a change in default values is a form of incompatible
API change, since CLI scripts written assuming the old defaults will now
produce a configuration that behaves differently. Transformers make it
possible to have a consistently configured domain even in the presence
of this kind of incompatible change, but that doesn&#8217;t mean such changes
are good practice. They are generally unacceptable in WildFly&#8217;s own
subsystems.</p>
</div>
<div class="paragraph">
<p>One trick to ameliorate the impact of a default value change is to
modify the xml parser for the <strong>old</strong> schema version such that if the xml
attribute is not configured, the parser sets the old default value for
the attribute, instead of <code>undefined</code>. This approach allows the parsing
of old config documents to produce results consistent with what happened
when they were created. It does not help with CLI scripts though.)</p>
</div>
</div>
<div class="sect3">
<h4 id="attribute-has-a-different-type"><a class="anchor" href="#attribute-has-a-different-type"></a>4.8.4. Attribute has a different type</h4>
<div class="paragraph">
<p>Here the example comes from the <code>capacity</code> parameter some way into the
<code>modcluster</code> subsystem, and the legacy version is AS 7.1.2.Final. There
are quite a few differences, so I am only showing the ones relevant for
this example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>====== Resource root address: ["subsystem" =&gt; "modcluster"] - Current version: 2.0.0; legacy version: 1.2.0 =======
...
--- Problems for relative address to root ["mod-cluster-config" =&gt; "configuration","dynamic-load-provider" =&gt; "configuration","custom-load-m
etric" =&gt; "*"]:
Different 'type' for attribute 'capacity'. Current: DOUBLE; legacy: INT
Different 'expressions-allowed' for attribute 'capacity'. Current: true; legacy: false
...
Different 'type' for parameter 'capacity' of operation 'add'. Current: DOUBLE; legacy: INT
Different 'expressions-allowed' for parameter 'capacity' of operation 'add'. Current: true; legacy: false</pre>
</div>
</div>
<div class="paragraph">
<p>So as we can see expressions are not allowed for the <code>capacity</code>
attribute, and the current type is <code>double</code> while the legacy subsystem
is <code>int</code>. So this means that if the value is for example <code>2.0</code> we can
convert this to <code>2</code>, but <code>2.5</code> cannot be converted. The way this is
solved in the ModClusterExtension is to register the following some
other attributes are registered here, but hopefully it is clear anyway:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        dynamicLoadProvider.addChildResource(LOAD_METRIC_PATH)
                    .getAttributeBuilder()
                        .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, TYPE, WEIGHT, CAPACITY, PROPERTY)
                        .addRejectCheck(CapacityCheckerAndConverter.INSTANCE, CAPACITY)
                        .setValueConverter(CapacityCheckerAndConverter.INSTANCE, CAPACITY)
                        ...
                        .end();</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we register that we should reject expressions, and we also register
the <code>CapacityCheckerAndConverter</code> for <code>capacity</code>.
<code>CapacityCheckerAndConverter</code> extends the convenience class
<code>DefaultCheckersAndConverter</code> which implements the
<code>DiscardAttributeChecker</code>, <code>RejectAttributeChecker</code>, and
<code>AttributeConverter</code> interfaces. We have seen <code>DiscardAttributeChecker</code>
and <code>RejectAttributeChecker</code> in previous examples. Since we now need to
convert a value we need an instance of <code>AttributeConverter</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="type">class</span> <span class="class">CapacityCheckerAndConverter</span> <span class="directive">extends</span> DefaultCheckersAndConverter {
<span class="error"> </span>
        <span class="directive">static</span> <span class="directive">final</span> CapacityCheckerAndConverter INSTANCE = <span class="keyword">new</span> CapacityCheckerAndConverter();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We should not discard so <code>isValueDiscardable()</code> from
<code>DiscardAttributeChecker</code> always returns <code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">boolean</span> isValueDiscardable(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context) {
            <span class="comment">//Not used for discard</span>
            <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        }
<span class="error"> </span>
        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="predefined-type">String</span> getRejectionLogMessage(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, ModelNode&gt; attributes) {
            <span class="keyword">return</span> ModClusterMessages.MESSAGES.capacityIsExpressionOrGreaterThanIntegerMaxValue(attributes.get(CAPACITY.getName()));
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we check to see if we can convert the attribute to an <code>int</code> and
reject if not. Note that if it is an expression, we have no idea what
its value will resolve to on the target host, so we need to reject it.
Then we try to change it into an <code>int</code>, and reject if that was not
possible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">boolean</span> rejectAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context) {
            <span class="keyword">if</span> (checkForExpression(attributeValue)
                    || (attributeValue.isDefined() &amp;&amp; !isIntegerValue(attributeValue.asDouble()))) {
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
            }
            <span class="predefined-type">Long</span> converted = convert(attributeValue);
            <span class="keyword">return</span> (converted != <span class="predefined-constant">null</span> &amp;&amp; (converted &gt; <span class="predefined-type">Integer</span>.MAX_VALUE || converted &lt; <span class="predefined-type">Integer</span>.MIN_VALUE));
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then finally we do the conversion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">void</span> convertAttribute(PathAddress address, <span class="predefined-type">String</span> attributeName, ModelNode attributeValue, TransformationContext context) {
            <span class="predefined-type">Long</span> converted = convert(attributeValue);
            <span class="keyword">if</span> (converted != <span class="predefined-constant">null</span> &amp;&amp; converted &lt;= <span class="predefined-type">Integer</span>.MAX_VALUE &amp;&amp; converted &gt;= <span class="predefined-type">Integer</span>.MIN_VALUE) {
                attributeValue.set((<span class="type">int</span>)converted.longValue());
            }
        }
<span class="error"> </span>
<span class="error"> </span>
        <span class="directive">private</span> <span class="predefined-type">Long</span> convert(ModelNode attributeValue) {
            <span class="keyword">if</span> (attributeValue.isDefined() &amp;&amp; !checkForExpression(attributeValue)) {
                <span class="type">double</span> raw = attributeValue.asDouble();
                <span class="keyword">if</span> (isIntegerValue(raw)) {
                    <span class="keyword">return</span> <span class="predefined-type">Math</span>.round(raw);
                }
            }
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }
<span class="error"> </span>
        <span class="directive">private</span> <span class="type">boolean</span> isIntegerValue(<span class="type">double</span> raw) {
            <span class="keyword">return</span> raw == <span class="predefined-type">Double</span>.valueOf(<span class="predefined-type">Math</span>.round(raw)).doubleValue();
        }
<span class="error"> </span>
    }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
References in this document to Java Persistence API (JPA) refer to the Jakarta Persistence unless otherwise noted.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Key_Interfaces_and_Classes_Relevant_to_Extension_Developers"><a class="anchor" href="#Key_Interfaces_and_Classes_Relevant_to_Extension_Developers"></a>5. Key Interfaces and Classes Relevant to Extension Developers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the first major section of this guide, we provided an example of how
to implement an extension to the AS. The emphasis there was learning by
doing. In this section, we&#8217;ll focus a bit more on the major WildFly
interfaces and classes that most are relevant to extension developers.
The best way to learn about these interfaces and classes in detail is to
look at their javadoc. What we&#8217;ll try to do here is provide a brief
introduction of the key items and how they relate to each other.</p>
</div>
<div class="paragraph">
<p>Before digging into this section, readers are encouraged to read the
"Core Management Concepts" section of the Admin Guide.</p>
</div>
<div class="sect2">
<h3 id="extension-interface"><a class="anchor" href="#extension-interface"></a>5.1. Extension Interface</h3>
<div class="paragraph">
<p>The <code>org.jboss.as.controller.Extension</code> interface is the hook by which
your extension to the AS kernel is able to integrate with the AS. During
boot of the AS, when the <code>&lt;extension&gt;</code> element in the AS&#8217;s xml
configuration file naming your extension is parsed, the JBoss Modules
module named in the element&#8217;s name attribute is loaded. The standard JDK
<code>java.lang.ServiceLoader</code> mechanism is then used to load your module&#8217;s
implementation of this interface.</p>
</div>
<div class="paragraph">
<p>The function of an <code>Extension</code> implementation is to register with the
core AS the management API, xml parsers and xml marshallers associated
with the extension module&#8217;s subsystems. An <code>Extension</code> can register
multiple subsystems, although the usual practice is to register just one
per extension.</p>
</div>
<div class="paragraph">
<p>Once the <code>Extension</code> is loaded, the core AS will make two invocations
upon it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void initializeParsers(ExtensionParsingContext context)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When this is invoked, it is the <code>Extension</code> implementation&#8217;s
responsibility to initialize the XML parsers for this extension&#8217;s
subsystems and register them with the given <code>ExtensionParsingContext</code>.
The parser&#8217;s job when it is later called is to create
<code>org.jboss.dmr.ModelNode</code> objects representing WildFly management API
operations needed make the AS&#8217;s running configuration match what is
described in the xml. Those management operation <code>ModelNode</code> s are added
to a list passed in to the parser.</p>
</div>
<div class="paragraph">
<p>A parser for each version of the xml schema used by a subsystem should
be registered. A well behaved subsystem should be able to parse any
version of its schema that it has ever published in a final release.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void initialize(ExtensionContext context)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When this is invoked, it is the <code>Extension</code> implementation&#8217;s
responsibility to register with the core AS the management API for its
subsystems, and to register the object that is capable of marshalling
the subsystem&#8217;s in-memory configuration back to XML. Only one XML
marshaller is registered per subsystem, even though multiple XML parsers
can be registered. The subsystem should always write documents that
conform to the latest version of its XML schema.</p>
</div>
<div class="paragraph">
<p>The registration of a subsystem&#8217;s management API is done via the
<code>ManagementResourceRegistration</code> interface. Before discussing that
interface in detail, let&#8217;s describe how it (and the related <code>Resource</code>
interface) relate to the notion of managed resources in the AS.</p>
</div>
</div>
<div class="sect2">
<h3 id="wildfly-managed-resources"><a class="anchor" href="#wildfly-managed-resources"></a>5.2. WildFly Managed Resources</h3>
<div class="paragraph">
<p>Each subsystem is responsible for managing one or more management
resources. The conceptual characteristics of a management resource are
covered in some detail in the <a href="Admin_Guide.html#management-resources">Admin
Guide</a>; here we&#8217;ll just summarize the main points. A management resource
has</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <strong><em>address</em></strong> consisting of a list of key/value pairs that uniquely
identifies a resource</p>
</li>
<li>
<p>Zero or more <strong><em>attributes</em></strong> , the value of which is some sort of
<code>org.jboss.dmr.ModelNode</code></p>
</li>
<li>
<p>Zero or more supported <strong><em>operations</em></strong> . An operation has a string name
and zero or more parameters, each of which is a key/value pair where the
key is a string naming the parameter and the value is some sort of
<code>ModelNode</code></p>
</li>
<li>
<p>Zero or more <strong><em>children</em></strong> , each of which in turn is a managed
resource</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The implementation of a managed resource is somewhat analogous to the
implementation of a Java object. A managed resource will have a "type",
which encapsulates API information about that resource and logic used to
implement that API. And then there are actual instances of the resource,
which primarily store data representing the current state of a
particular resource. This is somewhat analogous to the "class" and
"object" notions in Java.</p>
</div>
<div class="paragraph">
<p>A managed resource&#8217;s type is encapsulated by the
<code>org.jboss.as.controller.registry.ManagementResourceRegistration</code> the
core AS creates when the type is registered. The data for a particular
instance is encapsulated in an implementation of the
<code>org.jboss.as.controller.registry.Resource</code> interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="managementresourceregistration-interface"><a class="anchor" href="#managementresourceregistration-interface"></a>5.3. ManagementResourceRegistration Interface</h3>
<div class="paragraph">
<p>In the Java analogy used above, the <code>ManagementResourceRegistration</code> is
analogous to the "class", while the <code>Resource</code> discussed below is
analogous to an instance of that class.</p>
</div>
<div class="paragraph">
<p>A <code>ManagementResourceRegistration</code> represents the specification for a
particular managed resource type. All resources whose address matches
the same pattern will be of the same type, specified by the type&#8217;s
<code>ManagementResourceRegistration</code>. The MRR encapsulates:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>PathAddress</code> showing the address pattern that matches resources of
that type. This <code>PathAddress</code> can and typically does involve wildcards
in the value of one or more elements of the address. In this case there
can be more than one instance of the type, i.e. different <code>Resource</code>
instances.</p>
</li>
<li>
<p>Definition of the various attributes exposed by resources of this
type, including the <code>OperationStepHandler</code> implementations used for
reading and writing the attribute values.</p>
</li>
<li>
<p>Definition of the various operations exposed by resources of this
type, including the <code>OperationStepHandler</code> implementations used for
handling user invocations of those operations.</p>
</li>
<li>
<p>Definition of child resource types. <code>ManagementResourceRegistration</code>
instances form a tree.</p>
</li>
<li>
<p>Definition of management notifications emitted by resources of this
type.</p>
</li>
<li>
<p>Definition of
<a href="#Working_with_WildFly_Capabilities">capabilities</a> provided by
resources of this type.</p>
</li>
<li>
<p>Definition of <a href="Admin_Guide.html#RBAC">RBAC</a> access constraints that should be
applied by the management kernel when authorizing operations against
resources of this type.</p>
</li>
<li>
<p>Whether the resource type is an alias to another resource type, and if
so information about that relationship. Aliases are primarily used to
preserve backwards compatibility of the management API when the location
of a given type of resources is moved in a newer release.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ManagementResourceRegistration</code> interface is a subinterface of
<code>ImmutableManagementResourceRegistration</code>, which provides a read-only
view of the information encapsulated by the MRR. The MRR subinterface
adds the methods needed for registering the attributes, operations,
children, etc.</p>
</div>
<div class="paragraph">
<p>Extension developers do not directly instantiate an MRR. Instead they
create a <code>ResourceDefinition</code> for the root resource type for each
subsystem, and register it with the <code>ExtensionContext</code> passed in to
their <code>Extension</code> implementation&#8217;s <code>initialize</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">public</span> <span class="type">void</span> initialize(ExtensionContext context) {
        SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_VERSION);
        subsystem.registerXMLElementWriter(getOurXmlWriter());
        ResourceDefinition rd = getOurSubsystemDefinition();
        ManagementResourceRegistration mrr = subsystem.registerSubsystemModel(rd));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The kernel uses the provided <code>ResourceDefinition</code> to construct a
<code>ManagementResourceRegistration</code> and then passes that MRR to the various
<code>registerXXX</code> methods implemented by the <code>ResourceDefinition</code>, giving it
the change to record the resource type&#8217;s attributes, operations and
children.</p>
</div>
</div>
<div class="sect2">
<h3 id="resourcedefinition-interface"><a class="anchor" href="#resourcedefinition-interface"></a>5.4. ResourceDefinition Interface</h3>
<div class="paragraph">
<p>An implementation of <code>ResourceDefinition</code> is the primary class used by
an extension developer when defining a managed resource type. It
provides basic information about the type, exposes a
<code>DescriptionProvider</code> used to generate a DMR description of the type,
and implements callbacks the kernel can invoke when building up the
<code>ManagementResourceRegistration</code> to ask for registration of definitions
of attributes, operations, children, notifications and capabilities.</p>
</div>
<div class="paragraph">
<p>Almost always an extension author will create their <code>ResourceDefinition</code>
by creating a subclass of the
<code>org.jboss.as.controller.SimpleResourceDefinition</code> class or of its
<code>PersistentResourceDefinition</code> subclass. Both of these classes have
constructors that take a <code>Parameters</code> object, which is a simple builder
class to use to provide most of the key information about the resource
type. The extension-specific subclass would then take responsibility for
any additional behavior needed by overriding the <code>registerAttributes</code>,
<code>registerOperations</code>, <code>registerNotifications</code> and <code>registerChildren</code>
callbacks to do whatever is needed beyond what is provided by the
superclasses.</p>
</div>
<div class="paragraph">
<p>For example, to add a writable attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> registerAttributes(ManagementResourceRegistration resourceRegistration) {
        <span class="local-variable">super</span>.registerAttributes(resourceRegistration);
        <span class="comment">// Now we register the 'foo' attribute</span>
        AttributeDefinition ad = FOO; <span class="comment">// constant declared elsewhere</span>
        OperationStepHandler writeHandler = <span class="keyword">new</span> FooWriteAttributeHandler();
        resourceRegistration.registerReadWriteHandler(ad, <span class="predefined-constant">null</span>, writeHandler); <span class="comment">// null read handler means use default read handling</span>
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To register a custom operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> registerOperations(ManagementResourceRegistration resourceRegistration) {
        <span class="local-variable">super</span>.registerOperations(resourceRegistration);
        <span class="comment">// Now we register the 'foo-bar' custom operation</span>
        OperationDefinition od = FooBarOperationStepHandler.getDefinition();
        OperationStepHandler osh = <span class="keyword">new</span> FooBarOperationStepHandler();
        resourceRegistration.registerOperationHandler(od, osh);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To register a child resource type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> registerChildren(ManagementResourceRegistration resourceRegistration) {
        <span class="local-variable">super</span>.registerChildren(resourceRegistration);
        <span class="comment">// Now we register the 'baz=*' child type</span>
        ResourceDefinition rd = <span class="keyword">new</span> BazResourceDefinition();
        resourceRegistration.registerSubmodel(rd);
    }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="resourcedescriptionresolver"><a class="anchor" href="#resourcedescriptionresolver"></a>5.4.1. ResourceDescriptionResolver</h4>
<div class="paragraph">
<p>One of the things a <code>ResourceDefinition</code> must be able to do is provide a
<code>DescriptionProvider</code> that provides a proper DMR description of the
resource to use as the output for the standard
<code>read-resource-description</code> management operation. Since you are almost
certainly going to be using one of the standard <code>ResourceDefinition</code>
implementations like <code>SimpleResourceDefinition</code>, the creation of this
<code>DescriptionProvider</code> is largely handled for you. The one thing that is
not handled for you is providing the localized free form text
descriptions of the various attributes, operations, operation
parameters, child types, etc used in creating the resource description.</p>
</div>
<div class="paragraph">
<p>For this you must provide an implementation of the
<code>ResourceDescriptionResolver</code> interface, typically passed to the
<code>Parameters</code> object provided to the <code>SimpleResourceDefinition</code>
constructor. This interface has various methods that are invoked when a
piece of localized text description is needed.</p>
</div>
<div class="paragraph">
<p>Almost certainly you&#8217;ll satisfy this requirement by providing an
instance of the <code>StandardResourceDescriptionResolver</code> class.</p>
</div>
<div class="paragraph">
<p><code>StandardResourceDescriptionResolver</code> uses a <code>ResourceBundle</code> to load
text from a properties file available on the classpath. The keys in the
properties file must follow patterns expected by
<code>StandardResourceDescriptionResolver</code>. See the
<code>StandardResourceDescriptionResolver</code> javadoc for further details.</p>
</div>
<div class="paragraph">
<p>The biggest task here is to create the properties file and add the text
descriptions. A text description must be provided for everything. The
typical thing to do is to store this properties file in the same package
as your <code>Extension</code> implementation, in a file named
<code>LocalDescriptions.properties</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="attributedefinition-class"><a class="anchor" href="#attributedefinition-class"></a>5.5. AttributeDefinition Class</h3>
<div class="paragraph">
<p>The <code>AttributeDefinition</code> class is used to create the static definition
of one of a managed resource&#8217;s attributes. It&#8217;s a bit poorly named
though, because the same interface is used to define the details of
parameters to operations, and to define fields in the result of of
operations.</p>
</div>
<div class="paragraph">
<p>The definition includes all the static information about the
attribute/operation parameter/result field, e.g. the DMR <code>ModelType</code> of
its value, whether its presence is required, whether it supports
expressions, etc. See
<a href="Admin_Guide.html#Description_of_the_Management_Model">Description of the
Management Model</a> for a description of the metadata available. Almost
all of this comes from the <code>AttributeDefinition</code>.</p>
</div>
<div class="paragraph">
<p>Besides basic metadata, the <code>AttributeDefinition</code> can also hold custom
logic the kernel should use when dealing with the attribute/operation
parameter/result field. For example, a <code>ParameterValidator</code> to use to
perform special validation of values (beyond basic things like DMR type
checks and defined/undefined checks), or an <code>AttributeParser</code> or
<code>AttributeMarshaller</code> to use to perform customized parsing from and
marshaling to XML.</p>
</div>
<div class="paragraph">
<p>WildFly Core&#8217;s <code>controller</code> module provides a number of subclasses of
<code>AttributeDefinition</code> used for the usual kinds of attributes. For each
there is an associated builder class which you should use to build the
<code>AttributeDefinition</code>. Most commonly used are
<code>SimpleAttributeDefinition</code>, built by the associated
<code>SimpleAttributeDefinitionBuilder</code>. This is used for attributes whose
values are analogous to java primitives, <code>String</code> or byte[]. For
collections, there are various subclasses of <code>ListAttributeDefinition</code>
and <code>MapAttributeDefinition</code>. All have a <code>Builder</code> inner class. For
complex attributes, i.e. those with a fixed set of fully defined fields,
use <code>ObjectTypeAttributeDefinition</code>. (Each field in the complex type is
itself specified by an <code>AttributeDefinition</code>.) Finally there&#8217;s
<code>ObjectListAttributeDefinition</code> and <code>ObjectMapAttributeDefinition</code> for
lists whose elements are complex types and maps whose values are complex
types respectively.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of creating a simple attribute definition with extra
validation of the range of allowed values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">static</span> <span class="directive">final</span> AttributeDefinition QUEUE_LENGTH = <span class="keyword">new</span> SimpleAttributeDefinitionBuilder(<span class="string"><span class="delimiter">&quot;</span><span class="content">queue-length</span><span class="delimiter">&quot;</span></span>, ModelType.INT)
                .setRequired(<span class="predefined-constant">true</span>)
                .setAllowExpression(<span class="predefined-constant">true</span>)
                .setValidator(<span class="keyword">new</span> IntRangeValidator(<span class="integer">1</span>, <span class="predefined-type">Integer</span>.MAX_VALUE))
                .setRestartAllServices() <span class="comment">// means modification after resource add puts the server in reload-required</span>
                .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Via a bit of dark magic, the kernel knows that the <code>IntRangeValidator</code>
defined here is a reliable source of information on min and max values
for the attribute, so when creating the <code>read-resource-description</code>
output for the attribute it will use it and output <code>min</code> and <code>max</code>
metadata. For STRING attributes, <code>StringLengthValidator</code> can also be
used, and the kernel will see this and provide <code>min-length</code> and
<code>max-length</code> metadata. In both cases the kernel is checking for the
presence of a <code>MinMaxValidator</code> and if found it provides the appropriate
metadata based on the type of the attribute.</p>
</div>
<div class="paragraph">
<p>Use <code>EnumValidator</code> to restrict a STRING attribute&#8217;s values to a set of
legal values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="directive">static</span> <span class="directive">final</span> SimpleAttributeDefinition TIME_UNIT = <span class="keyword">new</span> SimpleAttributeDefinitionBuilder(<span class="string"><span class="delimiter">&quot;</span><span class="content">unit</span><span class="delimiter">&quot;</span></span>, ModelType.STRING)
            .setRequired(<span class="predefined-constant">true</span>)
            .setAllowExpression(<span class="predefined-constant">true</span>)
            .setValidator(<span class="keyword">new</span> EnumValidator&lt;<span class="predefined-type">TimeUnit</span>&gt;(<span class="predefined-type">TimeUnit</span>.class))
            .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>EnumValidator</code> is an implementation of <code>AllowedValuesValidator</code> that
works with Java enums. You can use other implementations or write your
own to do other types of restriction to certain values.</p>
</div>
<div class="paragraph">
<p>Via a bit of dark magic similar to what is done with <code>MinMaxValidator</code>,
the kernel recognizes the presence of an <code>AllowedValuesValidator</code> and
uses it to seed the <code>allowed-values</code> metadata in
<code>read-resource-description</code> output.</p>
</div>
<div class="sect3">
<h4 id="key-uses-of-attributedefinition"><a class="anchor" href="#key-uses-of-attributedefinition"></a>5.5.1. Key Uses of AttributeDefinition</h4>
<div class="paragraph">
<p>Your <code>AttributeDefinition</code> instances will be some of the most commonly
used objects in your extension code. Following are the most typical
uses. In each of these examples assume there is a
<code>SimpleAttributeDefinition</code> stored in a constant FOO_AD that is
available to the code. Typically FOO_AD would be a constant in the
relevant <code>ResourceDefinition</code> implementation class. Assume FOO_AD
represents an INT attribute.</p>
</div>
<div class="paragraph">
<p>Note that for all of these cases except for "Use in Extracting Data from
the Configuration Model for Use in Runtime Services" there may be
utility code that handles this for you. For example
<code>PersistentResourceXMLParser</code> can handle the XML cases, and
<code>AbstractAddStepHandler</code> can handle the "Use in Storing Data Provided by
the User to the Configuration Model" case.</p>
</div>
<div class="sect4">
<h5 id="use-in-xml-parsing"><a class="anchor" href="#use-in-xml-parsing"></a>Use in XML Parsing</h5>
<div class="paragraph">
<p>Here we have your extension&#8217;s implementation of
<code>XMLElementReader&lt;List&lt;ModelNode&gt;&gt;</code> that is being used to parse the xml
for your subsystem and add <code>ModelNode</code> operations to the list that will
be used to boot the server.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> readElement(<span class="directive">final</span> XMLExtendedStreamReader reader, <span class="directive">final</span> <span class="predefined-type">List</span>&lt;ModelNode&gt; operationList) <span class="directive">throws</span> XMLStreamException {
        <span class="comment">// Create a node for the op to add our subsystem</span>
        ModelNode addOp = <span class="keyword">new</span> ModelNode();
        addOp.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">address</span><span class="delimiter">&quot;</span></span>).add(<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystem</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">mysubsystem</span><span class="delimiter">&quot;</span></span>);
        addOp.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">operation</span><span class="delimiter">&quot;</span></span>).set(<span class="string"><span class="delimiter">&quot;</span><span class="content">add</span><span class="delimiter">&quot;</span></span>);
        operationList.add(addOp);
<span class="error"> </span>
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; reader.getAttributeCount(); i++) {
            <span class="directive">final</span> <span class="predefined-type">String</span> value = reader.getAttributeValue(i);
            <span class="directive">final</span> <span class="predefined-type">String</span> attribute = reader.getAttributeLocalName(i);
            <span class="keyword">if</span> (FOO_AD.getXmlName().equals(attribute) {
                FOO_AD.parseAndSetParameter(value, addOp, reader);
            } <span class="keyword">else</span> ....
        }
<span class="error"> </span>
        ... more parsing
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the parsing code has deliberately been abbreviated. The key
point is the <code>parseAndSetParameter</code> call. FOO_AD will validate the
<code>value</code> read from XML, throwing an XMLStreamException with a useful
message if invalid, including a reference to the current location of the
<code>reader</code>. If valid, <code>value</code> will be converted to a DMR <code>ModelNode</code> of
the appropriate type and stored as a parameter field of <code>addOp</code>. The
name of the parameter will be what <code>FOO_AD.getName()</code> returns.</p>
</div>
<div class="paragraph">
<p>If you use <code>PersistentResourceXMLParser</code> this parsing logic is handled
for you and you don&#8217;t need to write it yourself.</p>
</div>
</div>
<div class="sect4">
<h5 id="use-in-storing-data-provided-by-the-user-to-the-configuration-model"><a class="anchor" href="#use-in-storing-data-provided-by-the-user-to-the-configuration-model"></a>Use in Storing Data Provided by the User to the Configuration Model</h5>
<div class="paragraph">
<p>Here we illustrate code in an <code>OperationStepHandler</code> that extracts a
value from a user-provided <code>operation</code> and stores it in the internal
model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> execute(OperationContext context, ModelNode operation) <span class="directive">throws</span> OperationFailedException {
        <span class="comment">// Get the Resource targeted by this operation</span>
        Resource resource = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);
        ModelNode model = resource.getModel();
        <span class="comment">// Store the value of any 'foo' param to the model's 'foo' attribute</span>
        FOO_AD.validateAndSet(operation, model);
<span class="error"> </span>
        ... do other stuff
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the name implies <code>validateAndSet</code> will validate the value in
<code>operation</code> before setting it. A validation failure will result in an
<code>OperationFailedException</code> with an appropriate message, which the kernel
will use to provide a failure response to the user.</p>
</div>
<div class="paragraph">
<p>Note that <code>validateAndSet</code> will not perform expression resolution.
Expression resolution is not appropriate at this stage, when we are just
trying to store data to the persistent configuration model. However, it
will check for expressions and fail validation if found and FOO_AD
wasn&#8217;t built with <code>setAllowExpressions(true)</code>.</p>
</div>
<div class="paragraph">
<p>This work of storing data to the configuration model is usually done in
handlers for the <code>add</code> and <code>write-attribute</code> operations. If you base
your handler implementations on the standard classes provided by WildFly
Core, this part of the work will be handled for you.</p>
</div>
</div>
<div class="sect4">
<h5 id="use-in-extracting-data-from-the-configuration-model-for-use-in-runtime-services"><a class="anchor" href="#use-in-extracting-data-from-the-configuration-model-for-use-in-runtime-services"></a>Use in Extracting Data from the Configuration Model for Use in</h5>
<div class="paragraph">
<p>Runtime Services</p>
</div>
<div class="paragraph">
<p>This is the example you are most likely to use in your code, as this is
where data needs to be extracted from the configuration model and passed
to your runtime services. What your services need is custom, so there&#8217;s
no utility code we provide.</p>
</div>
<div class="paragraph">
<p>Assume as part of <code>&#8230;&#8203; do other stuff</code> in the last example that your
handler adds a step to do further work once operation execution proceeds
to RUNTIME state (see Operation Execution and the <code>OperationContext</code> for
more on what this means):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">        context.addStep(<span class="keyword">new</span> OperationStepHandler() {
            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> execute(OperationContext context, ModelNode operation) <span class="directive">throws</span> OperationFailedException {
<span class="error"> </span>
                <span class="comment">// Get the Resource targetted by this operation</span>
                Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS);
                ModelNode model = resource.getModel();
                <span class="comment">// Extract the value of the 'foo' attribute from the model</span>
                <span class="type">int</span> foo = FOO_AD.resolveModelAttribute(context, model).asInt();

                Service&lt;XyZ&gt; service = <span class="keyword">new</span> MyService(foo);
<span class="error"> </span>
                ... do other stuff, like install <span class="string"><span class="delimiter">'</span><span class="content">service</span><span class="delimiter">'</span></span> with MSC
    }
        }, Stage.RUNTIME);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use <code>resolveModelAttribute</code> to extract data from the model. It does a
number of things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>reads the value from the model</p>
</li>
<li>
<p>if it&#8217;s an expression and expressions are supported, resolves it</p>
</li>
<li>
<p>if it&#8217;s undefined and undefined is allowed but FOO_AD was configured
with a default value, uses the default value</p>
</li>
<li>
<p>validates the result of that (which is how we check that expressions
resolve to legal values), throwing OperationFailedException with a
useful message if invalid</p>
</li>
<li>
<p>returns that as a <code>ModelNode</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If when you built FOO_AD you configured it such that the user must
provide a value, or if you configured it with a default value, then you
know the return value of <code>resolveModelAttribute</code> will be a defined
<code>ModelNode</code>. Hence you can safely perform type conversions with it, as
we do in the example above with the call to <code>asInt()</code>. If FOO_AD was
configured such that it&#8217;s possible that the attribute won&#8217;t have a
defined value, you need to guard against that, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    ModelNode node = FOO_AD.resolveModelAttribute(context, model);
    <span class="predefined-type">Integer</span> foo = node.isDefined() ? node.asInt() : <span class="predefined-constant">null</span>;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="use-in-marshaling-configuration-model-data-to-xml"><a class="anchor" href="#use-in-marshaling-configuration-model-data-to-xml"></a>Use in Marshaling Configuration Model Data to XML</h5>
<div class="paragraph">
<p>Your <code>Extension</code> must register an
<code>XMLElementWriter&lt;SubsystemMarshallingContext&gt;</code> for each subsystem. This
is used to marshal the subsystem&#8217;s configuration to XML. If you don&#8217;t
use <code>PersistentResourceXMLParser</code> for this you&#8217;ll need to write your own
marshaling code, and <code>AttributeDefinition</code> will be used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) <span class="directive">throws</span> XMLStreamException {
        context.startSubsystemElement(Namespace.CURRENT.getUriString(), <span class="predefined-constant">false</span>);
<span class="error"> </span>
        ModelNode subsystemModel = context.getModelNode();
        <span class="comment">// we persist foo as an xml attribute</span>
        FOO_AD.marshalAsAttribute(subsystemModel, writer);
        <span class="comment">// We also have a different attribute that we marshal as an element</span>
        BAR_AD.marshalAsElement(subsystemModel, writer);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>SubsystemMarshallingContext</code> provides a <code>ModelNode</code> that represents
the entire resource tree for the subsystem (including child resources).
Your <code>XMLElementWriter</code> should walk through that model, using
<code>marshalAsAttribute</code> or <code>marshalAsElement</code> to write the attributes in
each resource. If the model includes child node trees that represent
child resources, create child xml elements for those and continue down
the tree.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="operationdefinition-and-operationstephandler-interfaces"><a class="anchor" href="#operationdefinition-and-operationstephandler-interfaces"></a>5.6. OperationDefinition and OperationStepHandler Interfaces</h3>
<div class="paragraph">
<p><code>OperationDefinition</code> defines an operation, particularly its name, its
parameters and the details of any result value, with
<code>AttributeDefinition</code> instances used to define the parameters and result
details. The <code>OperationDefinition</code> is used to generate the
<code>read-operation-description</code> output for the operation, and in some cases
is also used by the kernel to decide details as to how to execute the
operation.</p>
</div>
<div class="paragraph">
<p>Typically <code>SimpleOperationDefinitionBuilder</code> is used to create an
<code>OperationDefinition</code>. Usually you only need to create an
<code>OperationDefinition</code> for custom operations. For the common <code>add</code> and
<code>remove</code> operations, if you provide minimal information about your
handlers to your <code>SimpleResourceDefinition</code> implementation via the
<code>Parameters</code> object passed to its constructor, then
<code>SimpleResourceDefinition</code> can generate a correct <code>OperationDefinition</code>
for those operations.</p>
</div>
<div class="paragraph">
<p>The <code>OperationStepHandler</code> is what contains the actual logic for doing
what the user requests when they invoke an operation. As its name
implies, each OSH is responsible for doing one step in the overall
sequence of things necessary to give effect to what the user requested.
One of the things an OSH can do is add other steps, with the result that
an overall operation can involve a great number of OSHs executing. (See
Operation Execution and the <code>OperationContext</code> for more on this.)</p>
</div>
<div class="paragraph">
<p>Each OSH is provided in its <code>execute</code> method with a reference to the
<code>OperationContext</code> that is controlling the overall operation, plus an
<code>operation</code> <code>ModelNode</code> that represents the operation that particular
OSH is being asked to deal with. The <code>operation</code> node will be of
<code>ModelType.OBJECT</code> with the following key/value pairs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a key named <code>operation</code> with a value of <code>ModelType.STRING</code> that
represents the name of the operation. Typically an OSH doesn&#8217;t care
about this information as it is written for an operation with a
particular name and will only be invoked for that operation.</p>
</li>
<li>
<p>a key named <code>address</code> with a value of <code>ModelType.LIST</code> with list
elements of <code>ModelType.PROPERTY</code>. This value represents the address of
the resource the operation targets. If this key is not present or the
value is undefined or an empty list, the target is the root resource.
Typically an OSH doesn&#8217;t care about this information as it can more
efficiently get the address from the <code>OperationContext</code> via its
<code>getCurrentAddress()</code> method.</p>
</li>
<li>
<p>other key/value pairs that represent parameters to the operation, with
the key the name of the parameter. This is the main information an OSH
would want from the <code>operation</code> node.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are a variety of situations where extension code will instantiate
an <code>OperationStepHandler</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p>When registering a writable attribute with a
<code>ManagementResourceRegistration</code> (typically in an implementation of
<code>ResourceDefinition.registerAttributes</code>), an OSH must be provided to
handle the <code>write-attribute</code> operation.</p>
</li>
<li>
<p>When registering a read-only or read-write attribute that needs
special handling of the <code>read-attribute</code> operation, an OSH must be
provided.</p>
</li>
<li>
<p>When registering a metric attribute, an OSH must be provided to handle
the <code>read-attribute</code> operation.</p>
</li>
<li>
<p>Most resources need OSHs created for the <code>add</code> and <code>remove</code>
operations. These are passed to the <code>Parameters</code> object given to the
<code>SimpleResourceDefinition</code> constructor, for use by the
<code>SimpleResourceDefinition</code> in its implementation of the
<code>registerOperations</code> method.</p>
</li>
<li>
<p>If your resource has custom operations, you will instantiate them to
register with a <code>ManagementResourceRegistration</code>, typically in an
implementation of <code>ResourceDefinition.registerOperations</code></p>
</li>
<li>
<p>If an OSH needs to tell the <code>OperationContext</code> to add additional steps
to do further handling, the OSH will create another OSH to execute that
step. This second OSH is typically an inner class of the first OSH.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="operation-execution-and-the-operationcontext"><a class="anchor" href="#operation-execution-and-the-operationcontext"></a>5.7. Operation Execution and the OperationContext</h3>
<div class="paragraph">
<p>When the <code>ModelController</code> at the heart of the WildFly Core management
layer handles a request to execute an operation, it instantiates an
implementation of the <code>OperationContext</code> interface to do the work. The
<code>OperationContext</code> is configured with an initial list of operation steps
it must execute. This is done in one of two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>During boot, multiple steps are configured, one for each operation in
the list generated by the parser of the xml configuration file. For each
operation, the <code>ModelController</code> finds the
<code>ManagementResourceRegistration</code> that matches the address of the
operation and finds the <code>OperationStepHandler</code> registered with that MRR
for the operation&#8217;s name. A step is added to the <code>OperationContext</code> for
each operation by providing the operation <code>ModelNode</code> itself, plus the
<code>OperationStepHandler</code>.</p>
</li>
<li>
<p>After boot, any management request involves only a single operation,
so only a single step is added. (Note that a <code>composite</code> operation is
still a single operation; it&#8217;s just one that internally executes via
multiple steps.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ModelController</code> then asks the <code>OperationContext</code> to execute the
operation.</p>
</div>
<div class="paragraph">
<p>The <code>OperationContext</code> acts as both the engine for operation execution,
and as the interface provided to <code>OperationStepHandler</code> implementations
to let them interact with the rest of the system.</p>
</div>
<div class="sect3">
<h4 id="execution-process"><a class="anchor" href="#execution-process"></a>5.7.1. Execution Process</h4>
<div class="paragraph">
<p>Operation execution proceeds via execution by the <code>OperationContext</code> of
a series of "steps" with an <code>OperationStepHandler</code> doing the key work
for each step. As mentioned above, during boot the OC is initially
configured with a number of steps, but post boot operations involve only
a single step initially. But even a post-boot operation can end up
involving numerous steps before completion. In the case of a
<code>/:read-resource(recursive=true)</code> operation, thousands of steps might
execute. This is possible because one of the key things an
<code>OperationStepHandler</code> can do is ask the <code>OperationContext</code> to add
additional steps to execute later.</p>
</div>
<div class="paragraph">
<p>Execution proceeds via a series of "stages", with a queue of steps
maintained for each stage. An <code>OperationStepHandler</code> can tell the
<code>OperationContext</code> to add a step for any stage equal to or later than
the currently executing stage. The instruction can either be to add the
step to the head of the queue for the stage or to place it at the end of
the stage&#8217;s queue.</p>
</div>
<div class="paragraph">
<p>Execution of a stage continues until there are no longer any steps in
the stage&#8217;s queue. Then an internal transition task can execute, and the
processing of the next stage&#8217;s steps begins.</p>
</div>
<div class="paragraph">
<p>Here is some brief information about each stage:</p>
</div>
<div class="sect4">
<h5 id="stage.model"><a class="anchor" href="#stage.model"></a>Stage.MODEL</h5>
<div class="paragraph">
<p>This stage is concerned with interacting with the persistent
configuration model, either making changes to it or reading information
from it. Handlers for this stage should not make changes to the runtime,
and handlers running after this stage should not make changes to the
persistent configuration model.</p>
</div>
<div class="paragraph">
<p>If any step fails during this stage, the operation will automatically
roll back. Rollback of MODEL stage failures cannot be turned off.
Rollback during boot results in abort of the process start.</p>
</div>
<div class="paragraph">
<p>The initial step or steps added to the <code>OperationContext</code> by the
<code>ModelController</code> all execute in Stage.MODEL. This means that all
<code>OperationStepHandler</code> instances your extension registers with a
<code>ManagementResourceRegistration</code> must be designed for execution in
<code>Stage.MODEL</code>. If you need work done in later stages your <code>Stage.MODEL</code>
handler must add a step for that work.</p>
</div>
<div class="paragraph">
<p>When this stage completes, the <code>OperationContext</code> internally performs
model validation work before proceeding on to the next stage. Validation
failures will result in rollback.</p>
</div>
</div>
<div class="sect4">
<h5 id="stage.runtime"><a class="anchor" href="#stage.runtime"></a>Stage.RUNTIME</h5>
<div class="paragraph">
<p>This stage is concerned with interacting with the server runtime, either
reading from it or modifying it (e.g. installing or removing services or
updating their configuration.) By the time this stage begins, all model
changes are complete and model validity has been checked. So typically
handlers in this stage read their inputs from the model, not from the
original <code>operation</code> <code>ModelNode</code> provided by the user.</p>
</div>
<div class="paragraph">
<p>Most <code>OperationStepHandler</code> logic written by extension authors will be
for Stage.RUNTIME. The vast majority of Stage.MODEL handling can best be
performed by the base handler classes WildFly Core provides in its
<code>controller</code> module. (See below for more on those.)</p>
</div>
<div class="paragraph">
<p>During boot failures in <code>Stage.RUNTIME</code> will not trigger rollback and
abort of the server boot. After boot, by default failures here will
trigger rollback, but users can prevent that by using the
<code>rollback-on-runtime-failure</code> header. However, a RuntimeException thrown
by a handler will trigger rollback.</p>
</div>
<div class="paragraph">
<p>At the end of <code>Stage.RUNTIME</code>, the <code>OperationContext</code> blocks waiting for
the MSC service container to stabilize (i.e. for all services to have
reached a rest state) before moving on to the next stage.</p>
</div>
</div>
<div class="sect4">
<h5 id="stage.verify"><a class="anchor" href="#stage.verify"></a>Stage.VERIFY</h5>
<div class="paragraph">
<p>Service container verification work is performed in this stage, checking
that any MSC changes made in <code>Stage.RUNTIME</code> had the expected effect.
Typically extension authors do not add any steps in this stage, as the
steps automatically added by the <code>OperationContext</code> itself are all that
are needed. You can add a step here though if you have an unusual use
case where you need to verify something after MSC has stabilized.</p>
</div>
<div class="paragraph">
<p>Handlers in this stage should not make any further runtime changes;
their purpose is simply to do verification work and fail the operation
if verification is unsuccessful.</p>
</div>
<div class="paragraph">
<p>During boot failures in <code>Stage.VERIFY</code> will not trigger rollback and
abort of the server boot. After boot, by default failures here will
trigger rollback, but users can prevent that by using the
<code>rollback-on-runtime-failure</code> header. However, a RuntimeException thrown
by a handler will trigger rollback.</p>
</div>
<div class="paragraph">
<p>There is no special transition work at the end of this stage.</p>
</div>
</div>
<div class="sect4">
<h5 id="stage.domain"><a class="anchor" href="#stage.domain"></a>Stage.DOMAIN</h5>
<div class="paragraph">
<p>Extension authors should not add steps in this stage; it is only for use
by the kernel.</p>
</div>
<div class="paragraph">
<p>Steps needed to execute rollout across the domain of an operation that
affects multiple processes in a managed domain run here. This stage is
only run on Host Contoller processes, never on servers.</p>
</div>
</div>
<div class="sect4">
<h5 id="stage.done-and-resulthandler-rollbackhandler-execution"><a class="anchor" href="#stage.done-and-resulthandler-rollbackhandler-execution"></a>Stage.DONE and ResultHandler / RollbackHandler Execution</h5>
<div class="paragraph">
<p>This stage doesn&#8217;t maintain a queue of steps; no <code>OperationStepHandler</code>
executes here. What does happen here is persistence of any configuration
changes to the xml file and commit or rollback of changes affecting
multiple processes in a managed domain.</p>
</div>
<div class="paragraph">
<p>While no <code>OperationStepHandler</code> executes in this stage, following
persistence and transaction commit all <code>ResultHandler</code> or
<code>RollbackHandler</code> callbacks registered with the <code>OperationContext</code> by
the steps that executed are invoked. This is done in the reverse order
of step execution, so the callback for the last step to run is the first
to be executed. The most common thing for a callback to do is to respond
to a rollback by doing whatever is necessary to reverse changes made in
<code>Stage.RUNTIME</code>. (No reversal of <code>Stage.MODEL</code> changes is needed,
because if an operation rolls back the updated model produced by the
operation is simply never published and is discarded.)</p>
</div>
</div>
<div class="sect4">
<h5 id="tips-about-adding-steps"><a class="anchor" href="#tips-about-adding-steps"></a>Tips About Adding Steps</h5>
<div class="paragraph">
<p>Here are some useful tips about how to add steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add a step to the head of the current stage&#8217;s queue if you want it to
execute next, prior to any other steps. Typically you would use this
technique if you are trying to decompose some complex work into pieces,
with reusable logic handling each piece. There would be an
<code>OperationStepHandler</code> for each part of the work, added to the head of
the queue in the correct sequence. This would be a pretty advanced use
case for an extension author but is quite common in the handlers
provided by the kernel.</p>
</li>
<li>
<p>Add a step to the end of the queue if either you don&#8217;t care when it
executes or if you do care and want to be sure it executes after any
already registered steps.</p>
<div class="ulist">
<ul>
<li>
<p>A very common example of this is a <code>Stage.MODEL</code> handler adding a
step for its associated <code>Stage.RUNTIME</code> work. If there are multiple
model steps that will execute (e.g. at boot or as part of handling a
<code>composite</code>), each will want to add a runtime step, and likely the best
order for those runtime steps is the same as the order of the model
steps. So if each adds its runtime step at the end, the desired result
will be achieved.</p>
</li>
<li>
<p>A more sophisticated but important scenario is when a step may or may
not be executing as part of a larger set of steps, i.e. it may be one
step in a <code>composite</code> or it may not. There is no way for the handler to
know. But it can assume that if it is part of a composite, the steps for
the other operations in the composite <strong>are already registered in the
queue</strong>. (The handler for the <code>composite</code> op guarantees this.) So, if it
wants to do some work (say validation of the relationship between
different attributes or resources) the input to which may be affected by
possible other already registered steps, instead of doing that work
itself, it should register a different step at the <strong>end</strong> of the queue
and have that step do the work. This will ensure that when the
validation step runs, the other steps in the <code>composite</code> will have had a
chance to do their work. <strong>Rule of thumb: always doing any extra
validation work in an added step.</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="passing-data-to-an-added-step"><a class="anchor" href="#passing-data-to-an-added-step"></a>Passing Data to an Added Step</h6>
<div class="paragraph">
<p>Often a handler author will want to share state between the handler for
a step it adds and the handler that added it. There are a number of ways
this can be done:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Very often the <code>OperationStepHandler</code> for the added class is an inner
class of the handler that adds it. So here sharing state is easily done
using final variables in the outer class.</p>
</li>
<li>
<p>The handler for the added step can accept values passed to its
constructor which can serve as shared state.</p>
</li>
<li>
<p>The <code>OperationContext</code> includes an Attachment API which allows
arbitary data to be attached to the context and retrieved by any handler
that has access to the attachment key.</p>
</li>
<li>
<p>The <code>OperationContext.addStep</code> methods include overloaded variants
where the caller can pass in an <code>operation</code> <code>ModelNode</code> that will in
turn be passed to the <code>execute</code> method of the handler for the added
step. So, state can be passed via this <code>ModelNode</code>. It&#8217;s important to
remember though that the <code>address</code> field of the <code>operation</code> will govern
what the <code>OperationContext</code> sees as the target of operation when that
added step&#8217;s handler executes.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="controlling-output-from-an-added-step"><a class="anchor" href="#controlling-output-from-an-added-step"></a>Controlling Output from an Added Step</h6>
<div class="paragraph">
<p>When an <code>OperationStepHandler</code> wants to report an operation result, it
calls the <code>OperationContext.getResult()</code> method and manipulates the
returned <code>ModelNode</code>. Similarly for failure messages it can call
<code>OperationContext.getFailureDescription()</code>. The usual assumption when
such a call is made is that the result or failure description being
modified is the one at the root of the response to the end user. But
this is not necessarily the case.</p>
</div>
<div class="paragraph">
<p>When an <code>OperationStepHandler</code> adds a step it can use one of the
overloaded <code>OperationContext.addStep</code> variants that takes a <code>response</code>
<code>ModelNode</code> parameter. If it does, whatever <code>ModelNode</code> it passes in
will be what is updated as a result of <code>OperationContext.getResult()</code>
and <code>OperationContext.getFailureDescription()</code> calls by the step&#8217;s
handler. This node does not need to be one that is directly associated
with the response to the user.</p>
</div>
<div class="paragraph">
<p>How then does the handler that adds a step in this manner make use of
whatever results the added step produces, since the added step will not
run until the adding step completes execution? There are a couple of
ways this can be done.</p>
</div>
<div class="paragraph">
<p>The first is to add yet another step, and provide it a reference to the
<code>response</code> node used by the second step. It will execute after the
second step and can read its response and use it in formulating its own
response.</p>
</div>
<div class="paragraph">
<p>The second way involves using a <code>ResultHandler</code>. The <code>ResultHandler</code> for
a step will execute <strong>after</strong> any step that it adds executes. And, it is
legal for a <code>ResultHandler</code> to manipulate the "result" value for an
operation, or its "failure-description" in case of failure. So, the
handler that adds a step can provide to its <code>ResultHandler</code> a reference
to the <code>response</code> node it passed to <code>addStep</code>, and the <code>ResultHandler</code>
can in turn and use its contents to manipulate its own response.</p>
</div>
<div class="paragraph">
<p>This kind of handling wouldn&#8217;t commonly be done by extension authors and
great care needs to be taken if it is done. It is often done in some of
the kernel handlers.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="operationstephandler-use-of-the-operationcontext"><a class="anchor" href="#operationstephandler-use-of-the-operationcontext"></a>5.7.2. OperationStepHandler use of the OperationContext</h4>
<div class="paragraph">
<p>All useful work an <code>OperationStepHandler</code> performs is done by invoking
methods on the <code>OperationContext</code>. The <code>OperationContext</code> interface is
extensively javadoced, so this section will just provide a brief partial
overview. The OSH can use the <code>OperationContext</code> to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Learn about the environment in which it is executing (
<code>getProcessType</code>, <code>getRunningMode</code>, <code>isBooting</code>, <code>getCurrentStage</code>,
<code>getCallEnvironment</code>, <code>getSecurityIdentity</code>, <code>isDefaultRequiresRuntime</code>,
<code>isNormalServer</code>)</p>
</li>
<li>
<p>Learn about the operation ( <code>getCurrentAddress</code>,
<code>getCurrentAddressValue</code>, <code>getAttachmentStream</code>,
<code>getAttachmentStreamCount</code>)</p>
</li>
<li>
<p>Read the <code>Resource</code> tree ( <code>readResource</code>, <code>readResourceFromRoot</code>,
<code>getOriginalRootResource</code>)</p>
</li>
<li>
<p>Manipulate the <code>Resource</code> tree ( <code>createResource</code>, <code>addResource</code>,
<code>readResourceForUpdate</code>, <code>removeResource</code>)</p>
</li>
<li>
<p>Read the resource type information ( <code>getResourceRegistration</code>,
<code>getRootResourceRegistration</code>)</p>
</li>
<li>
<p>Manipulate the resource type information (
<code>getResourceRegistrationForUpdate</code>)</p>
</li>
<li>
<p>Read the MSC service container ( <code>getServiceRegistry(false)</code>)</p>
</li>
<li>
<p>Manipulate the MSC service container ( <code>getServiceTarget</code>,
<code>getServiceRegistry(true)</code>, <code>removeService</code>)</p>
</li>
<li>
<p>Manipulate the process state ( <code>reloadRequired</code>,
<code>revertReloadRequired</code>, <code>restartRequired</code>, <code>revertRestartRequired</code></p>
</li>
<li>
<p>Resolve expressions ( <code>resolveExpressions</code>)</p>
</li>
<li>
<p>Manipulate the operation response ( <code>getResult</code>,
<code>getFailureDescription</code>, <code>attachResultStream</code>, <code>runtimeUpdateSkipped</code>)</p>
</li>
<li>
<p>Force operation rollback ( <code>setRollbackOnly</code>)</p>
</li>
<li>
<p>Add other steps ( <code>addStep</code>)</p>
</li>
<li>
<p>Share data with other steps ( <code>attach</code>, <code>attachIfAbsent</code>,
<code>getAttachment</code>, <code>detach</code>)</p>
</li>
<li>
<p>Work with capabilities (numerous methods)</p>
</li>
<li>
<p>Emit notifications ( <code>emit</code>)</p>
</li>
<li>
<p>Request a callback to a <code>ResultHandler</code> or <code>RollbackHandler</code> (
<code>completeStep</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="locking-and-change-visibility"><a class="anchor" href="#locking-and-change-visibility"></a>5.7.3. Locking and Change Visibility</h4>
<div class="paragraph">
<p>The <code>ModelController</code> and <code>OperationContext</code> work together to ensure
that only one operation at a time is modifying the state of the system.
This is done via an exclusive lock maintained by the <code>ModelController</code>.
Any operation that does not need to write never requests the lock and is
able to proceed without being blocked by an operation that holds the
lock (i.e. writes do not block reads.) If two operations wish to
concurrently write, one or the other will get the lock and the loser
will block waiting for the winner to complete and release the lock.</p>
</div>
<div class="paragraph">
<p>The <code>OperationContext</code> requests the exclusive lock the first time any of
the following occur:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A step calls one of its methods that indicates a wish to modify the
resource tree ( <code>createResource</code>, <code>addResource</code>,
<code>readResourceForUpdate</code>, <code>removeResource</code>)</p>
</li>
<li>
<p>A step calls one of its methods that indicates a wish to modify the
<code>ManagementResourceRegistration</code> tree (
<code>getResourceRegistrationForUpdate</code>)</p>
</li>
<li>
<p>A step calls one of its methods that indicates a desire to change MSC
services ( <code>getServiceTarget</code>, <code>removeService</code> or <code>getServiceRegistry</code>
with the <code>modify</code> param set to <code>true</code>)</p>
</li>
<li>
<p>A step calls one of its methods that manipulates the capability
registry (various)</p>
</li>
<li>
<p>A step explicitly requests the lock by calling the
<code>acquireControllerLock</code> method (doing this is discouraged)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The step that acquired the lock is tracked, and the lock is released
when the <code>ResultHandler</code> added by that step has executed. (If the step
doesn&#8217;t add a result handler, a default no-op one is automatically
added).</p>
</div>
<div class="paragraph">
<p>When an operation first expresses a desire to manipulate the <code>Resource</code>
tree or the capability registry, a private copy of the tree or registry
is created and thereafter the <code>OperationContext</code> works with that copy.
The copy is published back to the <code>ModelController</code> in <code>Stage.DONE</code> if
the operation commits. Until that happens any changes to the tree or
capability registry made by the operation are invisible to other
threads. If the operation does not commit, the private copies are simply
discarded.</p>
</div>
<div class="paragraph">
<p>However, the <code>OperationContext</code> does not make a private copy of the
<code>ManagementResourceRegistration</code> tree before manipulating it, nor is
there a private copy of the MSC service container. So, any changes made
by an operation to either of those are immediately visible to other
threads.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resource-interface"><a class="anchor" href="#resource-interface"></a>5.8. Resource Interface</h3>
<div class="paragraph">
<p>An instance of the <code>Resource</code> interface holds the state for a particular
instance of a type defined by a <code>ManagementResourceRegistration</code>.
Referring back to the analogy mentioned earlier the
<code>ManagementResourceRegistration</code> is analogous to a Java class while the
<code>Resource</code> is analogous to an instance of that class.</p>
</div>
<div class="paragraph">
<p>The <code>Resource</code> makes available state information, primarily</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Some descriptive metadata, such as its address, whether it is
runtime-only and whether it represents a proxy to a another primary
resource that resides on another process in a managed domain</p>
</li>
<li>
<p>A <code>ModelNode</code> of <code>ModelType.OBJECT</code> whose keys are the resource&#8217;s
attributes and whose values are the attribute values</p>
</li>
<li>
<p>Links to child resources such that the resources form a tree</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="creating-resources"><a class="anchor" href="#creating-resources"></a>5.8.1. Creating Resources</h4>
<div class="paragraph">
<p>Typically extensions create resources via <code>OperationStepHandler</code> calls
to the <code>OperationContext.createResource</code> method. However it is allowed
for handlers to use their own <code>Resource</code> implementations by
instantiating the resource and invoking <code>OperationContext.addResource</code>.
The <code>AbstractModelResource</code> class can be used as a base class.</p>
</div>
</div>
<div class="sect3">
<h4 id="runtime-only-and-synthetic-resources-and-the-placeholderresourceentry-class"><a class="anchor" href="#runtime-only-and-synthetic-resources-and-the-placeholderresourceentry-class"></a>5.8.2. Runtime-Only and Synthetic Resources and the PlaceholderResourceEntry Class</h4>
<div class="paragraph">
<p>A runtime-only resource is one whose state is not persisted to the xml
configuration file. Many runtime-only resources are also "synthetic"
meaning they are not added or removed as a result of user initiated
management operations. Rather these resources are "synthesized" in order
to allow users to use the management API to examine some aspect of the
internal state of the process. A good example of synthetic resources are
the resources in the <code>/core-service=platform-mbeans</code> branch of the
resource tree. There are resources there that represent various aspects
of the JVM (classloaders, memory pools, etc) but which resources are
present entirely depends on what the JVM is doing, not on any management
action. Another example are resources representing "core queues" in the
WildFly messaging and messaging-artemismq subsystems. Queues are created
as a result of activity in the message broker which may not involve
calls to the management API. But for each such queue a management
resource is available to allow management users to perform management
operations against the queue.</p>
</div>
<div class="paragraph">
<p>It is a requirement of execution of a management operation that the
<code>OperationContext</code> can navigate through the resource tree to a
<code>Resource</code> object located at the address specified. This requirement
holds true even for synthetic resources. How can this be handled, given
the fact these resources are not created in response to management
operations?</p>
</div>
<div class="paragraph">
<p>The trick involves using special implementations of <code>Resource</code>. Let&#8217;s
imagine a simple case where we have a parent resource which is fairly
normal (i.e. it holds persistent configuration and is added via a user&#8217;s
<code>add</code> operation) except for the fact that one of its child types
represents synthetic resources (e.g. message queues). How would this be
handled?</p>
</div>
<div class="paragraph">
<p>First, the parent resource would require a custom implementation of the
<code>Resource</code> interface. The <code>OperationStepHandler</code> for the <code>add</code> operation
would instantiate it, providing it with access to whatever API is needed
for it to work out what items exist for which a synthetic resource
should be made available (e.g. an API provided by the message broker
that provides access to its queues). The <code>add</code> handler would use the
<code>OperationContext.addResource</code> method to tie this custom resource into
the overall resource tree.</p>
</div>
<div class="paragraph">
<p>The custom <code>Resource</code> implementation would use special implementations
of the various methods that relate to accessing children. For all calls
that relate to the synthetic child type (e.g. core-queue) the custom
implementation would use whatever API call is needed to provide the
correct data for that child type (e.g. ask the message broker for the
names of queues).</p>
</div>
<div class="paragraph">
<p>A nice strategy for creating such a custom resource is to use
delegation. Use <code>Resource.Factory.create}()</code> to create a standard
resource. Then pass it to the constructor of your custom resource type
for use as a delegate. The custom resource type&#8217;s logic is focused on
the synthetic children; all other work it passes on to the delegate.</p>
</div>
<div class="paragraph">
<p>What about the synthetic resources themselves, i.e. the leaf nodes in
this part of the tree? These are created on the fly by the parent
resource in response to <code>getChild</code>, <code>requireChild</code>, <code>getChildren</code> and
<code>navigate</code> calls that target the synthetic resource type. These
created-on-the-fly resources can be very lightweight, since they store
no configuration model and have no children. The
<code>PlaceholderResourceEntry</code> class is perfect for this. It&#8217;s a very
lightweight <code>Resource</code> implementation with minimal logic that only
stores the final element of the resource&#8217;s address as state.</p>
</div>
<div class="paragraph">
<p>See <code>LoggingResource</code> in the WildFly Core logging subsystem for an
example of this kind of thing. Searching for other uses of
<code>PlaceholderResourceEntry</code> will show other examples.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="deploymentunitprocessor-interface"><a class="anchor" href="#deploymentunitprocessor-interface"></a>5.9. DeploymentUnitProcessor Interface</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="useful-classes-for-implementing-operationstephandler"><a class="anchor" href="#useful-classes-for-implementing-operationstephandler"></a>5.10. Useful classes for implementing OperationStepHandler</h3>
<div class="paragraph">
<p>The WildFly Core <code>controller</code> module includes a number of
<code>OperationStepHandler</code> implementations that in some cases you can use
directly, and that in other cases can serve as the base class for your
own handler implementation. In all of these a general goal is to
eliminate the need for your code to do anything in <code>Stage.MODEL</code> while
providing support for whatever is appropriate for <code>Stage.RUNTIME</code>.</p>
</div>
<div class="sect3">
<h4 id="add-handlers"><a class="anchor" href="#add-handlers"></a>5.10.1. Add Handlers</h4>
<div class="paragraph">
<p><code>AbstractAddStepHandler</code> is a base class for handlers for <code>add</code>
operations. There are a number of ways you can configure its behavior,
the most commonly used of which are to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Configure its behavior in <code>Stage.MODEL</code> by passing to its constructor
<code>AttributeDefinition</code> and <code>RuntimeCapability</code> instances for the
attributes and capabilities provided by the resource. The handler will
automatically validate the operation parameters whose names match the
provided attributes and store their values in the model of the newly
added <code>Resource</code>. It will also record the presence of the given
capabilities.</p>
</li>
<li>
<p>Control whether a <code>Stage.RUNTIME</code> step for the operation needs to be
added, by overriding the
<code>protected boolean requiresRuntime(OperationContext context)</code> method.
Doing this is atypical; the standard behavior in the base class is
appropriate for most cases.</p>
</li>
<li>
<p>Implement the primary logic of the <code>Stage.RUNTIME</code> step by overriding
the
<code>protected void performRuntime(final OperationContext context, final ModelNode operation, final Resource resource)</code>
method. This is typically the bulk of the code in an
<code>AbstractAddStepHandler</code> subclass. This is where you read data from the
<code>Resource</code> model and use it to do things like configure and install MSC
services.</p>
</li>
<li>
<p>Handle any unusual needs of any rollback of the <code>Stage.RUNTIME</code> step
by overriding
<code>protected void rollbackRuntime(OperationContext context, final ModelNode operation, final Resource resource)</code>.
Doing this is not typically needed, since if the rollback behavior
needed is simply to remove any MSC services installed in
<code>performRuntime</code>, the <code>OperationContext</code> will do this for you
automatically.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractBoottimeAddStepHandler</code> is a subclass of
<code>AbstractAddStepHandler</code> meant for use by <code>add</code> operations that should
only do their normal <code>Stage.RUNTIME</code> work in server, boot, with the
server being put in <code>reload-required</code> if executed later. Primarily this
is used for <code>add</code> operations that register <code>DeploymentUnitProcessor</code>
implementations, as this can only be done at boot.</p>
</div>
<div class="paragraph">
<p>Usage of <code>AbstractBoottimeAddStepHandler</code> is the same as for
<code>AbstractAddStepHandler</code> except that instead of overriding
<code>performRuntime</code> you override
<code>protected void performBoottime(OperationContext context, ModelNode operation, Resource resource)</code>.</p>
</div>
<div class="paragraph">
<p>A typical thing to do in <code>performBoottime</code> is to add a special step that
registers one or more <code>DeploymentUnitProcessor</code> s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> performBoottime(OperationContext context, ModelNode operation, <span class="directive">final</span> Resource resource)
            <span class="directive">throws</span> OperationFailedException {
<span class="error"> </span>
        context.addStep(<span class="keyword">new</span> AbstractDeploymentChainStep() {
            <span class="annotation">@Override</span>
            <span class="directive">protected</span> <span class="type">void</span> execute(DeploymentProcessorTarget processorTarget) {
<span class="error"> </span>
                processorTarget.addDeploymentProcessor(RequestControllerExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_GLOBAL_REQUEST_CONTROLLER, <span class="keyword">new</span> RequestControllerDeploymentUnitProcessor());
            }
        }, OperationContext.Stage.RUNTIME);

        ... do other things</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remove-handlers"><a class="anchor" href="#remove-handlers"></a>5.10.2. Remove Handlers</h4>
<div class="paragraph">
<p>TODO <code>AbstractRemoveStepHandler</code> <code>ServiceRemoveStepHandler</code></p>
</div>
</div>
<div class="sect3">
<h4 id="write-attribute-handlers"><a class="anchor" href="#write-attribute-handlers"></a>5.10.3. Write attribute handlers</h4>
<div class="paragraph">
<p>TODO <code>AbstractWriteAttributeHandler</code></p>
</div>
</div>
<div class="sect3">
<h4 id="reload-required-handlers"><a class="anchor" href="#reload-required-handlers"></a>5.10.4. Reload-required handlers</h4>
<div class="paragraph">
<p><code>ReloadRequiredAddStepHandler</code> <code>ReloadRequiredRemoveStepHandler</code>
<code>ReloadRequiredWriteAttributeHandler</code></p>
</div>
<div class="paragraph">
<p>Use these for cases where, post-boot, the change to the configuration
model made by the operation cannot be reflected in the runtime until the
process is reloaded. These handle the mechanics of recording the need
for reload and reverting it if the operation rolls back.</p>
</div>
</div>
<div class="sect3">
<h4 id="restart-parent-resource-handlers"><a class="anchor" href="#restart-parent-resource-handlers"></a>5.10.5. Restart Parent Resource Handlers</h4>
<div class="paragraph">
<p><code>RestartParentResourceAddHandler</code> <code>RestartParentResourceRemoveHandler</code>
<code>RestartParentWriteAttributeHandler</code></p>
</div>
<div class="paragraph">
<p>Use these in cases where a management resource doesn&#8217;t directly control
any runtime services, but instead simply represents a chunk of
configuration that a parent resource uses to configure services it
installs. (Really, this kind of situation is now considered to be a poor
management API design and is discouraged. Instead of using child
resources for configuration chunks, complex attributes on the parent
resource should be used.)</p>
</div>
<div class="paragraph">
<p>These handlers help you deal with the mechanics of the fact that,
post-boot, any change to the child resource likely requires a restart of
the service provided by the parent.</p>
</div>
</div>
<div class="sect3">
<h4 id="model-only-handlers"><a class="anchor" href="#model-only-handlers"></a>5.10.6. Model Only Handlers</h4>
<div class="paragraph">
<p><code>ModelOnlyAddStepHandler</code> <code>ModelOnlyRemoveStepHandler</code>
<code>ModelOnlyWriteAttributeHandler</code></p>
</div>
<div class="paragraph">
<p>Use these for cases where the operation never affects the runtime, even
at boot. All it does is update the configuration model. In most cases
such a thing would be odd. These are primarily useful for legacy
subsystems that are no longer usable on current version servers and thus
will never do anything in the runtime. However, current version Domain
Controllers must be able to understand the subsystem&#8217;s configuration
model to allow them to manage older Host Controllers running previous
versions where the subsystem is still usable by servers. So these
handlers allow the DC to maintain the configuration model for the
subsystem.</p>
</div>
</div>
<div class="sect3">
<h4 id="misc"><a class="anchor" href="#misc"></a>5.10.7. Misc</h4>
<div class="paragraph">
<p><code>AbstractRuntimeOnlyHandler</code> is used for custom operations that don&#8217;t
involve the configuration model. Create a subclass and implement the
<code>protected abstract void executeRuntimeStep(OperationContext context, ModelNode operation)</code>
method. The superclass takes care of adding a <code>Stage.RUNTIME</code> step that
calls your method.</p>
</div>
<div class="paragraph">
<p><code>ReadResourceNameOperationStepHandler</code> is for cases where a resource
type includes a 'name' attribute whose value is simply the value of the
last element in the resource&#8217;s address. There is no need to store the
value of such an attribute in the resource&#8217;s model, since it can always
be determined from the resource address. But, if the value is not stored
in the resource model, when the attribute is registered with
<code>ManagementResourceRegistration.registerReadAttribute</code> an
<code>OperationStepHandler</code> to handle the <code>read-attribute</code> operation must be
provided. Use <code>ReadResourceNameOperationStepHandler</code> for this. (Note
that including such an attribute in your management API is considered to
be poor practice as it&#8217;s just redundant data.)</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="WildFly_JNDI_Implementation"><a class="anchor" href="#WildFly_JNDI_Implementation"></a>6. WildFly JNDI Implementation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="introduction"><a class="anchor" href="#introduction"></a>6.1. Introduction</h3>
<div class="paragraph">
<p>This page proposes a reworked WildFly JNDI implementation, and
new/updated APIs for WildFly subsystem and EE deployment processors
developers to bind new resources easier.</p>
</div>
<div class="paragraph">
<p>To support discussion in the community, the content includes a big focus
on comparing WildFly 29 JNDI implementation with the new proposal, and
should later evolve to the prime guide for WildFly developers needing to
interact with JNDI at subsystem level.</p>
</div>
</div>
<div class="sect2">
<h3 id="architecture"><a class="anchor" href="#architecture"></a>6.2. Architecture</h3>
<div class="paragraph">
<p>WildFly relies on MSC to provide the data source for the JNDI tree. Each
resource bound in JNDI is stored in a MSC service (BinderService), and
such services are installed as children of subsystem/deployment
services, for an automatically unbound as consequence of uninstall of
the parent services.</p>
</div>
<div class="paragraph">
<p>Since there is the need to know what entries are bound, and MSC does not
provides that, there is also the (ServiceBased)NamingStore concept,
which internally manage the set of service names bound. There are
multiple naming stores in every WildFly instance, serving different JNDI
namespaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>java:comp - the standard EE namespace for entries scoped to a specific
component, such as an Jakarta Enterprise Beans</p>
</li>
<li>
<p>java:module - the standard EE namespace for entries scoped to specific
module, such as an Jakarta Enterprise Beans jar, and shared by all components in it</p>
</li>
<li>
<p>java:app - the standard EE namespace for entries scoped to a specific
application, i.e. EAR, and shared by all modules in it</p>
</li>
<li>
<p>java:global - the standard EE namespace for entries shared by all
deployments</p>
</li>
<li>
<p>java:jboss - a proprietary namespace "global" namespace</p>
</li>
<li>
<p>java:jboss/exported - a proprietary "global" namespace which entries
are exposed to remote JNDI</p>
</li>
<li>
<p>java: - any entries not in the other namespaces</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One particular implementation choice, to save resources, is that JNDI
contexts by default are not bound, the naming stores will search for any
entry bound with a name that is a child of the context name, if found
then its assumed the context exists.</p>
</div>
<div class="paragraph">
<p>The reworked implementation introduces shared/global java:comp,
java:module and java:app namespaces. Any entry bound on these will
automatically be available to every EE deployment scoped instance of
these namespaces, what should result in a significant reduction of
binder services, and also of EE deployment processors. Also, the Naming
subsystem may now configure bind on these shared contexts, and these
contexts will be available when there is no EE component in the
invocation, which means that entries such as java:comp/DefaultDatasource
will always be available.</p>
</div>
</div>
<div class="sect2">
<h3 id="binding-apis"><a class="anchor" href="#binding-apis"></a>6.3. Binding APIs</h3>
<div class="paragraph">
<p>WildFly Naming subsystem exposes high level APIs to bind new JNDI
resources, there is no need to deal with the low level BinderService
type anymore.</p>
</div>
<div class="sect3">
<h4 id="subsystem"><a class="anchor" href="#subsystem"></a>6.3.1. Subsystem</h4>
<div class="paragraph">
<p>At the lowest level a JNDI entry is bound by installing a BinderService
to a ServiceTarget:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="error"> </span>
   <span class="comment">/**
     * Binds a new entry to JNDI.
     * @param serviceTarget the binder service's target
     * @param name the new JNDI entry's name
     * @param value the new JNDI entry's value
     */</span>
    <span class="directive">private</span> ServiceController&lt;?&gt; bind(ServiceTarget serviceTarget, <span class="predefined-type">String</span> name, <span class="predefined-type">Object</span> value) {
       <span class="error"> </span>
 <span class="comment">// the bind info object provides MSC service names to use when creating the binder service</span>
        <span class="directive">final</span> ContextNames.BindInfo bindInfo = ContextNames.bindInfoFor(name);
        <span class="directive">final</span> BinderService binderService = <span class="keyword">new</span> BinderService(bindInfo.getBindName());
       <span class="error"> </span>
 <span class="comment">// the entry's value is provided by a managed reference factory,</span>
        <span class="comment">// since the value may need to be obtained on lookup (e.g. EJB reference)</span>
        <span class="directive">final</span> ManagedReferenceFactory managedReferenceFactory = <span class="keyword">new</span> ImmediateManagedReferenceFactory(value);
       <span class="error"> </span>
 <span class="keyword">return</span> serviceTarget
                <span class="comment">// add binder service to specified target</span>
                .addService(bindInfo.getBinderServiceName(), binderService)
                <span class="comment">// when started the service will be injected with the factory</span>
                .addInjection(binderService.getManagedObjectInjector(), managedReferenceFactory)
                <span class="comment">// the binder service depends on the related naming store service,</span>
                <span class="comment">// and on start/stop will add/remove its service name</span>
                .addDependency(bindInfo.getParentContextServiceName(),
                        ServiceBasedNamingStore.class,
                        binderService.getNamingStoreInjector())
                .install();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>But the example above is the simplest usage possible, it may become
quite complicated if the entry&#8217;s value is not immediately available, for
instance it is a value in another MSC service, or is a value in another
JNDI entry. It&#8217;s also quite easy to introduce bugs when working with the
service names, or incorrectly assume that other MSC functionality, such
as alias names, may be used.</p>
</div>
<div class="paragraph">
<p>Using the new high level API, it&#8217;s as simple as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">// bind an immediate value</span>
ContextNames.bindInfoFor(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/ORB</span><span class="delimiter">&quot;</span></span>).bind(serviceTarget, <span class="local-variable">this</span>.orb);
<span class="error"> </span>
<span class="error"> </span>
<span class="comment">// bind value from another JNDI entry (an alias/linkref)</span>
ContextNames.bindInfoFor(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:global/x</span><span class="delimiter">&quot;</span></span>).bind(serviceTarget, <span class="keyword">new</span> JndiName(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:jboss/x</span><span class="delimiter">&quot;</span></span>));
<span class="error"> </span>
<span class="error"> </span>
<span class="comment">// bind value obtained from a MSC service</span>
ContextNames.bindInfoFor(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:global/z</span><span class="delimiter">&quot;</span></span>).bind(serviceTarget, serviceName);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there is the need to access the binder&#8217;s service builder, perhaps to
add a service verification handler or simply not install the binder
service right away:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">ContextNames.bindInfoFor(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/ORB</span><span class="delimiter">&quot;</span></span>).builder(serviceTarget, verificationHandler, ServiceController.Mode.ON_DEMAND).installService(<span class="local-variable">this</span>.orb);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ee-deployment"><a class="anchor" href="#ee-deployment"></a>6.3.2. EE Deployment</h4>
<div class="paragraph">
<p>With respect to EE deployments, the subsystem API should not be used,
since bindings may need to be discarded/overridden, thus a EE deployment
processor should add a new binding in the form of a
BindingConfiguration, to the EeModuleDescription or
ComponentDescription, depending if the bind is specific to a component
or not. An example of a deployment processor adding a binding:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ModuleNameBindingProcessor</span> <span class="directive">implements</span> DeploymentUnitProcessor {
<span class="error"> </span>
    <span class="comment">// jndi name objects are immutable</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> JndiName JNDI_NAME_java_module_ModuleName = <span class="keyword">new</span> JndiName(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:module/ModuleName</span><span class="delimiter">&quot;</span></span>);
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> deploy(DeploymentPhaseContext phaseContext) <span class="directive">throws</span> DeploymentUnitProcessingException {
       <span class="error"> </span>
 <span class="directive">final</span> DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();
        <span class="comment">// skip deployment unit if it's the top level EAR</span>
        <span class="keyword">if</span> (DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {
            <span class="keyword">return</span>;
        }
       <span class="error"> </span>
 <span class="comment">// the module's description is in the DUs attachments</span>
        <span class="directive">final</span> EEModuleDescription moduleDescription = deploymentUnit
                .getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);
        <span class="keyword">if</span> (moduleDescription == <span class="predefined-constant">null</span>) {
            <span class="keyword">return</span>;
        }
       <span class="error"> </span>
 <span class="comment">// add the java:module/ModuleName binding</span>
        <span class="comment">// the value's injection source for an immediate available value</span>
        <span class="directive">final</span> InjectionSource injectionSource = <span class="keyword">new</span> ImmediateInjectionSource(moduleDescription.getModuleName());
       <span class="error"> </span>
 <span class="comment">// add the binding configuration to the module's description bindings configurations</span>
        moduleDescription.getBindingConfigurations()
                .addDeploymentBinding(<span class="keyword">new</span> BindingConfiguration(JNDI_NAME_java_module_ModuleName, injectionSource));
    }
<span class="error"> </span>
    <span class="comment">//...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When adding the binding configuration use:
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>addDeploymentBinding() for a binding that may not be overriden, such
as the ones found in xml descriptors</p>
</li>
<li>
<p>addPlatformBinding() for a binding which may be overriden by a
deployment descriptor bind or annotation, for instance
java:comp/DefaultDatasource</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A deployment processor may now also add a binding configuration to all
components in a module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">    <span class="error"> </span>
moduleDescription.getBindingConfigurations().addPlatformBindingToAllComponents(bindingConfiguration);</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In the reworked implementation there is now no need to behave
differently considering the deployment type, for instance if deployment
is a WAR or app client, the Module/Component BindingConfigurations
objects handle all of that. The processor should simply go for the 3 use
cases: module binding, component binding or binding shared by all
components.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
All deployment binding configurations MUST be added before INSTALL
phase, this is needed because on such phase, when the bindings are
actually done, there must be a final set of deployment binding names
known, such information is need to understand if a resource injection
targets entries in the global or scoped EE namespaces.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most cases for adding bindings to EE deployments are in the context of a
processor deploying a XML descriptor, or scanning deployment classes for
annotations, and there abstract types, such as the
AbstractDeploymentDescriptorBindingsProcessor, which simplifies greatly
the processor code for such use cases.</p>
</div>
<div class="paragraph">
<p>One particular use case is the parsing of EE Resource Definitions, and
the reworked implementation provides high level abstract deployment
processors for both XML descriptor and annotations, an example for each:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">/**
 * Deployment processor responsible for processing administered-object deployment descriptor elements
 *
 * @author Eduardo Martins
 */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AdministeredObjectDefinitionDescriptorProcessor</span> <span class="directive">extends</span> ResourceDefinitionDescriptorProcessor {
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> processEnvironment(RemoteEnvironment environment, ResourceDefinitionInjectionSources injectionSources) <span class="directive">throws</span> DeploymentUnitProcessingException {
        <span class="directive">final</span> AdministeredObjectsMetaData metaDatas = environment.getAdministeredObjects();
        <span class="keyword">if</span> (metaDatas != <span class="predefined-constant">null</span>) {
            <span class="keyword">for</span>(AdministeredObjectMetaData metaData : metaDatas) {
                injectionSources.addResourceDefinitionInjectionSource(getResourceDefinitionInjectionSource(metaData));
            }
        }
    }
<span class="error"> </span>
    <span class="directive">private</span> ResourceDefinitionInjectionSource getResourceDefinitionInjectionSource(<span class="directive">final</span> AdministeredObjectMetaData metaData) {
        <span class="directive">final</span> <span class="predefined-type">String</span> name = metaData.getName();
        <span class="directive">final</span> <span class="predefined-type">String</span> className = metaData.getClassName();
        <span class="directive">final</span> <span class="predefined-type">String</span> resourceAdapter = metaData.getResourceAdapter();
        <span class="directive">final</span> AdministeredObjectDefinitionInjectionSource resourceDefinitionInjectionSource = <span class="keyword">new</span> AdministeredObjectDefinitionInjectionSource(name, className, resourceAdapter);
        resourceDefinitionInjectionSource.setInterface(metaData.getInterfaceName());
        <span class="keyword">if</span> (metaData.getDescriptions() != <span class="predefined-constant">null</span>) {
            resourceDefinitionInjectionSource.setDescription(metaData.getDescriptions().toString());
        }
        resourceDefinitionInjectionSource.addProperties(metaData.getProperties());
        <span class="keyword">return</span> resourceDefinitionInjectionSource;
    }
<span class="error"> </span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">/**
 * Deployment processor responsible for processing {@link jakarta.resource.AdministeredObjectDefinition} and {@link jakarta.resource.AdministeredObjectDefinitions}.
 *
 * @author Jesper Pedersen
 * @author Eduardo Martins
 */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AdministeredObjectDefinitionAnnotationProcessor</span> <span class="directive">extends</span> ResourceDefinitionAnnotationProcessor {
<span class="error"> </span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> DotName ANNOTATION_NAME = DotName.createSimple(AdministeredObjectDefinition.class.getName());
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> DotName COLLECTION_ANNOTATION_NAME = DotName.createSimple(AdministeredObjectDefinitions.class.getName());
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> DotName getAnnotationDotName() {
        <span class="keyword">return</span> ANNOTATION_NAME;
    }
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> DotName getAnnotationCollectionDotName() {
        <span class="keyword">return</span> COLLECTION_ANNOTATION_NAME;
    }
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> ResourceDefinitionInjectionSource processAnnotation(AnnotationInstance annotationInstance) <span class="directive">throws</span> DeploymentUnitProcessingException {
        <span class="directive">final</span> <span class="predefined-type">String</span> name = AnnotationElement.asRequiredString(annotationInstance, AnnotationElement.NAME);
        <span class="directive">final</span> <span class="predefined-type">String</span> className = AnnotationElement.asRequiredString(annotationInstance, <span class="string"><span class="delimiter">&quot;</span><span class="content">className</span><span class="delimiter">&quot;</span></span>);
        <span class="directive">final</span> <span class="predefined-type">String</span> ra = AnnotationElement.asRequiredString(annotationInstance, <span class="string"><span class="delimiter">&quot;</span><span class="content">resourceAdapter</span><span class="delimiter">&quot;</span></span>);
        <span class="directive">final</span> AdministeredObjectDefinitionInjectionSource directAdministeredObjectInjectionSource =
                <span class="keyword">new</span> AdministeredObjectDefinitionInjectionSource(name, className, ra);
        directAdministeredObjectInjectionSource.setDescription(AnnotationElement.asOptionalString(annotationInstance,
                AdministeredObjectDefinitionInjectionSource.DESCRIPTION));
        directAdministeredObjectInjectionSource.setInterface(AnnotationElement.asOptionalString(annotationInstance,
                AdministeredObjectDefinitionInjectionSource.INTERFACE));
        directAdministeredObjectInjectionSource.addProperties(AnnotationElement.asOptionalStringArray(annotationInstance,
                AdministeredObjectDefinitionInjectionSource.PROPERTIES));
        <span class="keyword">return</span> directAdministeredObjectInjectionSource;
    }
<span class="error"> </span>
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The abstract processors with respect to Resource Definitions are already
submitted through WFLY-3292&#8217;s PR.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resource-ref-processing"><a class="anchor" href="#resource-ref-processing"></a>6.4. Resource Ref Processing</h3>
<div class="paragraph">
<p>TODO for now no changes on this in the reworked WildFly Naming.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="CLI_extensibility_for_layered_products"><a class="anchor" href="#CLI_extensibility_for_layered_products"></a>7. CLI extensibility for layered products</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to supporting the ServiceLoader extension mechanism to load
command handlers coming from outside of the CLI codebase, starting from
the wildfly-core-1.0.0.Beta1 release the CLI running in a modular
classloading environment can be extended with commands exposed in server
extension modules. The CLI will look for and register extension commands
when it (re-)connects to the controller by iterating through the
registered by that time extensions and using the ServiceLoader mechanism
on the extension modules. (Note, that this mechanism will work only for
extensions available in the server installation the CLI is launched
from.)</p>
</div>
<div class="paragraph">
<p>Here is an example of a simple command handler and its integration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.jboss.as.test.cli.extensions</span>;<span class="directive">public</span> <span class="type">class</span> <span class="class">ExtCommandHandler</span> <span class="directive">extends</span> org.jboss.as.cli.handlers.CommandHandlerWithHelp { <span class="error"> </span><span class="error"> </span> <span class="error"> </span>
<span class="error"> </span>
<span class="keyword">package</span> <span class="namespace">org.jboss.as.test.cli.extensions</span>;
<span class="directive">public</span> <span class="type">class</span> <span class="class">ExtCommandHandler</span> <span class="directive">extends</span> org.jboss.as.cli.handlers.CommandHandlerWithHelp {
<span class="error"> </span>
<span class="error"> </span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">ext-command</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> OUTPUT = <span class="string"><span class="delimiter">&quot;</span><span class="content">hello world!</span><span class="delimiter">&quot;</span></span>;
<span class="error"> </span>
<span class="error"> </span>
    <span class="directive">public</span> CliExtCommandHandler() {
        <span class="local-variable">super</span>(NAME, <span class="predefined-constant">false</span>);
    }
<span class="error"> </span>
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> doHandle(CommandContext ctx) <span class="directive">throws</span> CommandLineException {
        ctx.printLine(OUTPUT);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command will simply print a message to the terminal. The next step
is to implement the CLI CommandHandlerProvider interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.jboss.as.test.cli.extensions</span>;
<span class="directive">public</span> <span class="type">class</span> <span class="class">ExtCommandHandlerProvider</span> <span class="directive">implements</span> org.jboss.as.cli.CommandHandlerProvider {
<span class="error"> </span>
<span class="error"> </span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> CommandHandler createCommandHandler(CommandContext ctx) {
        <span class="keyword">return</span> <span class="keyword">new</span> ExtCommandHandler();
    }
<span class="error"> </span>
<span class="error"> </span>
    <span class="comment">/**
     * Whether the command should be available in tab-completion.
     */</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> isTabComplete() {
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
<span class="error"> </span>
<span class="error"> </span>
    <span class="comment">/**
     * Command name(s).
     */</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span><span class="type">[]</span> getNames() {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">String</span><span class="type">[]</span>{ExtCommandHandler.NAME};
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final step is to include
<strong>META-INF/services/org.jboss.as.cli.CommandHandlerProvider</strong> entry into
the JAR file containing the classes above with value
<strong>org.jboss.as.test.cli.extensions.ExtCommandHandlerProvider</strong>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 29.0.0.Final<br>
Last updated 2023-06-22 14:37:11 -0500
</div>
</div>
</body>
</html>